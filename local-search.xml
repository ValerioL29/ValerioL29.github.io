<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>LeetCode Notes - 1</title>
    <link href="/2021/09/22/LeetCode-Notes-1/"/>
    <url>/2021/09/22/LeetCode-Notes-1/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-Notes-1"><a href="#Leetcode-Notes-1" class="headerlink" title="Leetcode Notes - 1"></a>Leetcode Notes - 1</h1><p>题目：<strong>1. 两数之和</strong></p><p>难度：<strong>简单</strong></p><p>遇见次数：<strong>第二次</strong></p><p>涉及知识点：</p><ul><li>数组</li><li>哈希表</li></ul><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="1-暴力枚举"><a href="#1-暴力枚举" class="headerlink" title="1. 暴力枚举"></a>1. 暴力枚举</h3><p><img src="../Picbed/image-20210725103759961.png" alt="image-20210725103759961"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] twoSum(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target) &#123;<br>        <span class="hljs-keyword">int</span> cur=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span>[] ans=<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;<br>        <br>        <span class="hljs-keyword">while</span>(i&lt;nums.length-<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">while</span>(j&lt;nums.length)&#123;<br>                cur=nums[i]+nums[j];<br>                <span class="hljs-keyword">if</span>(cur==target)&#123;<br>                    ans[<span class="hljs-number">0</span>]=i;<br>                    ans[<span class="hljs-number">1</span>]=j;<br>                &#125;<br>                j++;<br>            &#125;<br>            i++;<br>            j=i+<span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p>注意到方法一的时间复杂度较高的原因是寻找 <code>target - x</code> 的时间复杂度过高。因此，我们需要一种更优秀的方法，能够快速寻找数组中是否存在目标元素。如果存在，我们需要找出它的索引</p><p>使用哈希表，可以将寻找 <code>target - x</code> 的时间复杂度降低到从 <code>O(N)</code> 降低到 <code>O(1)</code></p><p>这样我们创建一个哈希表，对于每一个 x，我们首先查询哈希表中是否存在 <code>target - x</code>，然后将 x 插入到哈希表中，即可保证不会让 x 和自己匹配</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] twoSum(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target) &#123;<br>        Map&lt;Integer, Integer&gt; hashtable = <span class="hljs-keyword">new</span> HashMap&lt;Integer, Integer&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (hashtable.containsKey(target - nums[i])) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;hashtable.get(target - nums[i]), i&#125;;<br>            &#125;<br>            hashtable.put(nums[i], i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;<br><br>作者：LeetCode-Solution<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/two-sum/solution/liang-shu-zhi-he-by-leetcode-solution/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Notes - 25</title>
    <link href="/2021/09/22/LeetCode-Notes-25/"/>
    <url>/2021/09/22/LeetCode-Notes-25/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-Notes-25"><a href="#Leetcode-Notes-25" class="headerlink" title="Leetcode Notes - 25"></a>Leetcode Notes - 25</h1><p>题目：<strong>25. K个一组翻转链表</strong></p><p>难度：<strong>困难</strong></p><p>遇见次数：<strong>第二次</strong></p><p>涉及知识点：</p><ul><li>链表</li></ul><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="栈-快慢指针"><a href="#栈-快慢指针" class="headerlink" title="栈 + 快慢指针"></a>栈 + 快慢指针</h3><p>拉跨效率，不过很思路很流畅🛫</p><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210910112234627.png" alt="栈 + 快慢指针"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">reverseKGroup</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ListNode();<br><br>        ListNode dummy = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);<br>        ListNode tmp = dummy;<br>        Deque&lt;ListNode&gt; stk = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br><br>        <span class="hljs-keyword">while</span>(head != <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span>(head != <span class="hljs-keyword">null</span> &amp;&amp; i &lt; k)&#123;<br>                stk.push(head);<br>                head = head.next;<br>                i++;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span>(stk.size() &lt; k) <span class="hljs-keyword">break</span>;<br><br>            <span class="hljs-comment">// Rotating</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; k; j++)&#123;<br>                ListNode cur = stk.pop();<br>                tmp.next = cur;<br>                tmp = tmp.next;<br>            &#125;<br><br>            tmp.next = head;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h3><h4 id="思路及算法"><a href="#思路及算法" class="headerlink" title="思路及算法"></a>思路及算法</h4><p>ez</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">reverseKGroup</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        ListNode hair = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);<br>        hair.next = head;<br>        ListNode pre = hair;<br><br>        <span class="hljs-keyword">while</span> (head != <span class="hljs-keyword">null</span>) &#123;<br>            ListNode tail = pre;<br>            <span class="hljs-comment">// 查看剩余部分长度是否大于等于 k</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; ++i) &#123;<br>                tail = tail.next;<br>                <span class="hljs-keyword">if</span> (tail == <span class="hljs-keyword">null</span>) &#123;<br>                    <span class="hljs-keyword">return</span> hair.next;<br>                &#125;<br>            &#125;<br>            ListNode nex = tail.next;<br>            ListNode[] reverse = myReverse(head, tail);<br>            head = reverse[<span class="hljs-number">0</span>];<br>            tail = reverse[<span class="hljs-number">1</span>];<br>            <span class="hljs-comment">// 把子链表重新接回原链表</span><br>            pre.next = head;<br>            tail.next = nex;<br>            pre = tail;<br>            head = tail.next;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> hair.next;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> ListNode[] myReverse(ListNode head, ListNode tail) &#123;<br>        ListNode prev = tail.next;<br>        ListNode p = head;<br>        <span class="hljs-keyword">while</span> (prev != tail) &#123;<br>            ListNode nex = p.next;<br>            p.next = prev;<br>            prev = p;<br>            p = nex;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ListNode[]&#123;tail, head&#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Notes - 36</title>
    <link href="/2021/09/22/LeetCode-Notes-36/"/>
    <url>/2021/09/22/LeetCode-Notes-36/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-Notes-36"><a href="#Leetcode-Notes-36" class="headerlink" title="Leetcode Notes - 36"></a>Leetcode Notes - 36</h1><p>题目：36. 有效的数独</p><p>难度：<strong>中等</strong></p><p>遇见次数：<strong>第一次</strong></p><p>涉及知识点：</p><ul><li>数组</li><li>哈希表</li></ul><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="1-一次遍历"><a href="#1-一次遍历" class="headerlink" title="1. 一次遍历"></a>1. 一次遍历</h3><p>第一次内存消耗优于题解！🛫</p><p><img src="../Picbed/image-20210727190904647.png" alt="image-20210727190904647"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> Map&lt;Character, Integer&gt; rowMap = <span class="hljs-keyword">new</span> HashMap&lt;Character, Integer&gt;();<br>    <span class="hljs-keyword">public</span> Map&lt;Integer, HashMap&lt;Character, Integer&gt;&gt; colMap = <span class="hljs-keyword">new</span> HashMap&lt;Integer, HashMap&lt;Character, Integer&gt;&gt;();<br>    <span class="hljs-keyword">public</span> Map&lt;Integer, HashMap&lt;Character, Integer&gt;&gt; subBoxMap = <span class="hljs-keyword">new</span> HashMap&lt;Integer, HashMap&lt;Character, Integer&gt;&gt;();<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValidSudoku</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] board)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[] test = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">9</span>];<br><br>        <span class="hljs-keyword">int</span> curCol = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> curRow = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span>[] row : board)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> ele : row)&#123;<br>                <span class="hljs-comment">// Row map check</span><br>                <span class="hljs-comment">// System.out.println(ele);</span><br>                <span class="hljs-keyword">if</span>(ele == <span class="hljs-string">&#x27;.&#x27;</span>)&#123;<br>                    curCol++;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br><br>                <span class="hljs-keyword">if</span>(rowMap.containsKey(ele))&#123;<br>                    System.out.println(<span class="hljs-string">&quot;Return with the value of : &quot;</span> + ele);<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span>&#123;<br>                    rowMap.put(ele, <span class="hljs-number">1</span>);<br>                &#125;<br><br>                <span class="hljs-comment">// Column map check</span><br>                <span class="hljs-keyword">if</span>(colMap.containsKey(curCol))&#123;<br>                    <span class="hljs-keyword">if</span>((colMap.get(curCol)).containsKey(ele))&#123;<br>                        System.out.println(<span class="hljs-string">&quot;Return with the value of : &quot;</span> + ele + <span class="hljs-string">&quot; in column : &quot;</span> + curCol);<br>                        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">else</span>&#123;<br>                        (colMap.get(curCol)).put(ele, <span class="hljs-number">1</span>);<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">else</span>&#123;<br>                    HashMap&lt;Character, Integer&gt; newColmap = <span class="hljs-keyword">new</span> HashMap&lt;Character, Integer&gt;();<br><br>                    newColmap.put(ele, <span class="hljs-number">1</span>);<br><br>                    colMap.put(curCol, newColmap);<br>                &#125;<br><br>                <span class="hljs-comment">// SubBox check</span><br>                <span class="hljs-keyword">if</span>(!SubBoxcheck(curCol, curRow, ele))&#123;<br>                    System.out.println(<span class="hljs-string">&quot;SubBox check return&quot;</span>);<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>                &#125;<br><br>                curCol++;<br>            &#125;<br><br>            curCol = <span class="hljs-number">1</span>;<br>            curRow++;<br>            rowMap.clear();<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">SubBoxcheck</span><span class="hljs-params">(<span class="hljs-keyword">int</span> curCol, <span class="hljs-keyword">int</span> curRow, <span class="hljs-keyword">char</span> element)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> boxNo = subBoxNo(curCol, curRow);<br><br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.subBoxMap.containsKey(boxNo))&#123;<br>            HashMap&lt;Character, Integer&gt; curMap = <span class="hljs-keyword">this</span>.subBoxMap.get(boxNo);<br><br>            <span class="hljs-keyword">if</span>(curMap.containsKey(element))&#123;<br>                System.out.println(<span class="hljs-string">&quot;Return with value in subBox : &quot;</span> + boxNo);<br><br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                curMap.put(element, <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            HashMap&lt;Character, Integer&gt; curMap = <span class="hljs-keyword">new</span> HashMap&lt;Character, Integer&gt;();<br><br>            curMap.put(element, <span class="hljs-number">1</span>);<br><br>            <span class="hljs-keyword">this</span>.subBoxMap.put(boxNo, curMap);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">subBoxNo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> col, <span class="hljs-keyword">int</span> row)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(col &gt;= <span class="hljs-number">1</span> &amp;&amp; col &lt;= <span class="hljs-number">3</span> &amp;&amp; row &gt;= <span class="hljs-number">1</span> &amp;&amp; row &lt;= <span class="hljs-number">3</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(col &gt;= <span class="hljs-number">4</span> &amp;&amp; col &lt;= <span class="hljs-number">6</span> &amp;&amp; row &gt;= <span class="hljs-number">1</span> &amp;&amp; row &lt;= <span class="hljs-number">3</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(col &gt;= <span class="hljs-number">7</span> &amp;&amp; col &lt;= <span class="hljs-number">9</span> &amp;&amp; row &gt;= <span class="hljs-number">1</span> &amp;&amp; row &lt;= <span class="hljs-number">3</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(col &gt;= <span class="hljs-number">1</span> &amp;&amp; col &lt;= <span class="hljs-number">3</span> &amp;&amp; row &gt;= <span class="hljs-number">4</span> &amp;&amp; row &lt;= <span class="hljs-number">6</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">4</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(col &gt;= <span class="hljs-number">4</span> &amp;&amp; col &lt;= <span class="hljs-number">6</span> &amp;&amp; row &gt;= <span class="hljs-number">4</span> &amp;&amp; row &lt;= <span class="hljs-number">6</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">5</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(col &gt;= <span class="hljs-number">7</span> &amp;&amp; col &lt;= <span class="hljs-number">9</span> &amp;&amp; row &gt;= <span class="hljs-number">4</span> &amp;&amp; row &lt;= <span class="hljs-number">6</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">6</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(col &gt;= <span class="hljs-number">1</span> &amp;&amp; col &lt;= <span class="hljs-number">3</span> &amp;&amp; row &gt;= <span class="hljs-number">7</span> &amp;&amp; row &lt;= <span class="hljs-number">9</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">7</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(col &gt;= <span class="hljs-number">4</span> &amp;&amp; col &lt;= <span class="hljs-number">6</span> &amp;&amp; row &gt;= <span class="hljs-number">7</span> &amp;&amp; row &lt;= <span class="hljs-number">9</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">8</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(col &gt;= <span class="hljs-number">7</span> &amp;&amp; col &lt;= <span class="hljs-number">9</span> &amp;&amp; row &gt;= <span class="hljs-number">7</span> &amp;&amp; row &lt;= <span class="hljs-number">9</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">9</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="一次遍历"><a href="#一次遍历" class="headerlink" title="一次遍历"></a>一次遍历</h3><p>首先，让我们来讨论下面两个问题：</p><ul><li>如何枚举子数独？</li></ul><blockquote><p>可以使用 box_index = (row / 3) * 3 + columns / 3，其中 / 是整数除法。</p></blockquote><img src="../Picbed/2b141392e2a1811d0e8dfdf6279b1352e59fad0b3961908c6ff9412b6a7e7ccf-image.png" alt="image.png" style="zoom:50%;" /><ul><li>如何确保行 / 列 / 子数独中没有重复项？</li></ul><blockquote><p>可以利用 value -&gt; count 哈希映射来跟踪所有已经遇到的值。</p></blockquote><p>现在，我们完成了这个算法的所有准备工作：</p><ul><li>遍历数独。</li><li>检查看到每个单元格值是否已经在当前的行 / 列 / 子数独中出现过：<ul><li>如果出现重复，返回 false。</li><li>如果没有，则保留此值以进行进一步跟踪。</li></ul></li><li>返回 true。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValidSudoku</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] board)</span> </span>&#123;<br>    <span class="hljs-comment">// init data</span><br>    HashMap&lt;Integer, Integer&gt; [] rows = <span class="hljs-keyword">new</span> HashMap[<span class="hljs-number">9</span>];<br>    HashMap&lt;Integer, Integer&gt; [] columns = <span class="hljs-keyword">new</span> HashMap[<span class="hljs-number">9</span>];<br>    HashMap&lt;Integer, Integer&gt; [] boxes = <span class="hljs-keyword">new</span> HashMap[<span class="hljs-number">9</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++) &#123;<br>      rows[i] = <span class="hljs-keyword">new</span> HashMap&lt;Integer, Integer&gt;();<br>      columns[i] = <span class="hljs-keyword">new</span> HashMap&lt;Integer, Integer&gt;();<br>      boxes[i] = <span class="hljs-keyword">new</span> HashMap&lt;Integer, Integer&gt;();<br>    &#125;<br><br>    <span class="hljs-comment">// validate a board</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++) &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">9</span>; j++) &#123;<br>        <span class="hljs-keyword">char</span> num = board[i][j];<br>        <span class="hljs-keyword">if</span> (num != <span class="hljs-string">&#x27;.&#x27;</span>) &#123;<br>          <span class="hljs-keyword">int</span> n = (<span class="hljs-keyword">int</span>)num;<br>          <span class="hljs-keyword">int</span> box_index = (i / <span class="hljs-number">3</span> ) * <span class="hljs-number">3</span> + j / <span class="hljs-number">3</span>;<br><br>          <span class="hljs-comment">// keep the current cell value</span><br>          rows[i].put(n, rows[i].getOrDefault(n, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>          columns[j].put(n, columns[j].getOrDefault(n, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>          boxes[box_index].put(n, boxes[box_index].getOrDefault(n, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br><br>          <span class="hljs-comment">// check if this value has been already seen before</span><br>          <span class="hljs-keyword">if</span> (rows[i].get(n) &gt; <span class="hljs-number">1</span> || columns[j].get(n) &gt; <span class="hljs-number">1</span> || boxes[box_index].get(n) &gt; <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>  &#125;<br>&#125;<br><br>作者：LeetCode<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/valid-sudoku/solution/you-xiao-de-shu-du-by-leetcode/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Notes - 53</title>
    <link href="/2021/09/22/LeetCode-Notes-53/"/>
    <url>/2021/09/22/LeetCode-Notes-53/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-Notes-53"><a href="#Leetcode-Notes-53" class="headerlink" title="Leetcode Notes - 53"></a>Leetcode Notes - 53</h1><p>题目：53. 最大连续子序和</p><p>难度：<strong>简单</strong></p><p>遇见次数：<strong>第一次</strong></p><p>涉及知识点：</p><ul><li>动态规划</li><li>分治</li></ul><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="1-动态规划"><a href="#1-动态规划" class="headerlink" title="1. 动态规划"></a>1. 动态规划</h3><p><img src="../Picbed/image-20210723111206252.png" alt="image-20210723111206252"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> len = nums.length;<br><br>        <span class="hljs-keyword">if</span>(len == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(len == <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        &#125;<br><br>        <span class="hljs-keyword">int</span>[] sum = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len];<br>        sum[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">int</span> max = sum[<span class="hljs-number">0</span>];<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; len; i++)&#123;<br>            <span class="hljs-keyword">if</span>(sum[i - <span class="hljs-number">1</span>] &gt;= <span class="hljs-number">0</span>)&#123;<br>                sum[i] = nums[i] + sum[i - <span class="hljs-number">1</span>];<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                sum[i] = nums[i];<br>            &#125;<br><br>            <span class="hljs-keyword">if</span>(sum[i] &gt; max)&#123;<br>                max = sum[i];<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="1-动态规划-1"><a href="#1-动态规划-1" class="headerlink" title="1. 动态规划"></a>1. 动态规划</h3><p>动态规划的是首先对数组进行遍历，当前最大连续子序列和为 sum，结果为 ans</p><ul><li>如果 sum &gt; 0，则说明 sum 对结果有增益效果，则 sum 保留并加上当前遍历数字</li><li>如果 sum &lt;= 0，则说明 sum 对结果无增益效果，需要舍弃，则 sum 直接更新为当前遍历数字</li><li>每次比较 sum 和 ans的大小，将最大值置为ans，遍历结束返回结果</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> pre = <span class="hljs-number">0</span>, maxAns = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x : nums) &#123;<br>            pre = Math.max(pre + x, x);<br>            maxAns = Math.max(maxAns, pre);<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxAns;<br>    &#125;<br>&#125;<br><br>作者：LeetCode-Solution<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/maximum-subarray/solution/zui-da-zi-xu-he-by-leetcode-solution/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h3 id="2-分治法"><a href="#2-分治法" class="headerlink" title="2. 分治法"></a>2. 分治法</h3><p>分治法的思路是这样的，其实也是分类讨论</p><p>连续子序列的最大和主要由这三部分子区间里元素的最大和得到：</p><ul><li>第 1 部分：子区间 [left, mid]</li><li>第 2 部分：子区间 [mid + 1, right]</li><li>第 3 部分：包含子区间 [mid , mid + 1] 的子区间，即 nums[mid] 与 nums[mid + 1] 一定会被选取</li></ul><p>对这三个部分求最大值即可</p><p>说明：考虑第 3 部分跨越两个区间的连续子数组的时候，由于 nums[mid] 与 nums[mid + 1] 一定会被选取，可以从中间向两边扩散，扩散到底 选出最大值</p><p><img src="https://pic.leetcode-cn.com/1621840913-dcvfVD-image.png" alt="image.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> len = nums.length;<br>        <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxSubArraySum(nums, <span class="hljs-number">0</span>, len - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxCrossingSum</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> mid, <span class="hljs-keyword">int</span> right)</span> </span>&#123;<br>        <span class="hljs-comment">// 一定会包含 nums[mid] 这个元素</span><br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> leftSum = Integer.MIN_VALUE;<br>        <span class="hljs-comment">// 左半边包含 nums[mid] 元素，最多可以到什么地方</span><br>        <span class="hljs-comment">// 走到最边界，看看最值是什么</span><br>        <span class="hljs-comment">// 计算以 mid 结尾的最大的子数组的和</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = mid; i &gt;= left; i--) &#123;<br>            sum += nums[i];<br>            <span class="hljs-keyword">if</span> (sum &gt; leftSum) &#123;<br>                leftSum = sum;<br>            &#125;<br>        &#125;<br>        sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> rightSum = Integer.MIN_VALUE;<br>        <span class="hljs-comment">// 右半边不包含 nums[mid] 元素，最多可以到什么地方</span><br>        <span class="hljs-comment">// 计算以 mid+1 开始的最大的子数组的和</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = mid + <span class="hljs-number">1</span>; i &lt;= right; i++) &#123;<br>            sum += nums[i];<br>            <span class="hljs-keyword">if</span> (sum &gt; rightSum) &#123;<br>                rightSum = sum;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> leftSum + rightSum;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArraySum</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (left == right) &#123;<br>            <span class="hljs-keyword">return</span> nums[left];<br>        &#125;<br>        <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">return</span> max3(maxSubArraySum(nums, left, mid),<br>                maxSubArraySum(nums, mid + <span class="hljs-number">1</span>, right),<br>                maxCrossingSum(nums, left, mid, right));<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">max3</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num1, <span class="hljs-keyword">int</span> num2, <span class="hljs-keyword">int</span> num3)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> Math.max(num1, Math.max(num2, num3));<br>    &#125;<br>&#125;<br><br>作者：liweiwei1419<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/maximum-subarray/solution/dong-tai-gui-hua-fen-zhi-fa-python-dai-ma-java-dai/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Notes - 73</title>
    <link href="/2021/09/22/LeetCode-Notes-73/"/>
    <url>/2021/09/22/LeetCode-Notes-73/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-Notes-73"><a href="#Leetcode-Notes-73" class="headerlink" title="Leetcode Notes - 73"></a>Leetcode Notes - 73</h1><p>题目：73. 矩阵置零</p><p>难度：<strong>中等</strong></p><p>遇见次数：<strong>第一次</strong></p><p>涉及知识点：</p><ul><li>数组</li><li>原地算法</li></ul><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="两次遍历"><a href="#两次遍历" class="headerlink" title="两次遍历"></a>两次遍历</h3><p>Quite slow, but available</p><p><img src="../Picbed/image-20210727185953618.png" alt="image-20210727185953618"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> ArrayList&lt;Integer&gt; rowZeros = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>    <span class="hljs-keyword">public</span> ArrayList&lt;Integer&gt; colZeros = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setZeroes</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> curRow = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> curCol = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span>[] row1 : matrix)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> ele1 : row1)&#123;<br>                <span class="hljs-keyword">if</span>(ele1 == <span class="hljs-number">0</span>)&#123;<br>                    <span class="hljs-keyword">this</span>.rowZeros.add(curRow);<br>                    <span class="hljs-keyword">this</span>.colZeros.add(curCol);<br>                &#125;<br><br>                curCol++;<br>            &#125;<br><br>            curRow++;<br>            curCol = <span class="hljs-number">1</span>;<br>        &#125;<br><br>        curRow = <span class="hljs-number">1</span>;<br>        curCol = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span>[] row2 : matrix)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> ele2 : row2)&#123;<br>                <span class="hljs-keyword">if</span>(checkWhetherZero(curRow, curCol))&#123;<br>                    matrix[curRow - <span class="hljs-number">1</span>][curCol - <span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>                &#125;<br><br>                curCol++;<br>            &#125;<br><br>            curRow++;<br>            curCol = <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">checkWhetherZero</span><span class="hljs-params">(<span class="hljs-keyword">int</span> row, <span class="hljs-keyword">int</span> col)</span></span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i : <span class="hljs-keyword">this</span>.rowZeros)&#123;<br>            <span class="hljs-keyword">if</span>(row == i)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j : <span class="hljs-keyword">this</span>.colZeros)&#123;<br>            <span class="hljs-keyword">if</span>(col == j)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="首行首列记录置零信息-O-1-空间复杂度"><a href="#首行首列记录置零信息-O-1-空间复杂度" class="headerlink" title="首行首列记录置零信息 - O(1) 空间复杂度"></a>首行首列记录置零信息 - O(1) 空间复杂度</h3><p><strong>1. 使用两个变量（r0 &amp; c0），记录「首行 &amp; 首列」是否该被置零</strong></p><p><img src="../Picbed/1616292004-JWVOyl-image.png" alt="image.png"></p><p><strong>2.「非首行首列」的位置</strong></p><ul><li>将置零信息存储到原矩阵</li><li>根据置零信息，置零「非首行首列」的位置</li></ul><p><img src="../Picbed/1616291987-UnBQcI-image.png" alt="image.png"></p><p><strong>3. 使用 r0 &amp; c0 ，置零「首行 &amp; 首列」</strong></p><p><img src="../Picbed/1616292108-mznYHo-image.png" alt="image.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setZeroes</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] mat)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> m = mat.length, n = mat[<span class="hljs-number">0</span>].length;<br><br>        <span class="hljs-comment">// 1. 扫描「首行」和「首列」记录「首行」和「首列」是否该被置零</span><br>        <span class="hljs-keyword">boolean</span> r0 = <span class="hljs-keyword">false</span>, c0 = <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">if</span> (mat[i][<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>) &#123;<br>                r0 = <span class="hljs-keyword">true</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>            <span class="hljs-keyword">if</span> (mat[<span class="hljs-number">0</span>][j] == <span class="hljs-number">0</span>) &#123;<br>                c0 = <span class="hljs-keyword">true</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 2.1 扫描「非首行首列」的位置，如果发现零，将需要置零的信息存储到该行的「最左方」和「最上方」的格子内</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (mat[i][j] == <span class="hljs-number">0</span>) &#123;<br>                    mat[i][<span class="hljs-number">0</span>] = mat[<span class="hljs-number">0</span>][j] = <span class="hljs-number">0</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 2.2 根据刚刚记录在「最左方」和「最上方」格子内的置零信息，进行「非首行首列」置零</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>            <span class="hljs-keyword">if</span> (mat[<span class="hljs-number">0</span>][j] == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++) &#123;<br>                    mat[i][j] = <span class="hljs-number">0</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">if</span> (mat[i][<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>) &#123;<br>                Arrays.fill(mat[i], <span class="hljs-number">0</span>);<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 3. 根据最开始记录的「首行」和「首列」信息，进行「首行首列」置零</span><br>        <span class="hljs-keyword">if</span> (r0) <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) mat[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (c0) Arrays.fill(mat[<span class="hljs-number">0</span>], <span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br><br>作者：AC_OIer<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/set-matrix-zeroes/solution/xiang-jie-fen-san-bu-de-o1-kong-jian-jie-dbxd/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Notes - 88</title>
    <link href="/2021/09/22/LeetCode-Notes-88/"/>
    <url>/2021/09/22/LeetCode-Notes-88/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-Notes-88"><a href="#Leetcode-Notes-88" class="headerlink" title="Leetcode Notes - 88"></a>Leetcode Notes - 88</h1><p>题目：88. 合并两个有序数组</p><p>难度：<strong>简单</strong></p><p>遇见次数：<strong>第二次</strong></p><p>涉及知识点：</p><ul><li>排序</li><li>数组</li><li>双指针</li></ul><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="1-逆向三指针"><a href="#1-逆向三指针" class="headerlink" title="1. 逆向三指针"></a>1. 逆向三指针</h3><p><img src="../Picbed/image-20210725105531690.png" alt="image-20210725105531690"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums1, <span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span>[] nums2, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> p1 = m - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> p2 = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> p3 = m + n - <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)&#123;<br>            <span class="hljs-keyword">if</span>(p1 == -<span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">while</span>(p2 &gt;= <span class="hljs-number">0</span>)&#123;<br>                    nums1[p3] = nums2[p2];<br>                    p3--;<br>                    p2--;<br>                &#125;<br><br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span>(p2 == -<span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">while</span>(p1 &gt;= <span class="hljs-number">0</span>)&#123;<br>                    nums1[p3] = nums1[p1];<br>                    p3--;<br>                    p1--;<br>                &#125;<br><br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span>(nums1[p1] &gt; nums2[p2])&#123;<br>                nums1[p3] = nums1[p1];<br>                p3--;<br>                p1--;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                nums1[p3] = nums2[p2];<br>                p3--;<br>                p2--;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="逆向双指针"><a href="#逆向双指针" class="headerlink" title="逆向双指针"></a>逆向双指针</h3><p><img src="../Picbed/image-20210725105712911.png" alt="image-20210725105712911"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums1, <span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span>[] nums2, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> p1 = m - <span class="hljs-number">1</span>, p2 = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> tail = m + n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> cur;<br>        <span class="hljs-keyword">while</span> (p1 &gt;= <span class="hljs-number">0</span> || p2 &gt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (p1 == -<span class="hljs-number">1</span>) &#123;<br>                cur = nums2[p2--];<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p2 == -<span class="hljs-number">1</span>) &#123;<br>                cur = nums1[p1--];<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums1[p1] &gt; nums2[p2]) &#123;<br>                cur = nums1[p1--];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                cur = nums2[p2--];<br>            &#125;<br>            nums1[tail--] = cur;<br>        &#125;<br>    &#125;<br>&#125;<br><br>作者：LeetCode-Solution<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/merge-sorted-array/solution/he-bing-liang-ge-you-xu-shu-zu-by-leetco-rrb0/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Notes - 104</title>
    <link href="/2021/09/22/LeetCode-Notes-104/"/>
    <url>/2021/09/22/LeetCode-Notes-104/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-Notes-104"><a href="#Leetcode-Notes-104" class="headerlink" title="Leetcode Notes - 104"></a>Leetcode Notes - 104</h1><p>题目：<strong>104. 二叉树的最大深度</strong></p><p>难度：<strong>简单</strong></p><p>遇见次数：<strong>第一次</strong></p><p>涉及知识点：</p><ul><li>深度优先搜索</li><li>二叉树</li></ul><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="1-深度优先搜索"><a href="#1-深度优先搜索" class="headerlink" title="1. 深度优先搜索"></a>1. 深度优先搜索</h3><p>递归遍历找2的n次方 - 1的奇技淫巧被现场捕获🤣重写一个DFS</p><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210802174129492.png" alt="提交情况"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">int</span> maxLeft = maxDepth(root.left);<br>            <span class="hljs-keyword">int</span> maxRight = maxDepth(root.right);<br><br>            <span class="hljs-keyword">return</span> Math.max(maxLeft, maxRight) + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h3><p>思路与算法</p><p>如果我们知道了左子树和右子树的最大深度 left 和 right，那么该二叉树的最大深度即为：</p><blockquote><p>max (left, right) + 1 </p></blockquote><p>而左子树和右子树的最大深度又可以以同样的方式进行计算。因此我们可以用「深度优先搜索」的方法来计算二叉树的最大深度。具体而言，在计算当前二叉树的最大深度时，可以先递归计算出其左子树和右子树的最大深度，然后在 O(1) 时间内计算出当前二叉树的最大深度。递归在访问到空节点时退出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Notes - 121</title>
    <link href="/2021/09/22/LeetCode-Notes-121/"/>
    <url>/2021/09/22/LeetCode-Notes-121/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-Notes-121"><a href="#Leetcode-Notes-121" class="headerlink" title="Leetcode Notes - 121"></a>Leetcode Notes - 121</h1><p>题目：121. 买卖股票的最佳时机</p><p>难度：<strong>简单</strong></p><p>遇见次数：<strong>第一次</strong></p><p>涉及知识点：</p><ul><li>排序</li><li>哈希表</li></ul><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>好耶！</p><p><img src="../Picbed/image-20210725164118321.png" alt="image-20210725164118321"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] prices)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> len = prices.length;<br>        <span class="hljs-keyword">if</span>(len &lt;= <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> buyIn = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> sellOut = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> max = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span>(sellOut &lt; len)&#123;<br>            <span class="hljs-keyword">int</span> profit = prices[sellOut] - prices[buyIn];<br><br>            <span class="hljs-keyword">if</span>(profit &lt; <span class="hljs-number">0</span>)&#123;<br>                buyIn = sellOut;<br>                sellOut = buyIn + <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span>(profit &gt;= <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">if</span>(max &lt; profit)&#123;<br>                    max = profit;<br>                &#125;<br><br>                sellOut++;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>        &#125;        <br><br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="一次遍历"><a href="#一次遍历" class="headerlink" title="一次遍历"></a>一次遍历</h3><p>假设给定的数组为：<code>[7, 1, 5, 3, 6, 4]</code></p><p>如果我们在图表上绘制给定数组中的数字，我们将会得到：</p><p>我们来假设自己来购买股票。随着时间的推移，每天我们都可以选择出售股票与否。那么，假设在第 <code>i</code> 天，如果我们要在今天卖股票，那么我们能赚多少钱呢？</p><p>显然，如果我们真的在买卖股票，我们肯定会想：如果我是在历史最低点买的股票就好了！太好了，在题目中，我们只要用一个变量记录一个历史最低价格 <code>minprice</code>，我们就可以假设自己的股票是在那天买的。那么我们在第 <code>i</code> 天卖出股票能得到的利润就是 <code>prices[i] - minprice</code></p><p>因此，我们只需要遍历价格数组一遍，记录历史最低点，然后在每一天考虑这么一个问题：如果我是在历史最低点买进的，那么我今天卖出能赚多少钱？当考虑完所有天数之时，我们就得到了最好的答案。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> prices[])</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> minprice = Integer.MAX_VALUE;<br>        <span class="hljs-keyword">int</span> maxprofit = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; prices.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (prices[i] &lt; minprice) &#123;<br>                minprice = prices[i];<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (prices[i] - minprice &gt; maxprofit) &#123;<br>                maxprofit = prices[i] - minprice;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxprofit;<br>    &#125;<br>&#125;<br><br>作者：LeetCode-Solution<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/solution/121-mai-mai-gu-piao-de-zui-jia-shi-ji-by-leetcode-/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Notes - 143</title>
    <link href="/2021/09/22/LeetCode-Notes-143/"/>
    <url>/2021/09/22/LeetCode-Notes-143/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-Notes-143"><a href="#Leetcode-Notes-143" class="headerlink" title="Leetcode Notes - 143"></a>Leetcode Notes - 143</h1><p>题目：<strong>143. 重排链表</strong></p><p>难度：<strong>中等</strong></p><p>遇见次数：<strong>第二次</strong></p><p>涉及知识点：</p><ul><li>链表</li></ul><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="两次遍历-双向链表"><a href="#两次遍历-双向链表" class="headerlink" title="两次遍历+双向链表"></a>两次遍历+双向链表</h3><p>效率非常拉，不过这是很直接的一种办法了😊</p><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210910120055352.png" alt="两次遍历+双向链表"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reorderList</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-keyword">null</span> || head.next == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span>;<br><br>        LinkedList&lt;ListNode&gt; myList = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        ListNode dummy = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">while</span>(head != <span class="hljs-keyword">null</span>)&#123;<br>            myList.addLast(head);<br>            head = head.next;<br>        &#125;<br><br>        ListNode tmp = dummy;<br>        <span class="hljs-keyword">while</span>(myList.size() &gt;= <span class="hljs-number">2</span>)&#123;<br>            ListNode left = myList.removeFirst();<br>            ListNode right = myList.removeLast();<br><br>            tmp.next = left;<br>            left.next = right;<br>            tmp = tmp.next.next;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(myList.size() == <span class="hljs-number">1</span>)&#123;<br>            ListNode cur = myList.poll();<br>            tmp.next = cur;<br>            cur.next = <span class="hljs-keyword">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            tmp.next = <span class="hljs-keyword">null</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="寻找链表中点-链表逆序-合并链表"><a href="#寻找链表中点-链表逆序-合并链表" class="headerlink" title="寻找链表中点 + 链表逆序 + 合并链表"></a>寻找链表中点 + 链表逆序 + 合并链表</h3><h4 id="思路及算法"><a href="#思路及算法" class="headerlink" title="思路及算法"></a>思路及算法</h4><p>注意到目标链表即为将原链表的左半端和反转后的右半端合并后的结果。</p><p>这样我们的任务即可划分为三步：</p><ol><li><p>找到原链表的中点</p><ul><li>我们可以使用快慢指针来 O(N) 地找到链表的中间节点。</li></ul></li><li><p>将原链表的右半端反转</p><ul><li>我们可以使用迭代法实现链表的反转</li></ul></li><li><p>将原链表的两端合并</p></li></ol><p>因为两链表长度相差不超过 1，因此直接合并即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reorderList</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        ListNode mid = middleNode(head);<br>        ListNode l1 = head;<br>        ListNode l2 = mid.next;<br>        mid.next = <span class="hljs-keyword">null</span>;<br>        l2 = reverseList(l2);<br>        mergeList(l1, l2);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">middleNode</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>        ListNode slow = head;<br>        ListNode fast = head;<br>        <span class="hljs-keyword">while</span> (fast.next != <span class="hljs-keyword">null</span> &amp;&amp; fast.next.next != <span class="hljs-keyword">null</span>) &#123;<br>            slow = slow.next;<br>            fast = fast.next.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>        ListNode prev = <span class="hljs-keyword">null</span>;<br>        ListNode curr = head;<br>        <span class="hljs-keyword">while</span> (curr != <span class="hljs-keyword">null</span>) &#123;<br>            ListNode nextTemp = curr.next;<br>            curr.next = prev;<br>            prev = curr;<br>            curr = nextTemp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> prev;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mergeList</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> </span>&#123;<br>        ListNode l1_tmp;<br>        ListNode l2_tmp;<br>        <span class="hljs-keyword">while</span> (l1 != <span class="hljs-keyword">null</span> &amp;&amp; l2 != <span class="hljs-keyword">null</span>) &#123;<br>            l1_tmp = l1.next;<br>            l2_tmp = l2.next;<br><br>            l1.next = l2;<br>            l1 = l1_tmp;<br><br>            l2.next = l1;<br>            l2 = l2_tmp;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Notes - 144</title>
    <link href="/2021/09/22/LeetCode-Notes-144/"/>
    <url>/2021/09/22/LeetCode-Notes-144/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-Notes-144"><a href="#Leetcode-Notes-144" class="headerlink" title="Leetcode Notes - 144"></a>Leetcode Notes - 144</h1><p>题目：<strong>144. 二叉树的前序遍历</strong></p><p>难度：<strong>简单</strong></p><p>遇见次数：<strong>第一次</strong></p><p>涉及知识点：</p><ul><li>栈</li></ul><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="1-递归"><a href="#1-递归" class="headerlink" title="1. 递归"></a>1. 递归</h3><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210801102323990.png" alt="提交情况"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    List&lt;Integer&gt; ans = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>        &#125;<br><br>        <span class="hljs-keyword">this</span>.ans.add(root.val);<br><br>        preorderTraversal(root.left);<br>        preorderTraversal(root.right);<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="Morris-遍历"><a href="#Morris-遍历" class="headerlink" title="Morris 遍历"></a>Morris 遍历</h3><h4 id="思路与算法"><a href="#思路与算法" class="headerlink" title="思路与算法"></a>思路与算法</h4><p><strong>记作当前节点为cur。</strong></p><ol><li><p>如果cur无左孩子，cur向右移动（cur=cur.right）</p></li><li><p>如果cur有左孩子，找到cur左子树上最右的节点，记为mostRight</p></li><li><ul><li>如果mostRight的right指针指向空，让其指向cur，cur向左移动（cur=cur.left）</li><li>如果mostRight的right指针指向cur，让其指向空，cur向右移动（cur=cur.right）</li></ul></li></ol><p>实现以上的原则，即实现了morris遍历。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br><br>        TreeNode p1 = root, p2 = <span class="hljs-keyword">null</span>;<br><br>        <span class="hljs-keyword">while</span> (p1 != <span class="hljs-keyword">null</span>) &#123;<br>            p2 = p1.left;<br>            <span class="hljs-keyword">if</span> (p2 != <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">while</span> (p2.right != <span class="hljs-keyword">null</span> &amp;&amp; p2.right != p1) &#123;<br>                    p2 = p2.right;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (p2.right == <span class="hljs-keyword">null</span>) &#123;<br>                    res.add(p1.val);<br>                    p2.right = p1;<br>                    p1 = p1.left;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    p2.right = <span class="hljs-keyword">null</span>;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                res.add(p1.val);<br>            &#125;<br>            p1 = p1.right;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br><br>作者：LeetCode-Solution<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/binary-tree-preorder-traversal/solution/er-cha-shu-de-qian-xu-bian-li-by-leetcode-solution/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Notes - 173</title>
    <link href="/2021/09/22/LeetCode-Notes-173/"/>
    <url>/2021/09/22/LeetCode-Notes-173/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-Notes-173"><a href="#Leetcode-Notes-173" class="headerlink" title="Leetcode Notes - 173"></a>Leetcode Notes - 173</h1><p>题目：<strong>173. 二叉搜索树的迭代器</strong></p><p>难度：<strong>中等</strong></p><p>遇见次数：<strong>第二次</strong></p><p>涉及知识点：</p><ul><li>二叉搜索树</li><li>构造迭代器</li></ul><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="中序遍历-队列"><a href="#中序遍历-队列" class="headerlink" title="中序遍历+队列"></a>中序遍历+队列</h3><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210919233513940.png" alt="中序遍历+队列"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BSTIterator</span> </span>&#123;<br>    LinkedList&lt;Integer&gt; deck;<br>    <span class="hljs-keyword">int</span> index = -<span class="hljs-number">1</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BSTIterator</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.deck = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        inorder(root);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">inorder</span><span class="hljs-params">(TreeNode root)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span>;<br>        inorder(root.left);<br>        <span class="hljs-keyword">this</span>.deck.offer(root.val);<br>        inorder(root.right);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.index++;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.deck.get(<span class="hljs-keyword">this</span>.index);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> size = <span class="hljs-keyword">this</span>.deck.size();<br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.index &lt; size - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your BSTIterator object will be instantiated and called as such:</span><br><span class="hljs-comment"> * BSTIterator obj = new BSTIterator(root);</span><br><span class="hljs-comment"> * int param_1 = obj.next();</span><br><span class="hljs-comment"> * boolean param_2 = obj.hasNext();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="扁平化"><a href="#扁平化" class="headerlink" title="扁平化"></a>扁平化</h3><h4 id="思路及算法"><a href="#思路及算法" class="headerlink" title="思路及算法"></a>思路及算法</h4><p>直接对二叉搜索树做一次完全的递归遍历，获取中序遍历的全部结果并保存在数组中。随后，我们利用得到的数组本身来实现迭代器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BSTIterator</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> idx;<br>    <span class="hljs-keyword">private</span> List&lt;Integer&gt; arr;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BSTIterator</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        idx = <span class="hljs-number">0</span>;<br>        arr = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>        inorderTraversal(root, arr);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> arr.get(idx++);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> idx &lt; arr.size();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode root, List&lt;Integer&gt; arr)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        inorderTraversal(root.left, arr);<br>        arr.add(root.val);<br>        inorderTraversal(root.right, arr);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>很好，数组</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Leetcode Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Notes - 215</title>
    <link href="/2021/09/22/LeetCode-Notes-215/"/>
    <url>/2021/09/22/LeetCode-Notes-215/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-Notes-215"><a href="#Leetcode-Notes-215" class="headerlink" title="Leetcode Notes - 215"></a>Leetcode Notes - 215</h1><p>题目：<strong>215. 数组中的第K个最大元素</strong></p><p>难度：<strong>中等</strong></p><p>遇见次数：<strong>第一次</strong></p><p>涉及知识点：</p><ul><li>大根堆</li><li>优先队列</li></ul><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h3><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210920001957965.png" alt="优先队列"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        PriorityQueue&lt;Integer&gt; myPq = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;(k,(a, b) -&gt; a - b);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i : nums)&#123;<br>            myPq.add(i);<br>            <span class="hljs-keyword">if</span>(myPq.size() &gt; k) myPq.poll();<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> myPq.peek();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><h4 id="思路及算法"><a href="#思路及算法" class="headerlink" title="思路及算法"></a>思路及算法</h4><p>使用堆排序来解决这个问题——建立一个大根堆，做 k − 1 次删除操作后堆顶元素就是我们要找的答案</p><p>在很多语言中，都有优先队列或者堆的的容器可以直接使用，但是在面试中，面试官更倾向于让更面试者自己实现一个堆</p><p>所以建议读者掌握这里大根堆的实现方法，在这道题中尤其要搞懂「建堆」、「调整」和「删除」的过程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> heapSize = nums.length;<br>        buildMaxHeap(nums, heapSize);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = nums.length - <span class="hljs-number">1</span>; i &gt;= nums.length - k + <span class="hljs-number">1</span>; --i) &#123;<br>            swap(nums, <span class="hljs-number">0</span>, i);<br>            --heapSize;<br>            maxHeapify(nums, <span class="hljs-number">0</span>, heapSize);<br>        &#125;<br>        <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildMaxHeap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] a, <span class="hljs-keyword">int</span> heapSize)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = heapSize / <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>            maxHeapify(a, i, heapSize);<br>        &#125; <br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">maxHeapify</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] a, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> heapSize)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> l = i * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>, r = i * <span class="hljs-number">2</span> + <span class="hljs-number">2</span>, largest = i;<br>        <span class="hljs-keyword">if</span> (l &lt; heapSize &amp;&amp; a[l] &gt; a[largest]) &#123;<br>            largest = l;<br>        &#125; <br>        <span class="hljs-keyword">if</span> (r &lt; heapSize &amp;&amp; a[r] &gt; a[largest]) &#123;<br>            largest = r;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (largest != i) &#123;<br>            swap(a, i, largest);<br>            maxHeapify(a, largest, heapSize);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] a, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> temp = a[i];<br>        a[i] = a[j];<br>        a[j] = temp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Notes - 217</title>
    <link href="/2021/09/22/LeetCode-Notes-217/"/>
    <url>/2021/09/22/LeetCode-Notes-217/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-Notes-217"><a href="#Leetcode-Notes-217" class="headerlink" title="Leetcode Notes - 217"></a>Leetcode Notes - 217</h1><p>题目：<strong>217. 存在重复的元素</strong></p><p>难度：<strong>简单</strong></p><p>遇见次数：<strong>第一次</strong></p><p>涉及知识点：</p><ul><li>排序</li><li>哈希表</li></ul><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="1-内置快排"><a href="#1-内置快排" class="headerlink" title="1. 内置快排"></a>1. 内置快排</h3><p><img src="../Picbed/image-20210723102725977.png" alt="image-20210723102725977"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">containsDuplicate</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> len = nums.length;<br><br>        <span class="hljs-keyword">if</span>(len == <span class="hljs-number">0</span> || len == <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br><br>        Arrays.sort(nums);<br><br>        <span class="hljs-keyword">int</span>[] check  = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)&#123;<br>            <span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span>)&#123;<br>                check[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span>(nums[i] == check[<span class="hljs-number">0</span>])&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                check[<span class="hljs-number">0</span>] = nums[i];<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-哈希表"><a href="#2-哈希表" class="headerlink" title="2. 哈希表"></a>2. 哈希表</h3><p><img src="../Picbed/image-20210723103805642.png" alt="image-20210723103805642"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">containsDuplicate</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> len = nums.length;<br><br>        <span class="hljs-keyword">if</span>(len == <span class="hljs-number">0</span> || len == <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br><br>        HashMap&lt;Integer, Integer&gt; myHashmap = <span class="hljs-keyword">new</span> HashMap&lt;Integer, Integer&gt;();<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i : nums)&#123;<br>            <span class="hljs-keyword">int</span> val = myHashmap.getOrDefault(i, <span class="hljs-number">0</span>);<br><br>            <span class="hljs-keyword">if</span>(val == <span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>            <br>            <span class="hljs-keyword">if</span>(val == <span class="hljs-number">0</span>)&#123;<br>                myHashmap.put(i, <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p>利用集合不能添加重复元素的特性</p><p>对于数组中每个元素，我们将它插入到哈希表中。如果插入一个元素时发现该元素已经存在于哈希表中，则说明存在重复的元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">containsDuplicate</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;Integer&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x : nums) &#123;<br>            <span class="hljs-keyword">if</span> (!set.add(x)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125;<br><br>作者：LeetCode-Solution<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/contains-duplicate/solution/cun-zai-zhong-fu-yuan-su-by-leetcode-sol-iedd/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Notes - 230</title>
    <link href="/2021/09/22/LeetCode-Notes-230/"/>
    <url>/2021/09/22/LeetCode-Notes-230/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-Notes-230"><a href="#Leetcode-Notes-230" class="headerlink" title="Leetcode Notes - 230"></a>Leetcode Notes - 230</h1><p>题目：<strong>230. 二叉搜索树中第K小的元素</strong></p><p>难度：<strong>中等</strong></p><p>遇见次数：<strong>第二次</strong></p><p>涉及知识点：</p><ul><li>二叉搜索树</li></ul><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><p>Pretty ez isn’t it？😊</p><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210919233115666.png" alt="中序遍历"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> target = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">kthSmallest</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.k = k;<br>        inorder(root);<br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.target;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">inorder</span><span class="hljs-params">(TreeNode root)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span>;<br>        <br>        inorder(root.left);<br>        <br>        <span class="hljs-keyword">this</span>.k--;<br>        <span class="hljs-keyword">if</span>(k == <span class="hljs-number">0</span>) <span class="hljs-keyword">this</span>.target = root.val;<br>        <br>        inorder(root.right);<br>        <br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Notes - 242</title>
    <link href="/2021/09/22/LeetCode-Notes-242/"/>
    <url>/2021/09/22/LeetCode-Notes-242/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-Notes-247"><a href="#Leetcode-Notes-247" class="headerlink" title="Leetcode Notes - 247"></a>Leetcode Notes - 247</h1><p>题目：247. 有效的字母异位词</p><p>难度：<strong>简单</strong></p><p>遇见次数：<strong>第一次</strong></p><p>涉及知识点：</p><ul><li>字符串</li><li>哈希表</li></ul><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="1-数组哈希遍历"><a href="#1-数组哈希遍历" class="headerlink" title="1. 数组哈希遍历"></a>1. 数组哈希遍历</h3><p><img src="../Picbed/image-20210728121333451.png" alt="image-20210728121333451"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isAnagram</span><span class="hljs-params">(String s, String t)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[] dictOfS = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">26</span>];<br>        <span class="hljs-keyword">int</span>[] dictOfT = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">26</span>];<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> sChar : s.toCharArray())&#123;<br>            dictOfS[sChar - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> tChar : t.toCharArray())&#123;<br>            dictOfT[tChar - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i ++)&#123;<br>            <span class="hljs-keyword">if</span>(dictOfS[i] != dictOfT[i])&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p>从另一个角度考虑，<code>t</code> 是 <code>s</code> 的异位词等价于「两个字符串中字符出现的种类和次数均相等」。由于字符串只包含 <code>26</code> 个小写字母，因此我们可以维护一个长度为 <code>26</code> 的频次数组 <code>table</code>，先遍历记录字符串 <code>s</code> 中字符出现的频次，然后遍历字符串 <code>t</code>，减去 <code>table</code> 中对应的频次，如果出现 <code>table[i]&lt;0</code>，则说明 tt 包含一个不在 <code>s</code> 中的额外字符，返回 <code>false</code> 即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isAnagram</span><span class="hljs-params">(String s, String t)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (s.length() != t.length()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        Map&lt;Character, Integer&gt; table = <span class="hljs-keyword">new</span> HashMap&lt;Character, Integer&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;<br>            <span class="hljs-keyword">char</span> ch = s.charAt(i);<br>            table.put(ch, table.getOrDefault(ch, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; t.length(); i++) &#123;<br>            <span class="hljs-keyword">char</span> ch = t.charAt(i);<br>            table.put(ch, table.getOrDefault(ch, <span class="hljs-number">0</span>) - <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (table.get(ch) &lt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br><br>作者：LeetCode-Solution<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/valid-anagram/solution/you-xiao-de-zi-mu-yi-wei-ci-by-leetcode-solution/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Notes - 347</title>
    <link href="/2021/09/22/LeetCode-Notes-347/"/>
    <url>/2021/09/22/LeetCode-Notes-347/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-Notes-347"><a href="#Leetcode-Notes-347" class="headerlink" title="Leetcode Notes - 347"></a>Leetcode Notes - 347</h1><p>题目：<strong>347. 前K个高频元素</strong></p><p>难度：<strong>中等</strong></p><p>遇见次数：<strong>第一次</strong></p><p>涉及知识点：</p><ul><li>堆排序</li></ul><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h3><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210920002751747.png" alt="优先队列"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] topKFrequent(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k) &#123;<br>        Map&lt;Integer, Integer&gt; occurrences = <span class="hljs-keyword">new</span> HashMap&lt;Integer, Integer&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) &#123;<br>            occurrences.put(num, occurrences.getOrDefault(num, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// int[] 的第一个元素代表数组的值，第二个元素代表了该值出现的次数</span><br>        PriorityQueue&lt;<span class="hljs-keyword">int</span>[]&gt; queue = <span class="hljs-keyword">new</span> PriorityQueue&lt;<span class="hljs-keyword">int</span>[]&gt;(<span class="hljs-keyword">new</span> Comparator&lt;<span class="hljs-keyword">int</span>[]&gt;() &#123;<br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] m, <span class="hljs-keyword">int</span>[] n)</span> </span>&#123;<br>                <span class="hljs-keyword">return</span> m[<span class="hljs-number">1</span>] - n[<span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;);<br>        <span class="hljs-keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : occurrences.entrySet()) &#123;<br>            <span class="hljs-keyword">int</span> num = entry.getKey(), count = entry.getValue();<br>            <span class="hljs-keyword">if</span> (queue.size() == k) &#123;<br>                <span class="hljs-keyword">if</span> (queue.peek()[<span class="hljs-number">1</span>] &lt; count) &#123;<br>                    queue.poll();<br>                    queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;num, count&#125;);<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;num, count&#125;);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">int</span>[] ret = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[k];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; ++i) &#123;<br>            ret[i] = queue.poll()[<span class="hljs-number">0</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><h4 id="思路及算法"><a href="#思路及算法" class="headerlink" title="思路及算法"></a>思路及算法</h4><p>在这里，我们可以利用堆的思想：建立一个小顶堆，然后遍历「出现次数数组」：</p><ul><li>如果堆的元素个数小于 k，就可以直接插入堆中。</li><li>如果堆的元素个数等于 k，则检查堆顶与当前出现次数的大小。如果堆顶更大，说明至少有 k 个数字的出现次数比当前值大，故舍弃当前值；否则，就弹出堆顶，并将当前值插入堆中。</li></ul><p>遍历完成后，堆中的元素就代表了「出现次数数组」中前 k 大的值</p><blockquote><p>利用小顶对偏序性质</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Leetcode Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Notes - 350</title>
    <link href="/2021/09/22/LeetCode-Notes-350/"/>
    <url>/2021/09/22/LeetCode-Notes-350/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-Notes-217"><a href="#Leetcode-Notes-217" class="headerlink" title="Leetcode Notes - 217"></a>Leetcode Notes - 217</h1><p>题目：217. 存在重复的元素</p><p>难度：<strong>简单</strong></p><p>遇见次数：<strong>第一次</strong></p><p>涉及知识点：</p><ul><li>排序</li><li>哈希表</li></ul><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p><img src="../Picbed/image-20210725122815211.png" alt="image-20210725122815211"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] intersect(<span class="hljs-keyword">int</span>[] nums1, <span class="hljs-keyword">int</span>[] nums2) &#123;<br>        <span class="hljs-keyword">int</span> len1 = nums1.length;<br>        <span class="hljs-keyword">int</span> len2 = nums2.length;<br><br>        Map&lt;Integer, Integer&gt; myHashmap1 = <span class="hljs-keyword">new</span> HashMap&lt;Integer, Integer&gt;();<br>        Map&lt;Integer, Integer&gt; myHashmap2 = <span class="hljs-keyword">new</span> HashMap&lt;Integer, Integer&gt;();<br><br>        <span class="hljs-keyword">if</span>(len1 == <span class="hljs-number">0</span> || len2 == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>];<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i : nums1)&#123;<br>            <span class="hljs-keyword">int</span> count = myHashmap1.getOrDefault(i, <span class="hljs-number">1</span>);<br><br>            <span class="hljs-keyword">if</span>(myHashmap1.containsKey(i))&#123;<br>                myHashmap1.replace(i, ++count);<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                myHashmap1.put(i, count);<br>            &#125;<br>        &#125;<br><br>        System.out.println(myHashmap1.entrySet());<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j : nums2)&#123;<br>            <span class="hljs-keyword">int</span> count = myHashmap2.getOrDefault(j, <span class="hljs-number">1</span>);<br><br>            <span class="hljs-keyword">if</span>(myHashmap2.containsKey(j))&#123;<br>                myHashmap2.replace(j, ++count);<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                myHashmap2.put(j, count);<br>            &#125;<br>        &#125;<br><br>        System.out.println(myHashmap2.entrySet());<br><br>        Map&lt;Integer, Integer&gt; ans = <span class="hljs-keyword">new</span> HashMap&lt;Integer, Integer&gt;();<br><br>        <span class="hljs-keyword">if</span>(myHashmap1.size() &gt; myHashmap2.size())&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k : myHashmap2.keySet())&#123;<br>                <span class="hljs-keyword">if</span>(myHashmap1.containsKey(k))&#123;<br>                    ans.put(k, Math.min(myHashmap1.get(k), myHashmap2.get(k)));<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k : myHashmap1.keySet())&#123;<br>                <span class="hljs-keyword">if</span>(myHashmap2.containsKey(k))&#123;<br>                    ans.put(k, Math.min(myHashmap1.get(k), myHashmap2.get(k)));<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        System.out.println(ans.entrySet());<br><br>        List&lt;Integer&gt; myArraylist = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> p : ans.keySet())&#123;<br>            <span class="hljs-keyword">int</span> times = ans.get(p);<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> q = <span class="hljs-number">0</span>; q &lt; times; q++)&#123;<br>                myArraylist.add(p);<br>            &#125;<br>        &#125;<br><br>        System.out.println(myArraylist);<br><br>        <span class="hljs-keyword">int</span>[] last = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[myArraylist.size()];<br><br>        <span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> m : myArraylist)&#123;<br>            last[n] = m;<br>            n++;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> last;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="哈希表-1"><a href="#哈希表-1" class="headerlink" title="哈希表"></a>哈希表</h3><p>由于同一个数字在两个数组中都可能出现多次，因此需要用哈希表存储每个数字出现的次数。对于一个数字，其在交集中出现的次数等于该数字在两个数组中出现次数的最小值</p><p>首先遍历第一个数组，并在哈希表中记录第一个数组中的每个数字以及对应出现的次数，然后遍历第二个数组，对于第二个数组中的每个数字，如果在哈希表中存在这个数字，则将该数字添加到答案，并减少哈希表中该数字出现的次数</p><p>为了降低空间复杂度，首先遍历较短的数组并在哈希表中记录每个数字以及对应出现的次数，然后遍历较长的数组得到交集</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] intersect(<span class="hljs-keyword">int</span>[] nums1, <span class="hljs-keyword">int</span>[] nums2) &#123;<br>        <span class="hljs-keyword">if</span> (nums1.length &gt; nums2.length) &#123;<br>            <span class="hljs-keyword">return</span> intersect(nums2, nums1);<br>        &#125;<br>        Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;Integer, Integer&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums1) &#123;<br>            <span class="hljs-keyword">int</span> count = map.getOrDefault(num, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>;<br>            map.put(num, count);<br>        &#125;<br>        <span class="hljs-keyword">int</span>[] intersection = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[nums1.length];<br>        <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums2) &#123;<br>            <span class="hljs-keyword">int</span> count = map.getOrDefault(num, <span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">0</span>) &#123;<br>                intersection[index++] = num;<br>                count--;<br>                <span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">0</span>) &#123;<br>                    map.put(num, count);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    map.remove(num);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> Arrays.copyOfRange(intersection, <span class="hljs-number">0</span>, index);<br>    &#125;<br>&#125;<br><br>作者：LeetCode-Solution<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/intersection-of-two-arrays-ii/solution/liang-ge-shu-zu-de-jiao-ji-ii-by-leetcode-solution/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Notes - 387</title>
    <link href="/2021/09/22/LeetCode-Notes-387/"/>
    <url>/2021/09/22/LeetCode-Notes-387/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-Notes-387"><a href="#Leetcode-Notes-387" class="headerlink" title="Leetcode Notes - 387"></a>Leetcode Notes - 387</h1><p>题目：387. 字符串中的第一个唯一字符</p><p>难度：<strong>简单</strong></p><p>遇见次数：<strong>第一次</strong></p><p>涉及知识点：</p><ul><li>字符串</li><li>哈希表</li></ul><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="1-哈希表两次遍历"><a href="#1-哈希表两次遍历" class="headerlink" title="1. 哈希表两次遍历"></a>1. 哈希表两次遍历</h3><p><img src="../Picbed/image-20210728095117644.png" alt="image-20210728095117644"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">firstUniqChar</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(s.length() == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(s.length() == <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        Map&lt;Character, ArrayList&lt;Integer&gt;&gt; checkMap = <span class="hljs-keyword">new</span> HashMap&lt;Character, ArrayList&lt;Integer&gt;&gt;();<br>        <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> ch : s.toCharArray())&#123;<br>            <span class="hljs-keyword">if</span>(checkMap.containsKey(ch))&#123;<br>                ArrayList&lt;Integer&gt; curList = checkMap.get(ch);<br>                curList.set(<span class="hljs-number">1</span>, curList.get(<span class="hljs-number">1</span>) + <span class="hljs-number">1</span>);<br><br>                checkMap.replace(ch, curList);<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                ArrayList&lt;Integer&gt; newList = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br><br>                newList.add(index);<br>                newList.add(<span class="hljs-number">1</span>);<br><br>                checkMap.put(ch, newList);<br>            &#125;<br><br>            index++;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> chEle : s.toCharArray())&#123;<br>            ArrayList&lt;Integer&gt; checkList = checkMap.get(chEle);<br>            <span class="hljs-keyword">if</span>(checkList.get(<span class="hljs-number">1</span>) == <span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">return</span> checkList.get(<span class="hljs-number">0</span>);<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-双哈希表遍历"><a href="#2-双哈希表遍历" class="headerlink" title="2. 双哈希表遍历"></a>2. 双哈希表遍历</h3><p>优化后</p><p><img src="../Picbed/image-20210728102440030.png" alt="image-20210728102440030"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">firstUniqChar</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(s.length() == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(s.length() == <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        Map&lt;Character, Integer&gt; uniqueMap = <span class="hljs-keyword">new</span> HashMap&lt;Character, Integer&gt;();<br>        Set&lt;Character&gt; checkList = <span class="hljs-keyword">new</span> HashSet&lt;Character&gt;();<br>        <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> ch : s.toCharArray())&#123;<br>            <span class="hljs-keyword">if</span>(uniqueMap.containsKey(ch))&#123;<br>                checkList.add(ch);<br>                uniqueMap.remove(ch);<br>            &#125;<br>            <br>            <span class="hljs-keyword">if</span>(!checkList.contains(ch))&#123;<br>                uniqueMap.put(ch, index);<br>            &#125;<br><br>            index++;<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> ans = s.length();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> chEle : uniqueMap.keySet())&#123;<br>            <span class="hljs-keyword">int</span> curIndex = uniqueMap.get(chEle);<br><br>            <span class="hljs-keyword">if</span>(curIndex &lt; ans)&#123;<br>                ans = curIndex;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans == s.length() ? -<span class="hljs-number">1</span> : ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="数组计数"><a href="#数组计数" class="headerlink" title="数组计数"></a>数组计数</h3><p>比较快的一个小方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">firstUniqChar</span><span class="hljs-params">(String s)</span> </span>&#123;<br>       <span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">26</span>];<br>        <span class="hljs-keyword">int</span> n = s.length();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            arr[s.charAt(i)-<span class="hljs-string">&#x27;a&#x27;</span>]++ ;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (arr[s.charAt(i)-<span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">return</span> i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Notes - 451</title>
    <link href="/2021/09/22/LeetCode-Notes-451/"/>
    <url>/2021/09/22/LeetCode-Notes-451/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-Notes-451"><a href="#Leetcode-Notes-451" class="headerlink" title="Leetcode Notes - 451"></a>Leetcode Notes - 451</h1><p>题目：<strong>451. 根据字符出现频率排序</strong></p><p>难度：<strong>中等</strong></p><p>遇见次数：<strong>第一次</strong></p><p>涉及知识点：</p><ul><li>优先队列</li></ul><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="集合排序"><a href="#集合排序" class="headerlink" title="集合排序"></a>集合排序</h3><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210920003518259.png" alt="集合排序"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">frequencySort</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(s.length() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>        Map&lt;Character, Integer&gt; mp = <span class="hljs-keyword">new</span> HashMap&lt;Character, Integer&gt;();<br>        StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> ch : s.toCharArray())&#123;<br>            <span class="hljs-keyword">int</span> cur = mp.getOrDefault(ch,<span class="hljs-number">0</span>);<br>            mp.put(ch, cur + <span class="hljs-number">1</span>);<br>        &#125;<br>        <br>        Set&lt;Map.Entry&lt;Character,Integer&gt;&gt; entrys = mp.entrySet();<br>        List&lt;Map.Entry&lt;Character,Integer&gt;&gt; li = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(entrys);<br>        Collections.sort(li, <span class="hljs-keyword">new</span> Comparator&lt;Map.Entry&lt;Character,Integer&gt;&gt;()&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Map.Entry&lt;Character, Integer&gt; e1, Map.Entry&lt;Character, Integer&gt; e2)</span></span>&#123;<br>                Integer v1 = e1.getValue();<br>                Integer v2 = e2.getValue();<br>                <span class="hljs-keyword">return</span> v2 - v1;<br>            &#125;<br>        &#125;);<br>        <br>        <span class="hljs-keyword">for</span>(Map.Entry&lt;Character,Integer&gt; ele : li)&#123;<br>            <span class="hljs-keyword">int</span> len = ele.getValue();<br>            <span class="hljs-keyword">char</span> curChar = ele.getKey();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)&#123;<br>                sb.append(curChar);<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> sb.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h3><h4 id="思路及算法"><a href="#思路及算法" class="headerlink" title="思路及算法"></a>思路及算法</h4><p>由于每个字符在字符串中出现的频率存在上限，因此可以使用桶排序的思想，根据出现次数生成排序后的字符串。具体做法如下：</p><ol><li>遍历字符串，统计每个字符出现的频率，同时记录最高频率 maxFreq；</li><li>创建桶，存储从 1 到 maxFreq 的每个出现频率的字符；</li><li>按照出现频率从大到小的顺序遍历桶，对于每个出现频率，获得对应的字符，然后将每个字符按照出现频率拼接到排序后的字符串。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">frequencySort</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        Map&lt;Character, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;Character, Integer&gt;();<br>        <span class="hljs-keyword">int</span> maxFreq = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> length = s.length();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>            <span class="hljs-keyword">char</span> c = s.charAt(i);<br>            <span class="hljs-keyword">int</span> frequency = map.getOrDefault(c, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>;<br>            map.put(c, frequency);<br>            maxFreq = Math.max(maxFreq, frequency);<br>        &#125;<br>        StringBuffer[] buckets = <span class="hljs-keyword">new</span> StringBuffer[maxFreq + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= maxFreq; i++) &#123;<br>            buckets[i] = <span class="hljs-keyword">new</span> StringBuffer();<br>        &#125;<br>        <span class="hljs-keyword">for</span> (Map.Entry&lt;Character, Integer&gt; entry : map.entrySet()) &#123;<br>            <span class="hljs-keyword">char</span> c = entry.getKey();<br>            <span class="hljs-keyword">int</span> frequency = entry.getValue();<br>            buckets[frequency].append(c);<br>        &#125;<br>        StringBuffer sb = <span class="hljs-keyword">new</span> StringBuffer();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = maxFreq; i &gt; <span class="hljs-number">0</span>; i--) &#123;<br>            StringBuffer bucket = buckets[i];<br>            <span class="hljs-keyword">int</span> size = bucket.length();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; size; j++) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; i; k++) &#123;<br>                    sb.append(bucket.charAt(j));<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sb.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Notes - 566</title>
    <link href="/2021/09/22/LeetCode-Notes-566/"/>
    <url>/2021/09/22/LeetCode-Notes-566/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-Notes-566"><a href="#Leetcode-Notes-566" class="headerlink" title="Leetcode Notes - 566"></a>Leetcode Notes - 566</h1><p>题目：566. 重塑矩阵</p><p>难度：<strong>简单</strong></p><p>遇见次数：<strong>第一次</strong></p><p>涉及知识点：</p><ul><li>二维数组</li></ul><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="两次遍历"><a href="#两次遍历" class="headerlink" title="两次遍历"></a>两次遍历</h3><p>优化可以从原地拷贝着手</p><p><img src="../Picbed/image-20210726120009586.png" alt="image-20210726120009586"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[][] matrixReshape(<span class="hljs-keyword">int</span>[][] mat, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> c) &#123;<br>        <span class="hljs-keyword">int</span> row = mat.length;<br>        <span class="hljs-keyword">int</span> col = mat[<span class="hljs-number">0</span>].length;<br><br>        <span class="hljs-keyword">if</span>(r * c != row * col)&#123;<br>            <span class="hljs-keyword">return</span> mat;<br>        &#125;<br><br>        <span class="hljs-keyword">int</span>[] eleArr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[r*c];<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span>[] rowArr : mat)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> element : rowArr)&#123;<br>                eleArr[i] = element;<br>                i++;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">int</span>[][] resShape = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[r][c];<br>        <span class="hljs-keyword">int</span> p1 = <span class="hljs-number">0</span>;<br>        i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span>[] rowRes : resShape)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> colRes : rowRes)&#123;<br>                rowRes[i] = eleArr[p1];<br>                i++;<br>                p1++;<br>            &#125;<br>            i = <span class="hljs-number">0</span>;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> resShape;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="二维数组的一维展示"><a href="#二维数组的一维展示" class="headerlink" title="二维数组的一维展示"></a>二维数组的一维展示</h3><p><img src="../Picbed/image-20210726120040304.png" alt="image-20210726120040304"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[][] matrixReshape(<span class="hljs-keyword">int</span>[][] nums, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> c) &#123;<br>        <span class="hljs-keyword">int</span> m = nums.length;<br>        <span class="hljs-keyword">int</span> n = nums[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-keyword">if</span> (m * n != r * c) &#123;<br>            <span class="hljs-keyword">return</span> nums;<br>        &#125;<br><br>        <span class="hljs-keyword">int</span>[][] ans = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[r][c];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>; x &lt; m * n; ++x) &#123;<br>            ans[x / c][x % c] = nums[x / n][x % n];<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br><br>作者：LeetCode-Solution<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/reshape-the-matrix/solution/zhong-su-ju-zhen-by-leetcode-solution-gt0g/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Notes - 841</title>
    <link href="/2021/09/22/LeetCode-Notes-841/"/>
    <url>/2021/09/22/LeetCode-Notes-841/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-Notes-841"><a href="#Leetcode-Notes-841" class="headerlink" title="Leetcode Notes - 841"></a>Leetcode Notes - 841</h1><p>题目：<strong>841. 钥匙和房间</strong></p><p>难度：<strong>中等</strong></p><p>遇见次数：<strong>第次</strong></p><p>涉及知识点：</p><ul><li>图</li></ul><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="栈-哈希集合"><a href="#栈-哈希集合" class="headerlink" title="栈+哈希集合"></a>栈+哈希集合</h3><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210920000226968.png" alt="栈+哈希集合"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">canVisitAllRooms</span><span class="hljs-params">(List&lt;List&lt;Integer&gt;&gt; rooms)</span> </span>&#123;<br>        Set&lt;Integer&gt; gone = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br>        Deque&lt;Integer&gt; stk = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        gone.add(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i : rooms.get(<span class="hljs-number">0</span>))&#123;<br>            <span class="hljs-keyword">if</span>(i != <span class="hljs-number">0</span>) stk.push(i);<br>        &#125;<br>        <br>        <span class="hljs-keyword">while</span>(!stk.isEmpty())&#123;<br>            <span class="hljs-keyword">int</span> len = stk.size();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; len; j++)&#123;<br>                Integer curKey = stk.pop();<br>                gone.add(curKey);<br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> ele : rooms.get(curKey))&#123;<br>                    <span class="hljs-keyword">if</span>(gone.contains(ele)) <span class="hljs-keyword">continue</span>;<br>                    stk.push(ele);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> gone.size() == rooms.size() ? <span class="hljs-keyword">true</span> : <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h3><h4 id="思路及算法"><a href="#思路及算法" class="headerlink" title="思路及算法"></a>思路及算法</h4><p>可以使用深度优先搜索的方式遍历整张图，统计可以到达的节点个数，并利用数组 <em>vis</em> 标记当前节点是否访问过，以防止重复访问。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">boolean</span>[] vis;<br>    <span class="hljs-keyword">int</span> num;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">canVisitAllRooms</span><span class="hljs-params">(List&lt;List&lt;Integer&gt;&gt; rooms)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = rooms.size();<br>        num = <span class="hljs-number">0</span>;<br>        vis = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[n];<br>        dfs(rooms, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> num == n;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(List&lt;List&lt;Integer&gt;&gt; rooms, <span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        vis[x] = <span class="hljs-keyword">true</span>;<br>        num++;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> it : rooms.get(x)) &#123;<br>            <span class="hljs-keyword">if</span> (!vis[it]) &#123;<br>                dfs(rooms, it);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Notes - 973</title>
    <link href="/2021/09/22/LeetCode-Notes-973/"/>
    <url>/2021/09/22/LeetCode-Notes-973/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-Notes-973"><a href="#Leetcode-Notes-973" class="headerlink" title="Leetcode Notes - 973"></a>Leetcode Notes - 973</h1><p>题目：<strong>973. 最接近原点的K个点</strong></p><p>难度：<strong>中等</strong></p><p>遇见次数：<strong>第一次</strong></p><p>涉及知识点：</p><ul><li>优先队列</li><li>排序</li></ul><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="集合排序"><a href="#集合排序" class="headerlink" title="集合排序"></a>集合排序</h3><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210920003740082.png" alt="集合排序"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[][] kClosest(<span class="hljs-keyword">int</span>[][] points, <span class="hljs-keyword">int</span> k) &#123;<br>        Map&lt;Integer, Double&gt; mp = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; points.length; i++)&#123;<br>            mp.put(i, Math.pow(points[i][<span class="hljs-number">0</span>],<span class="hljs-number">2</span>) + Math.pow(points[i][<span class="hljs-number">1</span>],<span class="hljs-number">2</span>));<br>        &#125;<br>        <br>        Set&lt;Map.Entry&lt;Integer, Double&gt;&gt; entrys = mp.entrySet();<br>        List&lt;Map.Entry&lt;Integer, Double&gt;&gt; li = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(entrys);<br>        Collections.sort(li, <span class="hljs-keyword">new</span> Comparator&lt;Map.Entry&lt;Integer, Double&gt;&gt;()&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Map.Entry&lt;Integer, Double&gt; e1, Map.Entry&lt;Integer, Double&gt; e2)</span></span>&#123;<br>                Double v1 = e1.getValue();<br>                Double v2 = e2.getValue();<br>                <span class="hljs-keyword">if</span>(v1 &gt; v2) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;);<br>        <br>        <span class="hljs-keyword">int</span>[][] ans = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[k][<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(Map.Entry&lt;Integer, Double&gt; ele : li)&#123;<br>            Integer curIndex = ele.getKey();<br>            ans[j] = points[curIndex];<br>            j++;<br>            <span class="hljs-keyword">if</span>(j == k) <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="快速选择"><a href="#快速选择" class="headerlink" title="快速选择"></a>快速选择</h3><h4 id="思路及算法"><a href="#思路及算法" class="headerlink" title="思路及算法"></a>思路及算法</h4><p>我们定义函数 <code>random_select(left, right, k)</code> 表示划分数组 points 的 [left,right] 区间，并且需要找到其中第 k 个距离最小的点。在一次划分操作完成后，设 pivot 的下标为 i，即区间 [left,i − 1] 中的点的距离都小于等于 pivot，而区间 [i + 1,right] 的点的距离都大于 pivot。此时会有三种情况：</p><ul><li>如果 k = i − left + 1，那么说明 pivot 就是第 k 个距离最小的点，我们可以结束整个过程</li><li>如果 k &lt; i − left+1，那么说明第 k 个距离最小的点在 pivot 左侧，因此递归调用 <code>random_select(left, i - 1, k)</code></li><li>如果 k &gt; i − left + 1，那么说明第 k 个距离最小的点在 pivot 右侧，因此递归调用 <code>random_select(i + 1, right, k - (i - left + 1))</code></li></ul><p>在整个过程结束之后，第 k 个距离最小的点恰好就在数组 points 中的第 k 个位置，并且其左侧的所有点的距离都小于它。此时，我们就找到了前 k 个距离最小的点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    Random rand = <span class="hljs-keyword">new</span> Random();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[][] kClosest(<span class="hljs-keyword">int</span>[][] points, <span class="hljs-keyword">int</span> k) &#123;<br>        <span class="hljs-keyword">int</span> n = points.length;<br>        random_select(points, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>, k);<br>        <span class="hljs-keyword">return</span> Arrays.copyOfRange(points, <span class="hljs-number">0</span>, k);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">random_select</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] points, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> pivotId = left + rand.nextInt(right - left + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">int</span> pivot = points[pivotId][<span class="hljs-number">0</span>] * points[pivotId][<span class="hljs-number">0</span>] + points[pivotId][<span class="hljs-number">1</span>] * points[pivotId][<span class="hljs-number">1</span>];<br>        swap(points, right, pivotId);<br>        <span class="hljs-keyword">int</span> i = left - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = left; j &lt; right; ++j) &#123;<br>            <span class="hljs-keyword">int</span> dist = points[j][<span class="hljs-number">0</span>] * points[j][<span class="hljs-number">0</span>] + points[j][<span class="hljs-number">1</span>] * points[j][<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (dist &lt;= pivot) &#123;<br>                ++i;<br>                swap(points, i, j);<br>            &#125;<br>        &#125;<br>        ++i;<br>        swap(points, i, right);<br>        <span class="hljs-comment">// [left, i-1] 都小于等于 pivot, [i+1, right] 都大于 pivot</span><br>        <span class="hljs-keyword">if</span> (k &lt; i - left + <span class="hljs-number">1</span>) &#123;<br>            random_select(points, left, i - <span class="hljs-number">1</span>, k);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (k &gt; i - left + <span class="hljs-number">1</span>) &#123;<br>            random_select(points, i + <span class="hljs-number">1</span>, right, k - (i - left + <span class="hljs-number">1</span>));<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] points, <span class="hljs-keyword">int</span> index1, <span class="hljs-keyword">int</span> index2)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[] temp = points[index1];<br>        points[index1] = points[index2];<br>        points[index2] = temp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Notes - 997</title>
    <link href="/2021/09/22/LeetCode-Notes-997/"/>
    <url>/2021/09/22/LeetCode-Notes-997/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-Notes-997"><a href="#Leetcode-Notes-997" class="headerlink" title="Leetcode Notes - 997"></a>Leetcode Notes - 997</h1><p>题目：<strong>997. 找到小镇的法官</strong></p><p>难度：<strong>简单</strong></p><p>遇见次数：<strong>第一次</strong></p><p>涉及知识点：</p><ul><li>图</li></ul><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="数组哈希"><a href="#数组哈希" class="headerlink" title="数组哈希"></a>数组哈希</h3><p>轻松拿下📕</p><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210919235711248.png" alt="数组哈希"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findJudge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span>[][] trust)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <br>        <span class="hljs-keyword">int</span>[] mp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>        <span class="hljs-keyword">int</span>[] check = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span>[] cur : trust)&#123;<br>            check[cur[<span class="hljs-number">0</span>] - <span class="hljs-number">1</span>]++;<br>            mp[cur[<span class="hljs-number">1</span>] - <span class="hljs-number">1</span>]++;<br>        &#125;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">if</span>(mp[i] == n - <span class="hljs-number">1</span> &amp;&amp; check[i] == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Notes - 1557</title>
    <link href="/2021/09/22/LeetCode-Notes-1557/"/>
    <url>/2021/09/22/LeetCode-Notes-1557/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-Notes-1557"><a href="#Leetcode-Notes-1557" class="headerlink" title="Leetcode Notes - 1557"></a>Leetcode Notes - 1557</h1><p>题目：<strong>1557. 可以到达所有点的最少点数</strong></p><p>难度：<strong>中等</strong></p><p>遇见次数：<strong>第二次</strong></p><p>涉及知识点：</p><ul><li>图</li><li>入度</li></ul><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210920000000571.png" alt="HashSet"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">findSmallestSetOfVertices</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, List&lt;List&lt;Integer&gt;&gt; edges)</span> </span>&#123;<br>        List&lt;Integer&gt; ans = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>        <span class="hljs-keyword">int</span>[] hs = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>        <span class="hljs-keyword">for</span>(List&lt;Integer&gt; edge : edges)&#123;<br>            <span class="hljs-keyword">int</span> cur = edge.get(<span class="hljs-number">1</span>);<br>            hs[cur]++;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">if</span>(hs[i] == <span class="hljs-number">0</span>) ans.add(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="寻找入度为0的点"><a href="#寻找入度为0的点" class="headerlink" title="寻找入度为0的点"></a>寻找入度为0的点</h3><h4 id="思路及算法"><a href="#思路及算法" class="headerlink" title="思路及算法"></a>思路及算法</h4><p>懂得都懂，很简单</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">findSmallestSetOfVertices</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, List&lt;List&lt;Integer&gt;&gt; edges)</span> </span>&#123;<br>        List&lt;Integer&gt; ans = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>        Set&lt;Integer&gt; endSet = <span class="hljs-keyword">new</span> HashSet&lt;Integer&gt;();<br>        <span class="hljs-keyword">for</span> (List&lt;Integer&gt; edge : edges) &#123;<br>            endSet.add(edge.get(<span class="hljs-number">1</span>));<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (!endSet.contains(i)) &#123;<br>                ans.add(i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Big Data Intro - Chapter 7</title>
    <link href="/2021/09/22/Big-Data-Intro-Chapter-7/"/>
    <url>/2021/09/22/Big-Data-Intro-Chapter-7/</url>
    
    <content type="html"><![CDATA[<h1 id="第07章-Flink流批一体分布式实时处理引擎"><a href="#第07章-Flink流批一体分布式实时处理引擎" class="headerlink" title="第07章 Flink流批一体分布式实时处理引擎"></a>第07章 Flink流批一体分布式实时处理引擎</h1><h2 id="Part-1-Flink-远离及架构"><a href="#Part-1-Flink-远离及架构" class="headerlink" title="Part 1 Flink 远离及架构"></a>Part 1 Flink 远离及架构</h2><h3 id="Flink-概述"><a href="#Flink-概述" class="headerlink" title="Flink 概述"></a>Flink 概述</h3><p>Apache Flink 是为<strong>分布式、高性能</strong>的流处理应用打造的开源处理框架</p><ul><li>Flink 可以提供支持<strong>高吞吐盒 Exactly-once</strong> 语义的实时计算</li><li>可以提供<strong>批量数据处理</strong></li></ul><h3 id="Flink-关键机制"><a href="#Flink-关键机制" class="headerlink" title="Flink 关键机制"></a>Flink 关键机制</h3><p>四个机制</p><ul><li>状态 - State</li><li>时间 - Time</li><li>检查点 -Checkpoint</li><li>窗口 - Window</li></ul><h3 id="Flink-核心理念"><a href="#Flink-核心理念" class="headerlink" title="Flink 核心理念"></a>Flink 核心理念</h3><p>Flink 与 其他流计算引擎的最大区别——<strong>状态管理</strong>，可以把工作状态存储在 Flink 内部，而不需要把它存储在外部系统</p><ul><li>降低了计算引擎对外部系统的<strong>依赖</strong>，使得部署、运维更加简单</li><li>对性能带来了极大的提升</li></ul><h3 id="Flink-Runtime-整体架构"><a href="#Flink-Runtime-整体架构" class="headerlink" title="Flink Runtime 整体架构"></a>Flink Runtime 整体架构</h3><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210919130134564.png" alt="Flink Runtime 整体架构"></p><p><strong>Flink</strong> 是一个分层架构的系统，主要分为三层，每一层所包含的组件都提供了特定的抽象，用来服务上层组件。</p><ul><li><strong>部署层面上：</strong>可以单机，集群，云上部署，一般 YARN 集群部署比较多</li><li><strong>核心层面上：</strong>有一个分布式的流式数据处理引擎</li><li><strong>API 层面上：</strong>有流式处理API，批处理API</li></ul><p><strong>流式处理</strong>支持事件处理，表操作；批处理支持机器学 习，图计算，也支持表操作。</p><h3 id="Flink-核心概念-DataStream"><a href="#Flink-核心概念-DataStream" class="headerlink" title="Flink 核心概念 - DataStream"></a>Flink 核心概念 - DataStream</h3><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210919130527436.png" alt="DataStream"></p><p>Flink 用类 DataStream 来表示程序中的流式数据</p><ul><li>用户可以认为他们是含有重复数据的不可修改集合（Collection）</li><li>DataStream 中元素的数量是<strong>无限的</strong></li></ul><p>DataStream 之间常用的算子操作</p><ul><li>含有 <strong>Window</strong> 的是窗口操作，与后面的窗口操作相关连，之间的关系可以通过 reduce，fold，sum，max函数进行管关联</li><li><strong>connect：</strong>进行 Stream 之间的连接，可以通过 flatmap，map 函数进行操作</li><li><strong>JoinedStream：</strong>进行 Stream 之间的 join 操作，类似于数据库中的 join，可以通过 join 函数等进行关联</li><li><strong>CoGroupedStream：</strong>Stream 之间的联合，类似于关系数据库中的 group 操作，可以通过 coGroup 函数进行关联</li><li><strong>KeyedStream：</strong>主要是对数据流依据 key 进行处理，可以通过 keyBy 函数进 行处理</li></ul><h3 id="Flink-核心概念-DataSet"><a href="#Flink-核心概念-DataSet" class="headerlink" title="Flink 核心概念 - DataSet"></a>Flink 核心概念 - DataSet</h3><p>Flink 系统可对数据集进行转换操作（如过滤，映射，链接，分组），数据集可从读取文件或从本地集合创建</p><ul><li>结果通过接收器（Sink）返回，接收器可以将数据写入（分布式）文件或标准输出（例如命令行终端）</li></ul><h3 id="Flink-程序"><a href="#Flink-程序" class="headerlink" title="Flink 程序"></a>Flink 程序</h3><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210919130824813.png" alt="Flink 程序"></p><p>Flink 程序由 Source、Transformation 和 Sink 三部分组成，其中：</p><ul><li>Source 主要负责数据的读取，支持 Kafka，HDFS 和文本等</li><li>Transformation 主要负责对数据的转换操作</li><li>Sink 负责最终数据的输出，支持 HDFS，Kafka 和文本输出等<br>在各部分之间流转的数据成为流（stream）</li></ul><p>一个 Flink 程序的<strong>基本构成</strong>——</p><ol><li><p><strong>获取 execution environment</strong></p><blockquote><p>执行环境 <strong>StreamExecutionEnvironment</strong> 是所有 Flink 程序的基础创建执行环境有三种方式，分别为：</p><ul><li><strong>StreamExecutionEnvironment.getExecutionEnvironment</strong> </li><li><strong>StreamExecutionEnvironment.createLocalEnvironment</strong></li><li><strong>StreamExecutionEnvironment.createRemoteEnvironment</strong> </li></ul></blockquote></li><li><p><strong>加载/创建原始数据</strong></p></li><li><p><strong>指定这些数据的转化方法</strong></p></li><li><p><strong>指定计算结果的存放位置</strong></p></li><li><p><strong>触发程序执行</strong></p></li></ol><h3 id="Flink-数据源"><a href="#Flink-数据源" class="headerlink" title="Flink 数据源"></a>Flink 数据源</h3><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210919131140312.png" alt="Flink 数据源"></p><h3 id="Flink-程序运行图"><a href="#Flink-程序运行图" class="headerlink" title="Flink 程序运行图"></a>Flink 程序运行图</h3><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210919131201694.png" alt="Flink 程序运行图"></p><p>Flink 是一个基于 <strong>Master-Slave</strong> 风格的架构</p><ol><li><p>Flink 集群启动时，会启动一个 JobManager 进程、至少一个 TaskManage r进程</p><ul><li>当 Flink 程序提交后，会创建 一个 Client 来进行预处理，将程序转换为一个表示完整 Job 的 DAG，并提交到  JobManager，最后 JobManager 将 Job 中的各个 Task 分配给 TaskManager</li></ul></li><li><p>Flink 中的计算资源<strong>通过 Task Slot 来定义</strong></p><ul><li>每个 Task Slot 代表了 TaskManager 的一个固定大小的资源池</li><li>例如，一个拥有 3 个 slot 的 TaskManager 会将其管理的内存平均分成三份分给各个slot</li><li>将资源 slot 化意味着来自不同 job 的 task 不会出现内存竞争</li><li>slot 目前仅支持内存的隔离，不支持 CPU 隔离</li></ul></li><li><p>Flink 程序在执行的时候，会<strong>先被转化为一个 Streaming Dataflows</strong></p><ul><li>一个 Streaming Dataflow 是由一组 Stream 和 Transformation Operator 组成的 DAG</li></ul></li></ol><h3 id="Flink-作业运行流程"><a href="#Flink-作业运行流程" class="headerlink" title="Flink 作业运行流程"></a>Flink 作业运行流程</h3><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210919131609248.png" alt="Flink 作业运行流程"></p><p>其中角色主要有——</p><ul><li><strong>Client：</strong>Flink Client 主要给用户提供向 Flink 系统提交用户任务（流式作业）的能力</li><li><strong>TaskManager：</strong>Flink 系统的业务执行节点，执行具体的用户任务。<ul><li>TaskManager 可以有多个，各个 TaskManager 都平等</li></ul></li><li><strong>JobManager：</strong>Flink系统的管理节点，管理所有的TaskManager，并决策用户任务在哪些 TaskManager 执行<ul><li>JobManager 在 HA 模式下可以有多个，但只有一个主 JobManager</li></ul></li><li><strong>TaskSlot（任务槽）：</strong>类似 yarn 中的 container 用于资源隔离，但是该组件只包含内存资源，不包含 cpu 资源。<ul><li>每一个 TaskManager 当中包含 3 个 Task Slot，TaskManager 最多能同时并发执行的任务是可以控制的，那就是 3 个,因为不能超过 slot 的数量</li><li>slot 有独占的内存空间，这样在一个 TaskManager 中可以运行多个不同的作业，作业之间不受影响</li><li>slot 之间可以共享 JVM 资源, 可以共享 Dataset 和数据结构，也可以通过<strong>多路复用（Multiplexing） 共享TCP连接和心跳消息（Heatbeat Message）</strong></li></ul></li><li><strong>Task：</strong>任务执行的单元</li></ul><p>整体运行流程为——</p><ol><li>用户首先提交 Flink 程序到 JobClient，经过其<strong>处理、解析、优化</strong>提交到 JobManager，最后再由 TaskManager 提交 Task</li><li>JobClient 是 Flink 程序和  JobManager 交互的桥梁</li></ol><ul><li>主要负责<strong>接收程序、解析程序的执行计划、优化程序的执行计划</strong></li><li>然后提交执行计划到 JobManager</li><li>主要有三类 Operator：Source，Transformation 和 Sink</li></ul><h3 id="Flink-的数据处理"><a href="#Flink-的数据处理" class="headerlink" title="Flink 的数据处理"></a>Flink 的数据处理</h3><p>Apache Flink 同时支持<strong>批处理和流处理</strong>，也能用来做一些基于事件的应用</p><ul><li>Flink 的基本数据模型是<strong>数据流</strong><ul><li>无边界的无限流对应<strong>流计算</strong></li><li>有边界的有限流对应<strong>批处理</strong></li></ul></li><li>Flink 的另一个优势是<strong>支持有状态的计算</strong><ul><li>有无状态，关键在于是否为 Causal（因果性）</li></ul></li></ul><p>对于<strong>无状态计算和有状态计算的区别</strong>来说——</p><ul><li><strong>无状态计算：</strong>无状态计算会观察每个独立的事件，并且会在最后一个时间出结果， <ul><li>例如一些报警和监控，一直观察每个事件，当触发警报的事件来临就会触发警告</li></ul></li><li><strong>有状态计算：</strong>有状态的计算就会基于多个事件来输出结果<ul><li>例如说计算过去一个小时的平均温度等等</li></ul></li></ul><p>Apache Flink 同样擅长处理<strong>无界和有界数据集</strong>——</p><ul><li>精确的时间控制和状态化使得 Flink 的运行时 (runtime) 能够运行任何处理无界流的应用</li><li>有界流则由一些专为固定大小数据集特殊设计的算法和数据结构进行内部处理，产生了出色的性能</li></ul><h3 id="有界流和无界流"><a href="#有界流和无界流" class="headerlink" title="有界流和无界流"></a>有界流和无界流</h3><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210919132524100.png" alt="有界流和无界流"></p><p>有限流处理是无限流处理的一种特殊情况，它只不过在某个时间点停止而已。</p><p>此外，如果计算结果不在执行过程中连续生成，而仅在末尾处生成一次，那就是批处理（分批处理数据）。</p><h4 id="无界流"><a href="#无界流" class="headerlink" title="无界流"></a>无界流</h4><p>有定义流的开始，但没有定义流的结束</p><h4 id="有界流"><a href="#有界流" class="headerlink" title="有界流"></a>有界流</h4><p>有定义流的开始，也有定义流的结束</p><h3 id="Flink-批处理模型"><a href="#Flink-批处理模型" class="headerlink" title="Flink 批处理模型"></a>Flink 批处理模型</h3><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210919132645901.png" alt="Flink 批处理模型"></p><p>Flink 的不寻常之处在于，它既可以<strong>将数据当作无限流</strong>来处理，也可以将它<strong>当作有限流</strong>来处理</p><ul><li>Flink 的 DataSet API 就是专为批处理而生的</li></ul><p>Flink 通过一个底层引擎同时支持<strong>流处理和批处理</strong></p><ul><li>在流处理引擎之上，Flink 有以下机制<ul><li><strong>检查点机制和状态机制：</strong>用于实现容错、有状态的处理</li><li><strong>水印机制：</strong>用于实现事件时钟</li><li><strong>窗口和触发器：</strong>用于限制计算范围，并定义呈现结果的时间</li></ul></li><li>在同一个流处理引擎之上，Flink 还存在另一套机制，用于实现高效的批处理<ul><li><strong>用于调度和恢复的回溯法：</strong>由 Microsoft Dryad 引入，现在几乎用于所有批处理器</li><li><strong>用于散列和排序的特殊内存数据结构：</strong>可以在需要时，将一部分数据从内存溢出到硬盘上</li><li><strong>优化器：</strong>尽可能地缩短生成结果的时间</li></ul></li></ul><h2 id="Part2-Flink-的-Time-和-Window"><a href="#Part2-Flink-的-Time-和-Window" class="headerlink" title="Part2 Flink 的 Time 和 Window"></a>Part2 Flink 的 Time 和 Window</h2><h3 id="流处理中的-Time-分类"><a href="#流处理中的-Time-分类" class="headerlink" title="流处理中的 Time 分类"></a>流处理中的 Time 分类</h3><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210919154550377.png" alt="流处理中的 Time 分类"></p><p>在实际场景中，每个事件的时间可以分为三种：</p><ul><li><strong>Event time：</strong>即事件发生时的时间</li><li><strong>Ingestion time：</strong>即事件到达流处理系统的时间</li><li><strong>Processing time：</strong>即事件被系统处理的时间</li></ul><p>在 Flink 的流式处理中，绝大部分的业务都会使用 Event Time，一般只在 event  Time 无法使用时，才会被迫使用 Processing Time 或者 Ingestion Time</p><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210919224202155.png" alt="三种时间的区别"></p><h3 id="Window-概述"><a href="#Window-概述" class="headerlink" title="Window 概述"></a>Window 概述</h3><p><strong>Window</strong> 是<strong>无限数据流处理的核心</strong>，它将一个无限的 Stream 拆分成有限大小的 “buckets” 桶，我们可以在这些桶上做计算操作</p><h3 id="Window-类型"><a href="#Window-类型" class="headerlink" title="Window 类型"></a>Window 类型</h3><p>Window 根据应用类型可以分成两类：</p><ul><li>Count Window：数据驱动，按照指定的数据条数生成一个 Window，与时间无关</li><li>Time Window：时间驱动，按照时间生成 Window</li></ul><p>Apache Flink 是一个<strong>天然支持无限流数据处理</strong>的分布式计算框架，Window 可以将无限流转变为有限流</p><h3 id="TimeWindow-分类"><a href="#TimeWindow-分类" class="headerlink" title="TimeWindow 分类"></a>TimeWindow 分类</h3><h4 id="Tumbling-Window-滚动窗口"><a href="#Tumbling-Window-滚动窗口" class="headerlink" title="Tumbling Window 滚动窗口"></a>Tumbling Window 滚动窗口</h4><p>将数据依据固定的窗口长度对数据进行切片</p><ul><li>时间对齐，窗口长度固定，没有重叠</li><li>适用于 BI 统计等（做每个时间段的聚合计算）</li></ul><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210919224332540.png" alt="滚动窗口"></p><h4 id="Sliding-滑动窗口"><a href="#Sliding-滑动窗口" class="headerlink" title="Sliding 滑动窗口"></a>Sliding 滑动窗口</h4><p>滑动窗口是固定窗口的更广义的一种形式，滑动窗口由固定的窗口长度和滑动间隔组成</p><ul><li>时间对齐，窗口长度固定，有重叠</li><li>对最近一个时间段内的统计</li></ul><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210919224352430.png" alt="滑动窗口"></p><h4 id="Session-会话窗口"><a href="#Session-会话窗口" class="headerlink" title="Session 会话窗口"></a>Session 会话窗口</h4><p>会话窗口由一系列事件组合一个指定时间长度的 timeout 间隙组成，类似 web 应用的 session，也就是一段时间没有接收到新数据就会生成新的窗口</p><ul><li>时间无对齐</li></ul><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210919224453825.png" alt="会话窗口"></p><p>session 窗口分配器通过 session 活动来对元素进行分组，session 窗口跟滚动窗口和滑动窗口相比，不会有重叠和固定的开始时间和结束时间的情况</p><ul><li><strong>当它在一个固定的时间周期内不再收到元素，即非活动间隔产生，那么这个窗口就会关闭</strong></li></ul><p>一个 session 窗口通过一个 session 间隔来配置，这个 session 间隔定义了非活跃周期的长度</p><ul><li>当这个非活跃周期产生，那么当前的 session 将被关闭并且后续的元素将被分配到新的 session 窗口中去。</li></ul><h2 id="Part3-Flink-的-Watermark-机制"><a href="#Part3-Flink-的-Watermark-机制" class="headerlink" title="Part3 Flink 的 Watermark 机制"></a>Part3 Flink 的 Watermark 机制</h2><h3 id="乱序问题"><a href="#乱序问题" class="headerlink" title="乱序问题"></a>乱序问题</h3><p>所谓乱序，就是指 Flink 接收到的时间的先后顺序不是严格按照事件的 Event Time 顺序排列的</p><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210919224717626.png" alt="乱序问题"></p><h3 id="为什么需要-Watermark"><a href="#为什么需要-Watermark" class="headerlink" title="为什么需要 Watermark"></a>为什么需要 Watermark</h3><p>一旦出现乱序，如果只根据 Event Time 决定 window 的运行，并不能明确数据是否全部到位，但又不能无限期的等下去，此时必须要有个机制来保证一个特定的时间后，触发 Window 去进行计算，这个机制就是 Watermark</p><ul><li>Watermark 告诉了<strong>算子延迟到达的信息不应该再被接收</strong></li></ul><p>Watermark 是一种衡量 Event Time 进展的机制，它是数据本身的一个隐藏属性， 数据本身携带着对应的 Watermark</p><ul><li>Watermark 是用于处理乱序事件的，通常结合 Window 来实现</li></ul><h3 id="Watermark-的原理"><a href="#Watermark-的原理" class="headerlink" title="Watermark 的原理"></a>Watermark 的原理</h3><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210919225014425.png" alt="Watermark 的原理"></p><ol><li><p>Watermark 会携带一个单调递增的时间戳，Watermark(t) 表示所有时间戳不大于 t 的数据都已经到达，未来小于等于 t 的数据不会再来</p><blockquote><p>输入的数据中，根据自身的 Event Time，将数据划分到不同的 window 中，如果  window 中有数据，则当 watermark 时间 &gt;= window maxTimestamp 时，就符 合了 window 触发的条件了</p><p>最终决定 window 触发，还是由数据本身的 Event  Time 所属的 window 中的 window maxTimestamp 决定。</p></blockquote></li><li><p>有序流的 Watermark 如下图所示：（Watermark 设置为 0）</p></li></ol><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210919225208593.png" alt="有序流的 Watermark"></p><ol start="3"><li>乱序流的 Watermark 如下图所示：（Watermark 设置为 2）</li></ol><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210919225241230.png" alt="乱序流的 Watermark"></p><blockquote><p>上图中，我们设置的允许最大延迟到达时间为 2s，所以时间戳为 7s 的事件对应的  Watermark 是 5s，时间戳为 12s 的事件的 Watermark 是 10s，如果我们的窗口1是 1s - 5s，窗口2是 6s - 10s，那么时间戳为 7s 的事件到达时的 Watermarker 恰好触发窗口1，时间戳为 12s 的事件到达时的 Watermark 恰好触发窗口2。</p></blockquote><h3 id="延迟的数据"><a href="#延迟的数据" class="headerlink" title="延迟的数据"></a>延迟的数据</h3><p>实际工作中会近似 Watermark(t) 之后，还有较小的概率接收到时间戳 t 之前的数据，在 Flink 中将这些数据定义为 “late elements”。<br>我们可以在 Window 中指定允许延迟的最大时间（默认为 0），可以使用如下代码进行设置：</p><h3 id="延迟数据处理机制"><a href="#延迟数据处理机制" class="headerlink" title="延迟数据处理机制"></a>延迟数据处理机制</h3><p>延迟事件是<strong>乱序事件的特例</strong>，和一般乱序事件不同的是他们的乱序程度超出了 <strong>Watermark</strong> 的预计，导致窗口在他们到达之前已经关闭。</p><p>延迟事件出现时窗口已经关闭并产出了计算结果，对于此种情况处理的方法有三种：</p><ul><li>重新激活已经关闭的窗口并重新计算以修正结果</li><li>将延迟事件<strong>收集起来另外处理</strong></li><li>将延迟事件视为<strong>错误信息并丢弃</strong></li></ul><p>Flink <strong>默认的处理方式是第三种直接丢弃</strong>，其他两种方式分别使用 <strong>Side Output 和 Allowed Lateness</strong>——</p><h4 id="Side-Output-机制"><a href="#Side-Output-机制" class="headerlink" title="Side Output 机制"></a>Side Output 机制</h4><p><strong>Side output</strong> 机制可以将延迟事件单独放入一个数据流分支，这会作为 Window 计算结果的副产品，以便用户获取并对其进行特殊处理</p><p>设置 <strong>Allowed Lateness</strong> 之后，迟来的数据同样可以触发窗口，进行输出</p><ul><li>利用 Flink 的 <strong>Side output</strong> 机制，可以获取到这些延迟数据</li><li>需要注意的是，设置了 <strong>Allowed Lateness</strong> 之后，延迟的数据也可能触发窗口，对于 <strong>Session Window</strong> 来说，可能会对窗口进行合并，产生预期外的行为</li><li><strong>Window，窗口类型，Allowed Lateness 允许延迟的时间</strong></li></ul><h4 id="Allowed-Lateness-机制"><a href="#Allowed-Lateness-机制" class="headerlink" title="Allowed Lateness 机制"></a>Allowed Lateness 机制</h4><p><strong>Allowed Lateness</strong> 机制允许用户设置一个**允许的最大延迟时长</p><ul><li>Flink 会在窗口关闭后一直保存窗口的状态直至超过允许延迟时长，这期间的延迟事件不会被丢弃，而是默认会触发窗口重新计算</li><li>因为保存窗口状态需要额外内存，并且如果窗口计算使用了 Process Window Function API 还可能使得每个延迟事件触发一次窗口的全量计算，代价比较大，所以允许延迟时长不宜设得太长，延迟事件也不宜过多</li></ul><h2 id="Part-4-Flink-的容错机制"><a href="#Part-4-Flink-的容错机制" class="headerlink" title="Part 4 Flink 的容错机制"></a>Part 4 Flink 的容错机制</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>为了保证程序的容错恢复以及程序启动时其状态恢复，Flink 任务都会开启 Checkpoint 或者触发 Savepoint 进行状态保存。</p><ul><li><strong>Checkpoint 机制：</strong>这种机制保证了实时程序运行时，即使突然遇到异常也能够进行自我恢复<ul><li>Checkpoint 对于用户层面，是透明的，用户会感觉不到 Checkpoint 过程的存在</li></ul></li><li><strong>Savepoint 机制：</strong>是在某个时间点程序状态全局镜像，以后程序在进行升级，或者修改并发布等情况，还能从保存的状态为进行启动恢复<ul><li>Savepoint 可以看作是 Checkpoint 在特定时期的一个状态快照</li></ul></li></ul><h3 id="Checkpoint"><a href="#Checkpoint" class="headerlink" title="Checkpoint"></a>Checkpoint</h3><p><strong>Flink</strong> 中基于<strong>异步轻量级的分布式快照技术</strong>提供了 Checkpoints 容错机制，分布式快照可以将同一时间点 Task/Operator 的状态数据全局统一快照处理。</p><p><strong>Flink</strong> 会在输入的数据集上间隔性的生成 <strong>Checkpoint barrier</strong>，通过<strong>栅栏（barrier）</strong>将间隔时间段内的数据划分到相应的 checkpoint 中。</p><ul><li>当应用出现异常时，Operator 就能够从上一次快照中恢复所有算子之前的状态，从而保证数据的一致性</li><li>对于状态占用空间比较小的应用，快照产生过程非常轻量，高频率创建且对 Flink 任务性能影响相对较小。</li><li>Checkpoint 过程中状态数据一般被保存在一个可配置的环境中，通常是在 JobManager 节点或 HDFS 上。</li></ul><h3 id="Checkpoint-的配置"><a href="#Checkpoint-的配置" class="headerlink" title="Checkpoint 的配置"></a>Checkpoint 的配置</h3><ol><li><p>首先，默认情况下 <strong>Flink</strong> 不开启检查点，用户需要在程序中通过调用 <code>enableCheckpointing(n)</code> 方法配置和开启检查点，其中 n 为检查点执行的时间间隔，单位为毫秒</p><blockquote><p><code>env.enableCheckpointing(1000)</code> // 开启检查点并且指定检查点时间间隔为 1000ms，根据实际情况自行选择。如果状态比较大，则建议适当增加该值</p></blockquote></li><li><p>对于 <code>exactly-once</code> 和 <code>at-least-once</code> 语义的选择——</p><ul><li><strong>exactly-once：</strong>保证端到端数据一致性，数据要求高，不允许出现数据丢失和数据重复，Flink 的性能也相对较弱</li><li><strong>at-least-once：</strong>时延和吞吐量要求非常高但对数据的一致性要求不高的场景</li></ul></li><li><p>Flink 默认使用 exactly-once 模式，可以通过 <code>setCheckpoingtingMode()</code> 方法来设定语义模式</p><blockquote><p>env.getCheckpointConfig().setCheckpointingMode(CheckpointingMode.EXACTLY_ONCE)</p></blockquote></li><li><p>Checkpoint 超时时间</p><ul><li>指定每次 Checkpoint 执行过程中的上限时间范围，一旦 Checkpoint 执行时间超过该阈值，Flink 将会中断 Checkpoint 过程，并按照超时处理</li><li>该指标可以通过 <code>setCheckpointTimeout</code> 方法设定，默认 10 分钟</li></ul><blockquote><p>env.getCheckpointConfig().setCheckpointingTimeout(60000)</p></blockquote></li><li><p>检查点之间最小时间间隔</p><ul><li>设定两个检查点之间的<strong>最小时间间隔</strong>，防止出现状态数据过大而导致 Checkpoint 执行时间过长，从而导致检查点积压过多，最终 Flink 应用密集地触发 Checkpoint 操作，会占用大量计算资源而影响到整个应用的性能</li></ul><blockquote><p>env.getCheckpointConfig().setMinPauseBetweenCheckpoints(500)</p></blockquote></li><li><p>最大并行执行的检查点数量</p><ul><li>设定能够同时执行的 Checkpoint 数量。在默认情况下只有一个检查点可以运行，根据用户指定的数量可以同时触发多个 Checkpoint，从而提升 Checkpoint 整体的效率</li></ul><blockquote><p>env.getCheckpointConfig().setMaxConcurrentCheckpoints(500)</p></blockquote></li><li><p>外部检查点</p><ul><li>设定周期性的外部检查点，然后将状态数据持久化到外部系统中</li><li>使用这种方式不会在任务停止的过程中清理掉检查点数据，而是一直保存在外部系统介质中，也可以通过从外部检查点中对任务进行恢复</li></ul><blockquote><p>env.getCheckpointConfig().enableExternalizedCheckpoints(ExternalizedCheckpointCleanup.RETAIN_ON_CANCELLATION)</p></blockquote></li></ol><h3 id="作业恢复数据的方法"><a href="#作业恢复数据的方法" class="headerlink" title="作业恢复数据的方法"></a>作业恢复数据的方法</h3><p>Flink 在 Cancel 时允许在外部介质保留 Checkpoint 。</p><p>同时，Flink 还具有 <strong>SavePoint 机制</strong>。</p><p><strong>Savepoints</strong> 是检查点的一种特殊实现，底层其实是使用 Checkpoints 的机制——</p><ul><li>Savepoints 是用户以手工命令的方式触发，并将结果持久化到指定的存储路径中</li><li>目的是帮助用户在升级和维护集群过程中保存系统中的状态数据</li><li>避免因为停机运维或者升级应用等正常终止应用的操作而导致系统无法恢复到原有的计算状态的情况，从而无法实现端到端的 Exactly-Once 语义保证</li></ul><h3 id="Savepoint-和-Checkpoint-的联系和区别"><a href="#Savepoint-和-Checkpoint-的联系和区别" class="headerlink" title="Savepoint 和 Checkpoint 的联系和区别"></a>Savepoint 和 Checkpoint 的联系和区别</h3><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210921194503088.png" alt="Savepoint 和 Checkpoint"></p><p>Savepoint 与 Checkpoint 类似，同样是把状态存储到外部介质。当作业失败时，可以从外部恢复。Savepoint 与 Checkpoint 有什么区别呢？</p><ul><li>从触发管理方式来讲，Checkpoint 由 Flink 自动触发并管理，而 Savepoint 由用户手动触发并人工管理</li><li>从用途来讲，Checkpoint 在 Task 发生异常时快速恢复，例如网络抖动或超时异常，而 Savepoint 有计划地进行备份，使作业能停止后再恢复，例如修改代码、调整并发</li><li>最后从特点来讲，Checkpoint 比较轻量级，作业出现问题会自动从故障中恢复，在作业停止后默认清除；而 Savepoint 比较持久，以标准格式存储，允许代码或配置发生改变，恢复需要启动作业手动指定一个路径恢复</li></ul><h3 id="状态的存储方式-MemoryStateBackend"><a href="#状态的存储方式-MemoryStateBackend" class="headerlink" title="状态的存储方式 - MemoryStateBackend"></a>状态的存储方式 - MemoryStateBackend</h3><h4 id="构造方式"><a href="#构造方式" class="headerlink" title="构造方式"></a>构造方式</h4><blockquote><p>MemoryStateBackend (int maxStateSize, boolean asynchronousSnapshots)</p></blockquote><h4 id="存储方式"><a href="#存储方式" class="headerlink" title="存储方式"></a>存储方式</h4><ul><li>State：TaskManager 内存</li><li>Checkpoint：JobManager 内存</li></ul><h4 id="容量限制"><a href="#容量限制" class="headerlink" title="容量限制"></a>容量限制</h4><ul><li>单个 State maxStateSize 默认 5 M</li><li>maxStateSize &lt;= akka.framesize，默认 10 M</li><li>总大小不超过 JobManager 的内存</li></ul><h4 id="推荐使用的场景"><a href="#推荐使用的场景" class="headerlink" title="推荐使用的场景"></a>推荐使用的场景</h4><ul><li>本地测试</li><li>几乎无状态的作业，比如 ETL</li></ul><h3 id="状态的存储方式-FsStateBackend"><a href="#状态的存储方式-FsStateBackend" class="headerlink" title="状态的存储方式 - FsStateBackend"></a>状态的存储方式 - FsStateBackend</h3><h4 id="构造方式-1"><a href="#构造方式-1" class="headerlink" title="构造方式"></a>构造方式</h4><blockquote><p>FsStateBackend (URI checkpointDataUri, boolean asynchronousSnapshots)</p></blockquote><h4 id="存储方式-1"><a href="#存储方式-1" class="headerlink" title="存储方式"></a>存储方式</h4><ul><li>State：TaskManager 内存</li><li>Checkpoint：外部文件存储系统（本地或 HDFS）</li></ul><h4 id="容量限制-1"><a href="#容量限制-1" class="headerlink" title="容量限制"></a>容量限制</h4><ul><li>单 TaskManager 上 State 总量不超过它的内存</li><li>总大小不超过配置的文件系统容量</li></ul><h4 id="推荐使用的场景-1"><a href="#推荐使用的场景-1" class="headerlink" title="推荐使用的场景"></a>推荐使用的场景</h4><ul><li>常规使用状态的作业</li><li>需要开启 HA 的作业</li><li>可以在生产场景使用</li></ul><h3 id="状态的存储方式-RocksDBStateBackend"><a href="#状态的存储方式-RocksDBStateBackend" class="headerlink" title="状态的存储方式 - RocksDBStateBackend"></a>状态的存储方式 - RocksDBStateBackend</h3><h4 id="构造方式-2"><a href="#构造方式-2" class="headerlink" title="构造方式"></a>构造方式</h4><blockquote><p>RocksDBStateBackend (URI checkpointDataUri, boolean enableIncrementalCheckpointing)</p></blockquote><h4 id="存储方式-2"><a href="#存储方式-2" class="headerlink" title="存储方式"></a>存储方式</h4><ul><li>State：TaskManager 上的 KV 数据库（实际为内存 + 磁盘）</li><li>Checkpoint：外部文件存储系统（本地或 HDFS）</li></ul><h4 id="容量限制-2"><a href="#容量限制-2" class="headerlink" title="容量限制"></a>容量限制</h4><ul><li>单 TaskManager 上 State 总量不超过它的内存 + 磁盘</li><li>单 Key 最大 2G</li><li>总大小不超过配置的文件系统容量</li></ul><h4 id="推荐使用的场景-2"><a href="#推荐使用的场景-2" class="headerlink" title="推荐使用的场景"></a>推荐使用的场景</h4><ul><li>超大状态的作业，例如 TB 级别窗口聚合</li><li>需要开启 HA 的作业</li><li>对状态读写性能要求不高的作业</li><li>可以在生产场景使用</li></ul>]]></content>
    
    
    <categories>
      
      <category>Big Data Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Notes - 450</title>
    <link href="/2021/09/13/LeetCode-Notes-450/"/>
    <url>/2021/09/13/LeetCode-Notes-450/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-Notes-450"><a href="#Leetcode-Notes-450" class="headerlink" title="Leetcode Notes - 450"></a>Leetcode Notes - 450</h1><p>题目：<strong>450. 删除二叉搜索树的节点</strong></p><p>难度：<strong>中等</strong></p><p>遇见次数：<strong>第二次</strong></p><p>涉及知识点：</p><ul><li>二叉搜索树</li></ul><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="递归-中序遍历"><a href="#递归-中序遍历" class="headerlink" title="递归 + 中序遍历"></a>递归 + 中序遍历</h3><h4 id="思路及算法"><a href="#思路及算法" class="headerlink" title="思路及算法"></a>思路及算法</h4><ul><li>如果 <code>key &gt; root.val</code>，说明要删除的节点在右子树，<code>root.right = deleteNode(root.right, key)</code></li><li>如果 <code>key &lt; root.val</code>，说明要删除的节点在左子树，<code>root.left = deleteNode(root.left, key)</code></li><li>如果 <code>key == root.val</code>，则该节点就是我们要删除的节点，则：<ul><li>如果该节点是叶子节点，则直接删除它：<code>root = null</code></li><li>如果该节点不是叶子节点且有右节点，则用它的后继节点的值替代 <code>root.val = successor.val</code>，然后删除后继节点</li><li>如果该节点不是叶子节点且只有左节点，则用它的前驱节点的值替代 <code>root.val = predecessor.val</code>，然后删除前驱节点</li></ul></li><li>返回 <code>root</code></li></ul><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210913143546309.png" alt="image-20210913143546309"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">  One step right and then always left</span><br><span class="hljs-comment">  */</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">successor</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>    root = root.right;<br>    <span class="hljs-keyword">while</span> (root.left != <span class="hljs-keyword">null</span>) root = root.left;<br>    <span class="hljs-keyword">return</span> root.val;<br>  &#125;<br><br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">  One step left and then always right</span><br><span class="hljs-comment">  */</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">predecessor</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>    root = root.left;<br>    <span class="hljs-keyword">while</span> (root.right != <span class="hljs-keyword">null</span>) root = root.right;<br>    <span class="hljs-keyword">return</span> root.val;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">deleteNode</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br><br>    <span class="hljs-comment">// delete from the right subtree</span><br>    <span class="hljs-keyword">if</span> (key &gt; root.val) root.right = deleteNode(root.right, key);<br>    <span class="hljs-comment">// delete from the left subtree</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key &lt; root.val) root.left = deleteNode(root.left, key);<br>    <span class="hljs-comment">// delete the current node</span><br>    <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// the node is a leaf</span><br>      <span class="hljs-keyword">if</span> (root.left == <span class="hljs-keyword">null</span> &amp;&amp; root.right == <span class="hljs-keyword">null</span>) root = <span class="hljs-keyword">null</span>;<br>      <span class="hljs-comment">// the node is not a leaf and has a right child</span><br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root.right != <span class="hljs-keyword">null</span>) &#123;<br>        root.val = successor(root);<br>        root.right = deleteNode(root.right, root.val);<br>      &#125;<br>      <span class="hljs-comment">// the node is not a leaf, has no right child, and has a left child    </span><br>      <span class="hljs-keyword">else</span> &#123;<br>        root.val = predecessor(root);<br>        root.left = deleteNode(root.left, root.val);<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> root;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Notes - 199</title>
    <link href="/2021/09/13/LeetCode-Notes-199/"/>
    <url>/2021/09/13/LeetCode-Notes-199/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-Notes-199"><a href="#Leetcode-Notes-199" class="headerlink" title="Leetcode Notes - 199"></a>Leetcode Notes - 199</h1><p>题目：<strong>199. 二叉树的右视图</strong></p><p>难度：<strong>中等</strong></p><p>遇见次数：<strong>第二次</strong></p><p>涉及知识点：</p><ul><li>层序遍历</li><li>广度优先搜索</li></ul><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h3><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210913143229197.png" alt="层序遍历"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">rightSideView</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br><br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        LinkedList&lt;TreeNode&gt; que = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        que.offer(root);<br>        <span class="hljs-keyword">boolean</span> addOrNot = <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">while</span>(!que.isEmpty())&#123;<br>            <span class="hljs-keyword">int</span> len = que.size();<br>            addOrNot = <span class="hljs-keyword">true</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)&#123;<br>                TreeNode cur = que.removeLast();<br>                <br>                <span class="hljs-keyword">if</span>(addOrNot)&#123;<br>                    res.add(cur.val);<br>                    addOrNot = <span class="hljs-keyword">false</span>;<br>                &#125;<br><br>                <span class="hljs-keyword">if</span>(cur.right != <span class="hljs-keyword">null</span>) que.addFirst(cur.right);<br>                <span class="hljs-keyword">if</span>(cur.left != <span class="hljs-keyword">null</span>) que.addFirst(cur.left);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><h4 id="思路及算法"><a href="#思路及算法" class="headerlink" title="思路及算法"></a>思路及算法</h4><p>执行广度优先搜索，左结点排在右结点之前，这样，我们对每一层都从左到右访问。</p><p>因此，只保留每个深度最后访问的结点，我们就可以在遍历完整棵树后得到每个深度最右的结点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">rightSideView</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        Map&lt;Integer, Integer&gt; rightmostValueAtDepth = <span class="hljs-keyword">new</span> HashMap&lt;Integer, Integer&gt;();<br>        <span class="hljs-keyword">int</span> max_depth = -<span class="hljs-number">1</span>;<br><br>        Queue&lt;TreeNode&gt; nodeQueue = <span class="hljs-keyword">new</span> LinkedList&lt;TreeNode&gt;();<br>        Queue&lt;Integer&gt; depthQueue = <span class="hljs-keyword">new</span> LinkedList&lt;Integer&gt;();<br>        nodeQueue.add(root);<br>        depthQueue.add(<span class="hljs-number">0</span>);<br><br>        <span class="hljs-keyword">while</span> (!nodeQueue.isEmpty()) &#123;<br>            TreeNode node = nodeQueue.remove();<br>            <span class="hljs-keyword">int</span> depth = depthQueue.remove();<br><br>            <span class="hljs-keyword">if</span> (node != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// 维护二叉树的最大深度</span><br>                max_depth = Math.max(max_depth, depth);<br><br>                <span class="hljs-comment">// 由于每一层最后一个访问到的节点才是我们要的答案，因此不断更新对应深度的信息即可</span><br>                rightmostValueAtDepth.put(depth, node.val);<br><br>                nodeQueue.add(node.left);<br>                nodeQueue.add(node.right);<br>                depthQueue.add(depth + <span class="hljs-number">1</span>);<br>                depthQueue.add(depth + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br><br>        List&lt;Integer&gt; rightView = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> depth = <span class="hljs-number">0</span>; depth &lt;= max_depth; depth++) &#123;<br>            rightView.add(rightmostValueAtDepth.get(depth));<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> rightView;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Notes - 113</title>
    <link href="/2021/09/13/LeetCode-Notes-113/"/>
    <url>/2021/09/13/LeetCode-Notes-113/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-Notes-113"><a href="#Leetcode-Notes-113" class="headerlink" title="Leetcode Notes - 113"></a>Leetcode Notes - 113</h1><p>题目：<strong>113. 路经总和 II</strong></p><p>难度：<strong>中等</strong></p><p>遇见次数：<strong>第二次</strong></p><p>涉及知识点：</p><ul><li>栈</li><li>二叉树</li></ul><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h3><h4 id="思路及算法"><a href="#思路及算法" class="headerlink" title="思路及算法"></a>思路及算法</h4><p>采用深度优先搜索的方式，枚举每一条从根节点到叶子节点的路径。当我们遍历到叶子节点，且此时路径和恰为目标和时，我们就找到了一条满足条件的路径。</p><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210913142729416.png" alt="栈"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    List&lt;List&lt;Integer&gt;&gt; ret = <span class="hljs-keyword">new</span> LinkedList&lt;List&lt;Integer&gt;&gt;();<br>    Deque&lt;Integer&gt; path = <span class="hljs-keyword">new</span> LinkedList&lt;Integer&gt;();<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, <span class="hljs-keyword">int</span> targetSum) &#123;<br>        dfs(root, targetSum);<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> targetSum)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        path.offerLast(root.val);<br>        targetSum -= root.val;<br>        <span class="hljs-keyword">if</span> (root.left == <span class="hljs-keyword">null</span> &amp;&amp; root.right == <span class="hljs-keyword">null</span> &amp;&amp; targetSum == <span class="hljs-number">0</span>) &#123;<br>            ret.add(<span class="hljs-keyword">new</span> LinkedList&lt;Integer&gt;(path));<br>        &#125;<br>        dfs(root.left, targetSum);<br>        dfs(root.right, targetSum);<br>        path.pollLast();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Notes - 103</title>
    <link href="/2021/09/12/LeetCode-Notes-103/"/>
    <url>/2021/09/12/LeetCode-Notes-103/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-Notes-103"><a href="#Leetcode-Notes-103" class="headerlink" title="Leetcode Notes - 103"></a>Leetcode Notes - 103</h1><p>题目：<strong>103. 二叉树的锯齿形层序遍历</strong></p><p>难度：<strong>中等</strong></p><p>遇见次数：<strong>第二次</strong></p><p>涉及知识点：</p><ul><li>二叉树</li><li>层序遍历</li></ul><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="队列-列表反转"><a href="#队列-列表反转" class="headerlink" title="队列+列表反转"></a>队列+列表反转</h3><p>不擦😊</p><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210912152623358.png" alt="队列+列表反转"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    LinkedList&lt;TreeNode&gt; ll = <span class="hljs-keyword">new</span> LinkedList&lt;TreeNode&gt;();<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();<br>        <span class="hljs-keyword">this</span>.ll.offer(root);<br>        <span class="hljs-keyword">boolean</span> side = <span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">while</span>(!<span class="hljs-keyword">this</span>.ll.isEmpty())&#123;<br>            List&lt;Integer&gt; cur = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br><br>            <span class="hljs-keyword">if</span>(side)&#123;<br>                cur = traverseFromLeft(<span class="hljs-keyword">this</span>.ll);<br>                side = <span class="hljs-keyword">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                cur = traverseFromRight(<span class="hljs-keyword">this</span>.ll);<br>                side = <span class="hljs-keyword">true</span>;<br>            &#125;<br><br>            res.add(cur);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">traverseFromLeft</span><span class="hljs-params">(LinkedList list)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> len = <span class="hljs-keyword">this</span>.ll.size();<br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)&#123;<br>            TreeNode cur = ll.poll();<br>            res.add(cur.val);<br>            <span class="hljs-keyword">if</span>(cur.left != <span class="hljs-keyword">null</span>) <span class="hljs-keyword">this</span>.ll.offer(cur.left);<br>            <span class="hljs-keyword">if</span>(cur.right != <span class="hljs-keyword">null</span>) <span class="hljs-keyword">this</span>.ll.offer(cur.right);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">traverseFromRight</span><span class="hljs-params">(LinkedList list)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> len = <span class="hljs-keyword">this</span>.ll.size();<br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)&#123;<br>            TreeNode cur = ll.poll();<br>            res.add(cur.val);<br>            <span class="hljs-keyword">if</span>(cur.left != <span class="hljs-keyword">null</span>) <span class="hljs-keyword">this</span>.ll.offer(cur.left);<br>            <span class="hljs-keyword">if</span>(cur.right != <span class="hljs-keyword">null</span>) <span class="hljs-keyword">this</span>.ll.offer(cur.right);<br>        &#125;<br><br>        len = res.size();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; len / <span class="hljs-number">2</span>; j++)&#123;<br>            <span class="hljs-keyword">int</span> tmp = res.get(j);<br>            res.set(j, res.get(len - <span class="hljs-number">1</span> - j));<br>            res.set(len - <span class="hljs-number">1</span> - j, tmp);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><h4 id="思路及算法"><a href="#思路及算法" class="headerlink" title="思路及算法"></a>思路及算法</h4><p>双百的递归，很吊，DFS</p><blockquote><p>1、用deep记录层级，同一层级，存入同一个list<br>2、最后，层级为双数的集合反转</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) &#123;<br>        List&lt;List&lt;Integer&gt;&gt; lists = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        dfs(lists, list, <span class="hljs-number">1</span>, root);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; lists.size(); i += <span class="hljs-number">2</span>) &#123;<br>            Collections.reverse(lists.get(i));<br>        &#125;<br>        <span class="hljs-keyword">return</span> lists;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(List&lt;List&lt;Integer&gt;&gt; lists, List&lt;Integer&gt; list, <span class="hljs-keyword">int</span> deep, TreeNode root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (deep &gt; lists.size()) &#123;<br>            lists.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;());<br>        &#125;<br>        lists.get(deep - <span class="hljs-number">1</span>).add(root.val);<br>        dfs(lists, list, deep + <span class="hljs-number">1</span>, root.left);<br>        dfs(lists, list, deep + <span class="hljs-number">1</span>, root.right);<br>    &#125;<br>&#125;<br><br>作者：si-shui-liu-nian-5b<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/solution/di-gui-ji-hu-shuang-bai-by-si-shui-liu-n-vwa5/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Notes - 105</title>
    <link href="/2021/09/12/LeetCode-Notes-105/"/>
    <url>/2021/09/12/LeetCode-Notes-105/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-Notes-105"><a href="#Leetcode-Notes-105" class="headerlink" title="Leetcode Notes - 105"></a>Leetcode Notes - 105</h1><p>题目：<strong>105. 从前序与中序遍历构造二叉树</strong></p><p>难度：<strong>中等</strong></p><p>遇见次数：<strong>第二次</strong></p><p>涉及知识点：</p><ul><li>栈</li><li>二叉树</li></ul><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>学习后解答，很基础🛫</p><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210912153007006.png" alt="栈"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">buildTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] preorder, <span class="hljs-keyword">int</span>[] inorder)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (preorder == <span class="hljs-keyword">null</span> || preorder.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>        TreeNode root = <span class="hljs-keyword">new</span> TreeNode(preorder[<span class="hljs-number">0</span>]);<br>        Deque&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> LinkedList&lt;TreeNode&gt;();<br>        stack.push(root);<br>        <span class="hljs-keyword">int</span> inorderIndex = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; preorder.length; i++) &#123;<br>            <span class="hljs-keyword">int</span> preorderVal = preorder[i];<br>            TreeNode node = stack.peek();<br>            <span class="hljs-keyword">if</span> (node.val != inorder[inorderIndex]) &#123;<br>                node.left = <span class="hljs-keyword">new</span> TreeNode(preorderVal);<br>                stack.push(node.left);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; stack.peek().val == inorder[inorderIndex]) &#123;<br>                    node = stack.pop();<br>                    inorderIndex++;<br>                &#125;<br>                node.right = <span class="hljs-keyword">new</span> TreeNode(preorderVal);<br>                stack.push(node.right);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="栈-1"><a href="#栈-1" class="headerlink" title="栈"></a>栈</h3><h4 id="思路及算法"><a href="#思路及算法" class="headerlink" title="思路及算法"></a>思路及算法</h4><p>同上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Notes - 108</title>
    <link href="/2021/09/12/LeetCode-Notes-108/"/>
    <url>/2021/09/12/LeetCode-Notes-108/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-Notes-108"><a href="#Leetcode-Notes-108" class="headerlink" title="Leetcode Notes - 108"></a>Leetcode Notes - 108</h1><p>题目：<strong>108. 将有序数组转换为二叉搜索树</strong></p><p>难度：<strong>中等</strong></p><p>遇见次数：<strong>第二次</strong></p><p>涉及知识点：</p><ul><li>构造二叉搜索树</li><li>前序遍历</li><li>中序遍历</li></ul><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><p>以中点左侧开始，中序遍历转换📕</p><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210912153133858.png" alt="中序遍历"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">sortedArrayToBST</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(nums.length == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TreeNode(nums[<span class="hljs-number">0</span>]);<br><br>        <span class="hljs-keyword">return</span> inorderTraverse(nums, <span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">inorderTraverse</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] num, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(left &gt; right) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br><br>        <span class="hljs-keyword">int</span> mid = (left + right) / <span class="hljs-number">2</span>;<br><br>        TreeNode root = <span class="hljs-keyword">new</span> TreeNode(num[mid]);<br>        root.left = inorderTraverse(num, left, mid - <span class="hljs-number">1</span>);<br>        root.right = inorderTraverse(num, mid + <span class="hljs-number">1</span>, right);<br><br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="递归-DFS"><a href="#递归-DFS" class="headerlink" title="递归 + DFS"></a>递归 + DFS</h3><h4 id="思路及算法"><a href="#思路及算法" class="headerlink" title="思路及算法"></a>思路及算法</h4><p>BST 的中序遍历是升序的，因此本题等同于根据中序遍历的序列恢复二叉搜索树。</p><p>我们可以以升序序列中的任一个元素作为根节点，以该元素左边的升序序列构建左子树，以该元素右边的升序序列构建右子树，这样得到的树就是一棵二叉搜索树</p><p>又因为本题要求高度平衡，因此我们需要选择升序序列的中间元素作为根节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">sortedArrayToBST</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> dfs(nums, <span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> TreeNode <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> lo, <span class="hljs-keyword">int</span> hi)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (lo &gt; hi) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125; <br>        <span class="hljs-comment">// 以升序数组的中间元素作为根节点 root。</span><br>        <span class="hljs-keyword">int</span> mid = lo + (hi - lo) / <span class="hljs-number">2</span>;<br>        TreeNode root = <span class="hljs-keyword">new</span> TreeNode(nums[mid]);<br>        <span class="hljs-comment">// 递归的构建 root 的左子树与右子树。</span><br>        root.left = dfs(nums, lo, mid - <span class="hljs-number">1</span>);<br>        root.right = dfs(nums, mid + <span class="hljs-number">1</span>, hi); <br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br><br>作者：sweetiee<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/solution/jian-dan-di-gui-bi-xu-miao-dong-by-sweetiee/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Notes - 1249</title>
    <link href="/2021/09/12/LeetCode-Notes-1249/"/>
    <url>/2021/09/12/LeetCode-Notes-1249/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-Notes-1249"><a href="#Leetcode-Notes-1249" class="headerlink" title="Leetcode Notes - 1249"></a>Leetcode Notes - 1249</h1><p>题目：<strong>1249. 移除无效的括号</strong></p><p>难度：<strong>中等</strong></p><p>遇见次数：<strong>第二次</strong></p><p>涉及知识点：</p><ul><li>栈</li><li>StringBuilder</li></ul><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="StringBuilder两步法"><a href="#StringBuilder两步法" class="headerlink" title="StringBuilder两步法"></a>StringBuilder两步法</h3><p>平衡⚖</p><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210912153455508.png" alt="StringBuilder两步法"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">minRemoveToMakeValid</span><span class="hljs-params">(String s)</span> </span>&#123;<br><br>        <span class="hljs-comment">// Parse 1: Remove all invalid &quot;)&quot;</span><br>        StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();<br>        <span class="hljs-keyword">int</span> openSeen = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> balance = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;<br>            <span class="hljs-keyword">char</span> c = s.charAt(i);<br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                openSeen++;<br>                balance++;<br>            &#125; <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;)&#x27;</span>) &#123;<br>                <span class="hljs-keyword">if</span> (balance == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>                balance--;<br>            &#125;<br>            sb.append(c);<br>        &#125;<br><br>        <span class="hljs-comment">// Parse 2: Remove the rightmost &quot;(&quot;</span><br>        StringBuilder result = <span class="hljs-keyword">new</span> StringBuilder();<br>        <span class="hljs-keyword">int</span> openToKeep = openSeen - balance;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; sb.length(); i++) &#123;<br>            <span class="hljs-keyword">char</span> c = sb.charAt(i);<br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                openToKeep--;<br>                <span class="hljs-keyword">if</span> (openToKeep &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            result.append(c);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="同上"><a href="#同上" class="headerlink" title="同上"></a>同上</h3><h4 id="思路及算法"><a href="#思路及算法" class="headerlink" title="思路及算法"></a>思路及算法</h4><p>略，栈很慢，现在起飞了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Notes - 155</title>
    <link href="/2021/09/12/LeetCode-Notes-155/"/>
    <url>/2021/09/12/LeetCode-Notes-155/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-Notes-155"><a href="#Leetcode-Notes-155" class="headerlink" title="Leetcode Notes - 155"></a>Leetcode Notes - 155</h1><p>题目：<strong>155. 最小栈</strong></p><p>难度：<strong>简单</strong></p><p>遇见次数：<strong>第二次</strong></p><p>涉及知识点：</p><ul><li>栈</li><li>链表</li></ul><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="辅助栈-单值记录"><a href="#辅助栈-单值记录" class="headerlink" title="辅助栈 + 单值记录"></a>辅助栈 + 单值记录</h3><p>Easy Guys 🆒</p><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210912153724292.png" alt="辅助栈 + 单值记录"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MinStack</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> min;<br>    Deque&lt;Integer&gt; stk;<br>    <span class="hljs-comment">/** initialize your data structure here. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MinStack</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.min = Integer.MAX_VALUE;<br>        <span class="hljs-keyword">this</span>.stk = <span class="hljs-keyword">new</span> LinkedList&lt;Integer&gt;();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.stk.push(val);<br>        <span class="hljs-keyword">if</span>(val &lt; <span class="hljs-keyword">this</span>.min) <span class="hljs-keyword">this</span>.min = val;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        Integer cur = <span class="hljs-keyword">this</span>.stk.pop();<br>        <span class="hljs-keyword">if</span>((<span class="hljs-keyword">int</span>)cur == <span class="hljs-keyword">this</span>.min)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.stk.isEmpty()) <span class="hljs-keyword">this</span>.min = Integer.MAX_VALUE;<br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">int</span> curMin = Integer.MAX_VALUE;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i : <span class="hljs-keyword">this</span>.stk)&#123;<br>                    <span class="hljs-keyword">if</span>(i &lt; curMin) curMin = i;<br>                &#125;<br>                <span class="hljs-keyword">this</span>.min = curMin;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;<br>        Integer topVal = <span class="hljs-keyword">this</span>.stk.peek();<br>        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>) topVal; <br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMin</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.min;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MinStack object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MinStack obj = new MinStack();</span><br><span class="hljs-comment"> * obj.push(val);</span><br><span class="hljs-comment"> * obj.pop();</span><br><span class="hljs-comment"> * int param_3 = obj.top();</span><br><span class="hljs-comment"> * int param_4 = obj.getMin();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="同上"><a href="#同上" class="headerlink" title="同上"></a>同上</h3><h4 id="思路及算法"><a href="#思路及算法" class="headerlink" title="思路及算法"></a>思路及算法</h4><p>略</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Notes - 707</title>
    <link href="/2021/09/09/LeetCode-Notes-707/"/>
    <url>/2021/09/09/LeetCode-Notes-707/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-Notes-707"><a href="#Leetcode-Notes-707" class="headerlink" title="Leetcode Notes - 707"></a>Leetcode Notes - 707</h1><p>题目：<strong>707. 设计链表</strong></p><p>难度：<strong>中等</strong></p><p>遇见次数：<strong>第二次</strong></p><p>涉及知识点：</p><ul><li>链表</li></ul><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><p>🤭</p><p>![双向链表](<a href="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/%E6%88%AA%E5%B1%8F">https://alipicbed.oss-cn-beijing.aliyuncs.com/img/截屏</a> 2021-09-09 上午10.59.47.png)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h3><h4 id="思路及算法"><a href="#思路及算法" class="headerlink" title="思路及算法"></a>思路及算法</h4><p>双链表比单链表快得多，测试用例花费的时间比单链表快了两倍。但是它更加复杂，它包含了 <code>size</code>，记录链表元素个数，和伪头伪尾。</p><blockquote><p>一样的啦，常数的复杂度</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListNode</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> val;<br>  ListNode next;<br>  ListNode prev;<br>  ListNode(<span class="hljs-keyword">int</span> x) &#123; val = x; &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyLinkedList</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> size;<br>  <span class="hljs-comment">// sentinel nodes as pseudo-head and pseudo-tail</span><br>  ListNode head, tail;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyLinkedList</span><span class="hljs-params">()</span> </span>&#123;<br>    size = <span class="hljs-number">0</span>;<br>    head = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);<br>    tail = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);<br>    head.next = tail;<br>    tail.prev = head;<br>  &#125;<br><br>  <span class="hljs-comment">/** Get the value of the index-th node in the linked list. If the index is invalid, return -1. */</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>    <span class="hljs-comment">// if index is invalid</span><br>    <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt;= size) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">// choose the fastest way: to move from the head</span><br>    <span class="hljs-comment">// or to move from the tail</span><br>    ListNode curr = head;<br>    <span class="hljs-keyword">if</span> (index + <span class="hljs-number">1</span> &lt; size - index)<br>      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; index + <span class="hljs-number">1</span>; ++i) curr = curr.next;<br>    <span class="hljs-keyword">else</span> &#123;<br>      curr = tail;<br>      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size - index; ++i) curr = curr.prev;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> curr.val;<br>  &#125;<br><br>  <span class="hljs-comment">/** Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. */</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addAtHead</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>    ListNode pred = head, succ = head.next;<br><br>    ++size;<br>    ListNode toAdd = <span class="hljs-keyword">new</span> ListNode(val);<br>    toAdd.prev = pred;<br>    toAdd.next = succ;<br>    pred.next = toAdd;<br>    succ.prev = toAdd;<br>  &#125;<br><br>  <span class="hljs-comment">/** Append a node of value val to the last element of the linked list. */</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addAtTail</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>    ListNode succ = tail, pred = tail.prev;<br><br>    ++size;<br>    ListNode toAdd = <span class="hljs-keyword">new</span> ListNode(val);<br>    toAdd.prev = pred;<br>    toAdd.next = succ;<br>    pred.next = toAdd;<br>    succ.prev = toAdd;<br>  &#125;<br><br>  <span class="hljs-comment">/** Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. */</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addAtIndex</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>    <span class="hljs-comment">// If index is greater than the length, </span><br>    <span class="hljs-comment">// the node will not be inserted.</span><br>    <span class="hljs-keyword">if</span> (index &gt; size) <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-comment">// [so weird] If index is negative, </span><br>    <span class="hljs-comment">// the node will be inserted at the head of the list.</span><br>    <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span>) index = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// find predecessor and successor of the node to be added</span><br>    ListNode pred, succ;<br>    <span class="hljs-keyword">if</span> (index &lt; size - index) &#123;<br>      pred = head;<br>      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; index; ++i) pred = pred.next;<br>      succ = pred.next;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>      succ = tail;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size - index; ++i) succ = succ.prev;<br>      pred = succ.prev;<br>    &#125;<br><br>    <span class="hljs-comment">// insertion itself</span><br>    ++size;<br>    ListNode toAdd = <span class="hljs-keyword">new</span> ListNode(val);<br>    toAdd.prev = pred;<br>    toAdd.next = succ;<br>    pred.next = toAdd;<br>    succ.prev = toAdd;<br>  &#125;<br><br>  <span class="hljs-comment">/** Delete the index-th node in the linked list, if the index is valid. */</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteAtIndex</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>    <span class="hljs-comment">// if the index is invalid, do nothing</span><br>    <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt;= size) <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-comment">// find predecessor and successor of the node to be deleted</span><br>    ListNode pred, succ;<br>    <span class="hljs-keyword">if</span> (index &lt; size - index) &#123;<br>      pred = head;<br>      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; index; ++i) pred = pred.next;<br>      succ = pred.next.next;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>      succ = tail;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size - index - <span class="hljs-number">1</span>; ++i) succ = succ.prev;<br>      pred = succ.prev.prev;<br>    &#125;<br><br>    <span class="hljs-comment">// delete pred.next </span><br>    --size;<br>    pred.next = succ;<br>    succ.prev = pred;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Notes - 24</title>
    <link href="/2021/09/09/LeetCode-Notes-24/"/>
    <url>/2021/09/09/LeetCode-Notes-24/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-Notes-24"><a href="#Leetcode-Notes-24" class="headerlink" title="Leetcode Notes - 24"></a>Leetcode Notes - 24</h1><p>题目：<strong>24. 两两交换链表中的节点</strong></p><p>难度：<strong>中等</strong></p><p>遇见次数：<strong>第二次</strong></p><p>涉及知识点：</p><ul><li>链表</li></ul><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h3><p>直接修改，快！📕</p><p>![快慢指针](<a href="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/%E6%88%AA%E5%B1%8F">https://alipicbed.oss-cn-beijing.aliyuncs.com/img/截屏</a> 2021-09-09 上午11.00.33.png)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">swapPairs</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-keyword">null</span> || head.next == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> head;<br>        <br>        ListNode dummy = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);<br>        ListNode tmp = dummy;<br>        <span class="hljs-keyword">while</span>(head != <span class="hljs-keyword">null</span> &amp;&amp; head.next != <span class="hljs-keyword">null</span>)&#123;<br>            ListNode first = head;<br>            head = head.next;<br>            ListNode second = head;<br>            head = head.next;<br>            <br>            tmp.next = second;<br>            second.next = first;<br>            first.next = head;<br>            <br>            tmp = tmp.next.next;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><h4 id="思路及算法"><a href="#思路及算法" class="headerlink" title="思路及算法"></a>思路及算法</h4><blockquote><p>上面写了迭代的解法，记录一个递归的解法</p></blockquote><p>递归的终止条件是链表中没有节点，或者链表中只有一个节点，此时无法进行交换。</p><p>如果链表中至少有两个节点，则在两两交换链表中的节点之后，原始链表的头节点变成新的链表的第二个节点，原始链表的第二个节点变成新的链表的头节点。链表中的其余节点的两两交换可以递归地实现。在对链表中的其余节点递归地两两交换之后，更新节点之间的指针关系，即可完成整个链表的两两交换。</p><ul><li>用 <code>head</code> 表示原始链表的头节点，新的链表的第二个节点，用 <code>newHead</code> 表示新的链表的头节点，原始链表的第二个节点，则原始链表中的其余节点的头节点是 <code>newHead.next</code></li><li>令 <code>head.next = swapPairs(newHead.next)</code>，表示将其余节点进行两两交换，交换后的新的头节点为 <code>head</code> 的下一个节点</li><li>然后令 <code>newHead.next = head</code>，即完成了所有节点的交换</li><li>最后返回新的链表的头节点 <code>newHead</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">swapPairs</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span> || head.next == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        ListNode newHead = head.next;<br>        head.next = swapPairs(newHead.next);<br>        newHead.next = head;<br>        <span class="hljs-keyword">return</span> newHead;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Notes - 160</title>
    <link href="/2021/09/08/LeetCode-Notes-160/"/>
    <url>/2021/09/08/LeetCode-Notes-160/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-Notes-160"><a href="#Leetcode-Notes-160" class="headerlink" title="Leetcode Notes - 160"></a>Leetcode Notes - 160</h1><p>题目：<strong>160. 相交链表</strong></p><p>难度：<strong>简单</strong></p><p>遇见次数：<strong>第二次</strong></p><p>涉及知识点：</p><ul><li>链表</li></ul><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="哈希集合"><a href="#哈希集合" class="headerlink" title="哈希集合"></a>哈希集合</h3><p>老套路了📕</p><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210908114136879.png" alt="哈希集合"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode(int x) &#123;</span><br><span class="hljs-comment"> *         val = x;</span><br><span class="hljs-comment"> *         next = null;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode headA, ListNode headB)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(headA == <span class="hljs-keyword">null</span> || headB == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br><br>        Set&lt;ListNode&gt; hs = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br><br>        <span class="hljs-keyword">while</span>(headA != <span class="hljs-keyword">null</span>)&#123;<br>            hs.add(headA);<br>            headA = headA.next;<br>        &#125;<br><br>        <span class="hljs-keyword">while</span>(headB != <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">if</span>(hs.contains(headB))&#123;<br>                <span class="hljs-keyword">return</span> headB;<br>            &#125;<br><br>            headB = headB.next;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><h4 id="思路及算法"><a href="#思路及算法" class="headerlink" title="思路及算法"></a>思路及算法</h4><p>使用双指针的方法，可以将空间复杂度降至 O(1)。</p><p>只有当链表 headA 和 headB 都不为空时，两个链表才可能相交。因此首先判断链表 headA 和 headB 是否为空，如果其中至少有一个链表为空，则两个链表一定不相交，返回 null。</p><p>当链表 headA 和 headB 都不为空时，创建两个指针 pA 和 pB，初始时分别指向两个链表的头节点 headA 和 headB，然后将两个指针依次遍历两个链表的每个节点。具体做法如下：</p><p>每步操作需要同时更新指针 pA 和 pB。</p><p>如果指针 pA 不为空，则将指针 pA 移到下一个节点；如果指针 pB 不为空，则将指针 pB 移到下一个节点。</p><p>如果指针 pA 为空，则将指针 pA 移到链表 headB 的头节点；如果指针 pB 为空，则将指针 pB 移到链表 headA 的头节点。</p><p>当指针 pA 和 pB 指向同一个节点或者都为空时，返回它们指向的节点或者 null。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode headA, ListNode headB)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (headA == <span class="hljs-keyword">null</span> || headB == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>        ListNode pA = headA, pB = headB;<br>        <span class="hljs-keyword">while</span> (pA != pB) &#123;<br>            pA = pA == <span class="hljs-keyword">null</span> ? headB : pA.next;<br>            pB = pB == <span class="hljs-keyword">null</span> ? headA : pB.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pA;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Notes - 82</title>
    <link href="/2021/09/08/LeetCode-Notes-82/"/>
    <url>/2021/09/08/LeetCode-Notes-82/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-Notes-82"><a href="#Leetcode-Notes-82" class="headerlink" title="Leetcode Notes - 82"></a>Leetcode Notes - 82</h1><p>题目：<strong>82. 删除排序链表里的重复元素 II</strong></p><p>难度：<strong>中等</strong></p><p>遇见次数：<strong>第二次</strong></p><p>涉及知识点：</p><ul><li>链表</li></ul><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="一次遍历-新链表"><a href="#一次遍历-新链表" class="headerlink" title="一次遍历 + 新链表"></a>一次遍历 + 新链表</h3><p>哨兵记录前一个结点的值，非重复节点的特点是——</p><blockquote><p><strong>prev != head.val &amp;&amp; head.val != head.next.val</strong></p></blockquote><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210908113827310.png" alt="一次遍历"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">deleteDuplicates</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br><br>        <span class="hljs-keyword">int</span> prev = -<span class="hljs-number">101</span>;<br>        ListNode dummy = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);<br>        ListNode res = <span class="hljs-keyword">new</span> ListNode();<br>        dummy.next = res;<br>        <span class="hljs-keyword">while</span>(head.next != <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">if</span>(head.next.val != head.val &amp;&amp; prev != head.val)&#123;<br>                res.next = <span class="hljs-keyword">new</span> ListNode(head.val,<span class="hljs-keyword">null</span>);<br>                res = res.next;<br>                prev = head.val;<br>                head = head.next;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                prev = head.val;<br>                head = head.next;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(head.val != prev)&#123;<br>            res.next = <span class="hljs-keyword">new</span> ListNode(head.val,<span class="hljs-keyword">null</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dummy.next.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="一次遍历"><a href="#一次遍历" class="headerlink" title="一次遍历"></a>一次遍历</h3><h4 id="思路及算法"><a href="#思路及算法" class="headerlink" title="思路及算法"></a>思路及算法</h4><p>由于给定的链表是排好序的，因此重复的元素在链表中出现的位置是连续的，因此我们只需要对链表进行一次遍历，就可以删除重复的元素。<strong>由于链表的头节点可能会被删除，因此我们需要额外使用一个哑节点（dummy node）指向链表的头节点。</strong></p><p>具体地，我们从指针 cur 指向链表的哑节点，随后开始对链表进行遍历。如果当前 cur.next 与 cur.next.next 对应的元素相同，那么我们就需要将 cur.next 以及所有后面拥有相同元素值的链表节点全部删除。我们记下这个元素值 xx，随后不断将 cur.next 从链表中移除，直到 cur.next 为空节点或者其元素值不等于 x 为止。此时，我们将链表中所有元素值为 x 的节点全部删除。</p><p>如果当前 cur.next 与 cur.next.next 对应的元素不相同，那么说明链表中只有一个元素值为 cur.next 的节点，那么我们就可以将 cur 指向 cur.next。</p><p>当遍历完整个链表之后，我们返回链表的的哑节点的下一个节点 dummy.next 即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">deleteDuplicates</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        <br>        ListNode dummy = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>, head);<br><br>        ListNode cur = dummy;<br>        <span class="hljs-keyword">while</span> (cur.next != <span class="hljs-keyword">null</span> &amp;&amp; cur.next.next != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (cur.next.val == cur.next.next.val) &#123;<br>                <span class="hljs-keyword">int</span> x = cur.next.val;<br>                <span class="hljs-keyword">while</span> (cur.next != <span class="hljs-keyword">null</span> &amp;&amp; cur.next.val == x) &#123;<br>                    cur.next = cur.next.next;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                cur = cur.next;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Notes - 2</title>
    <link href="/2021/09/07/LeetCode-Notes-2/"/>
    <url>/2021/09/07/LeetCode-Notes-2/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-Notes-2"><a href="#Leetcode-Notes-2" class="headerlink" title="Leetcode Notes - 2"></a>Leetcode Notes - 2</h1><p>题目：<strong>2. 两数相加</strong></p><p>难度：<strong>中等</strong></p><p>遇见次数：<strong>第二次</strong></p><p>涉及知识点：</p><ul><li>链表</li></ul><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="1-队列"><a href="#1-队列" class="headerlink" title="1. 队列"></a>1. 队列</h3><p>不太行🛬</p><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210907124355851.png" alt="1. 队列"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">addTwoNumbers</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> </span>&#123;<br>        Queue&lt;Integer&gt; que1 = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        Queue&lt;Integer&gt; que2 = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        <br>        <span class="hljs-keyword">while</span>(l1 != <span class="hljs-keyword">null</span> || l2 != <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">if</span>(l1 != <span class="hljs-keyword">null</span>)&#123;<br>                que1.offer(l1.val);<br>                l1 = l1.next;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(l2 != <span class="hljs-keyword">null</span>)&#123;<br>                que2.offer(l2.val);<br>                l2 = l2.next;<br>            &#125;<br>        &#125;<br>        <br>        ListNode ans = <span class="hljs-keyword">this</span>.addQueue(que1, que2);<br>        <br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">private</span> ListNode <span class="hljs-title">addQueue</span><span class="hljs-params">(Queue q1, Queue q2)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(q1.size() &lt; q2.size()) <span class="hljs-keyword">return</span> addQueue(q2, q1);<br>        <br>        <span class="hljs-keyword">int</span> addOn = <span class="hljs-number">0</span>;<br>        ListNode prev = <span class="hljs-keyword">null</span>;<br>        ListNode dummy = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);<br>        ListNode head = <span class="hljs-keyword">new</span> ListNode();<br>        dummy.next = head;<br>        <span class="hljs-keyword">while</span>(!q1.isEmpty())&#123;<br>            <span class="hljs-keyword">int</span> cur = (<span class="hljs-keyword">int</span>) q1.poll();<br>            <span class="hljs-keyword">if</span>(!q2.isEmpty())&#123;<br>                <span class="hljs-keyword">int</span> tmp = (<span class="hljs-keyword">int</span>) q2.poll();<br>                cur += tmp;<br>            &#125;<br>            cur += addOn;<br>            <br>            <span class="hljs-keyword">if</span>(cur &gt;= <span class="hljs-number">10</span>)&#123;<br>                addOn = <span class="hljs-number">1</span>;<br>                head.val = cur - <span class="hljs-number">10</span>;<br>                head.next = <span class="hljs-keyword">new</span> ListNode();<br>                prev = head;<br>                head = head.next;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                addOn = <span class="hljs-number">0</span>;<br>                head.val = cur;<br>                head.next = <span class="hljs-keyword">new</span> ListNode();<br>                prev = head;<br>                head = head.next;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span>(addOn == <span class="hljs-number">1</span>)&#123;<br>            head.val = <span class="hljs-number">1</span>;<br>            head.next = <span class="hljs-keyword">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            prev.next = <span class="hljs-keyword">null</span>;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h3><h4 id="思路及算法"><a href="#思路及算法" class="headerlink" title="思路及算法"></a>思路及算法</h4><p>一次遍历，直接合成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">addTwoNumbers</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> </span>&#123;<br>        ListNode head = <span class="hljs-keyword">null</span>, tail = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">int</span> carry = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (l1 != <span class="hljs-keyword">null</span> || l2 != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">int</span> n1 = l1 != <span class="hljs-keyword">null</span> ? l1.val : <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">int</span> n2 = l2 != <span class="hljs-keyword">null</span> ? l2.val : <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">int</span> sum = n1 + n2 + carry;<br>            <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;<br>                head = tail = <span class="hljs-keyword">new</span> ListNode(sum % <span class="hljs-number">10</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                tail.next = <span class="hljs-keyword">new</span> ListNode(sum % <span class="hljs-number">10</span>);<br>                tail = tail.next;<br>            &#125;<br>            carry = sum / <span class="hljs-number">10</span>;<br>            <span class="hljs-keyword">if</span> (l1 != <span class="hljs-keyword">null</span>) &#123;<br>                l1 = l1.next;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (l2 != <span class="hljs-keyword">null</span>) &#123;<br>                l2 = l2.next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (carry &gt; <span class="hljs-number">0</span>) &#123;<br>            tail.next = <span class="hljs-keyword">new</span> ListNode(carry);<br>        &#125;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Notes - 142</title>
    <link href="/2021/09/07/LeetCode-Notes-142/"/>
    <url>/2021/09/07/LeetCode-Notes-142/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-Notes-142"><a href="#Leetcode-Notes-142" class="headerlink" title="Leetcode Notes - 142"></a>Leetcode Notes - 142</h1><p>题目：<strong>142. 环形链表 II</strong></p><p>难度：<strong>中等</strong></p><p>遇见次数：<strong>第二次</strong></p><p>涉及知识点：</p><ul><li>链表</li></ul><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="哈希集合"><a href="#哈希集合" class="headerlink" title="哈希集合"></a>哈希集合</h3><p>哈希集合检测，双十😂</p><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210907133128466.png" alt="哈希集合"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode(int x) &#123;</span><br><span class="hljs-comment"> *         val = x;</span><br><span class="hljs-comment"> *         next = null;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">detectCycle</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>        Set&lt;ListNode&gt; hs = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br>        <br>        <span class="hljs-keyword">while</span>(head != <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">if</span>(hs.contains(head))&#123;<br>                <span class="hljs-keyword">return</span> head;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                hs.add(head);<br>                head = head.next;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h3><h4 id="思路及算法"><a href="#思路及算法" class="headerlink" title="思路及算法"></a>思路及算法</h4><p>我们使用两个指针，fast 与 slow。它们起始都位于链表的头部。随后，slow 指针每次向后移动一个位置，而 fast 指针向后移动两个位置。如果链表中存在环，则 fast 指针最终将再次与 slow 指针在环中相遇。</p><p>如下图所示，设链表中环外部分的长度为 a。slow 指针进入环后，又走了 b 的距离与 fast 相遇。此时，fast 指针已经走完了环的 nn 圈，因此它走过的总距离为 </p><blockquote><p>a +n * ( b + c ) + b = a + ( n + 1 ) * b + n * c</p></blockquote><p>根据题意，任意时刻，fast 指针走过的距离都为 slow 指针的 22 倍。因此，我们有</p><blockquote><p>a + ( n + 1 ) * b + n * c = 2 * ( a + b ) ⟹ a = c + ( n − 1 ) * ( b + c ) </p></blockquote><p>有了 a = c + ( n - 1 ) * ( b + c ) * a = c + ( n − 1 ) * ( b + c ) 的等量关系，我们会发现：从相遇点到入环点的距离加上 n-1 圈的环长，恰好等于从链表头部到入环点的距离。</p><p>因此，当发现 slow 与 fast 相遇时，我们再额外使用一个指针 ptr。起始，它指向链表头部；随后，它和 slow 每次向后移动一个位置。最终，它们会在入环点相遇。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">detectCycle</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>        ListNode slow = head, fast = head;<br>        <span class="hljs-keyword">while</span> (fast != <span class="hljs-keyword">null</span>) &#123;<br>            slow = slow.next;<br>            <span class="hljs-keyword">if</span> (fast.next != <span class="hljs-keyword">null</span>) &#123;<br>                fast = fast.next.next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (fast == slow) &#123;<br>                ListNode ptr = head;<br>                <span class="hljs-keyword">while</span> (ptr != slow) &#123;<br>                    ptr = ptr.next;<br>                    slow = slow.next;<br>                &#125;<br>                <span class="hljs-keyword">return</span> ptr;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Notes - 1221</title>
    <link href="/2021/09/07/LeetCode-Notes-1221/"/>
    <url>/2021/09/07/LeetCode-Notes-1221/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-Notes-1221"><a href="#Leetcode-Notes-1221" class="headerlink" title="Leetcode Notes - 1221"></a>Leetcode Notes - 1221</h1><p>题目：<strong>1221. 分割平衡字符串</strong></p><p>难度：<strong>简单</strong></p><p>遇见次数：<strong>第一次</strong></p><p>涉及知识点：</p><ul><li>字符串</li></ul><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="哈希表-贪心"><a href="#哈希表-贪心" class="headerlink" title="哈希表 + 贪心"></a>哈希表 + 贪心</h3><p>简单题乱杀🗡</p><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210907132456213.png" alt="哈希表"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">balancedStringSplit</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[] mp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">2</span>];<br>        <br>        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> ch : s.toCharArray())&#123;<br>            <span class="hljs-keyword">int</span> cur = ch == <span class="hljs-string">&#x27;L&#x27;</span> ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>;<br>            mp[cur]++;<br>            <br>            <span class="hljs-keyword">if</span>(mp[cur] == mp[<span class="hljs-number">1</span> - cur])&#123;<br>                count++;<br>            &#125;<br>            <br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h3><h4 id="思路及算法"><a href="#思路及算法" class="headerlink" title="思路及算法"></a>思路及算法</h4><p>根据题意，对于一个平衡字符串 s，若 s 能从中间某处分割成左右两个子串，若其中一个是平衡字符串，则另一个的 L 和 R 字符的数量必然是相同的，所以也一定是平衡字符串。</p><p>为了最大化分割数量，我们可以不断循环，每次从 s 中分割出一个最短的平衡前缀，由于剩余部分也是平衡字符串，我们可以将其当作 s 继续分割，直至 s 为空时，结束循环。</p><p>代码实现中，可以在遍历 s 时用一个变量 dd 维护 L 和 R 字符的数量之差，当 d = 0 时就说明找到了一个平衡字符串，将答案加一。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">balancedStringSplit</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>, d = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.length(); ++i) &#123;<br>            <span class="hljs-keyword">char</span> ch = s.charAt(i);<br>            <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;L&#x27;</span>) &#123;<br>                ++d;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                --d;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (d == <span class="hljs-number">0</span>) &#123;<br>                ++ans;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Notes - 187</title>
    <link href="/2021/09/06/LeetCode-Notes-187/"/>
    <url>/2021/09/06/LeetCode-Notes-187/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-Notes-187"><a href="#Leetcode-Notes-187" class="headerlink" title="Leetcode Notes - 187"></a>Leetcode Notes - 187</h1><p>题目：<strong>187. 重复的 DNA 序列</strong></p><p>难度：<strong>中等</strong></p><p>遇见次数：<strong>第二次</strong></p><p>涉及知识点：</p><ul><li>哈希表</li><li>双指针</li></ul><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="1-哈希表"><a href="#1-哈希表" class="headerlink" title="1. 哈希表"></a>1. 哈希表</h3><p>已出现的字串作为键📕</p><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210906161750320.png" alt="哈希表"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">findRepeatedDnaSequences</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(s.length() &lt;= <span class="hljs-number">10</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br><br>        Map&lt;String, Integer&gt; mp = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        <span class="hljs-keyword">int</span> len = s.length();<br>        List&lt;String&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i + <span class="hljs-number">9</span> &lt; len; i++)&#123;<br>            String str = s.substring(i, i + <span class="hljs-number">10</span>);<br>            <span class="hljs-keyword">int</span> cur = mp.getOrDefault(str, <span class="hljs-number">0</span>);<br><br>            <span class="hljs-keyword">if</span>(cur == <span class="hljs-number">0</span>)&#123;<br>                mp.put(str, <span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cur == <span class="hljs-number">1</span>)&#123;<br>                mp.put(str, cur + <span class="hljs-number">1</span>);<br>                res.add(str);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="位操作"><a href="#位操作" class="headerlink" title="位操作"></a>位操作</h3><h4 id="思路及算法"><a href="#思路及算法" class="headerlink" title="思路及算法"></a>思路及算法</h4><p>掩码实现滑动窗口切片。</p><p>遍历序列的起始位置：从 1 到 N - L。</p><ul><li>如果 start == 0，计算第一个序列 s [0 : L] 的掩码。</li><li>否则，从前一个掩码计算当前掩码。</li><li>如果掩码在 hashset 中，说明是重复序列，更新输出。</li><li>否则，将该掩码添加到 hashset。</li></ul><p>返回输出列表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">findRepeatedDnaSequences</span><span class="hljs-params">(String s)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> L = <span class="hljs-number">10</span>, n = s.length();<br>    <span class="hljs-keyword">if</span> (n &lt;= L) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArrayList();<br><br>    <span class="hljs-comment">// rolling hash parameters: base a</span><br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">4</span>, aL = (<span class="hljs-keyword">int</span>)Math.pow(a, L);<br><br>    <span class="hljs-comment">// convert string to array of integers</span><br>    Map&lt;Character, Integer&gt; toInt = <span class="hljs-keyword">new</span> HashMap() &#123;&#123;put(<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-number">0</span>); put(<span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-number">1</span>); put(<span class="hljs-string">&#x27;G&#x27;</span>, <span class="hljs-number">2</span>); put(<span class="hljs-string">&#x27;T&#x27;</span>, <span class="hljs-number">3</span>); &#125;&#125;;<br>    <span class="hljs-keyword">int</span>[] nums = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) nums[i] = toInt.get(s.charAt(i));<br><br>    <span class="hljs-keyword">int</span> bitmask = <span class="hljs-number">0</span>;<br>    Set&lt;Integer&gt; seen = <span class="hljs-keyword">new</span> HashSet();<br>    Set&lt;String&gt; output = <span class="hljs-keyword">new</span> HashSet();<br>    <span class="hljs-comment">// iterate over all sequences of length L</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> start = <span class="hljs-number">0</span>; start &lt; n - L + <span class="hljs-number">1</span>; ++start) &#123;<br>      <span class="hljs-comment">// compute bitmask of the current sequence in O(1) time</span><br>      <span class="hljs-keyword">if</span> (start != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// left shift to free the last 2 bit</span><br>        bitmask &lt;&lt;= <span class="hljs-number">2</span>;<br>        <span class="hljs-comment">// add a new 2-bits number in the last two bits</span><br>        bitmask |= nums[start + L - <span class="hljs-number">1</span>];<br>        <span class="hljs-comment">// unset first two bits: 2L-bit and (2L + 1)-bit</span><br>        bitmask &amp;= ~(<span class="hljs-number">3</span> &lt;&lt; <span class="hljs-number">2</span> * L);<br>      &#125;<br>      <span class="hljs-comment">// compute hash of the first sequence in O(L) time</span><br>      <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; L; ++i) &#123;<br>          bitmask &lt;&lt;= <span class="hljs-number">2</span>;<br>          bitmask |= nums[i];<br>        &#125;<br>      &#125;<br>      <span class="hljs-comment">// update output and hashset of seen sequences</span><br>      <span class="hljs-keyword">if</span> (seen.contains(bitmask)) output.add(s.substring(start, start + L));<br>      seen.add(bitmask);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;(output);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Notes - 5</title>
    <link href="/2021/09/06/LeetCode-Notes-5/"/>
    <url>/2021/09/06/LeetCode-Notes-5/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-Notes-5"><a href="#Leetcode-Notes-5" class="headerlink" title="Leetcode Notes - 5"></a>Leetcode Notes - 5</h1><p>题目：<strong>5. 最长回文子串</strong></p><p>难度：<strong>中等</strong></p><p>遇见次数：<strong>第二次</strong></p><p>涉及知识点：</p><ul><li>中心扩展</li><li>动态规划</li></ul><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="中心扩展"><a href="#中心扩展" class="headerlink" title="中心扩展"></a>中心扩展</h3><p>非常非常慢😂</p><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210906161400690.png" alt="预处理后中心扩展"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(s.length() == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> s;<br><br>        <span class="hljs-comment">// Transform</span><br>        StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> ch : s.toCharArray())&#123;<br>            sb.append(<span class="hljs-string">&#x27;#&#x27;</span>);<br>            sb.append(ch);<br>        &#125;<br>        sb.append(<span class="hljs-string">&#x27;#&#x27;</span>);<br>        String tfStr = sb.toString();<br><br>        <span class="hljs-keyword">int</span> maxLen = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> begin = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; tfStr.length(); i++)&#123;<br>            <span class="hljs-keyword">int</span> curLen = expand(i, tfStr);<br><br>            <span class="hljs-keyword">if</span>(curLen &gt; maxLen)&#123;<br>                begin = i;<br>                maxLen = curLen;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(maxLen == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> s.substring(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br><br>        StringBuilder ans = <span class="hljs-keyword">new</span> StringBuilder();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> ele : (tfStr.substring(begin - (maxLen - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>, begin + (maxLen - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>)).toCharArray())&#123;<br>            <span class="hljs-keyword">if</span>(ele != <span class="hljs-string">&#x27;#&#x27;</span>)&#123;<br>                ans.append(ele);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans.toString();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">expand</span><span class="hljs-params">(<span class="hljs-keyword">int</span> curIndex, String str)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> left = curIndex;<br>        <span class="hljs-keyword">int</span> right = curIndex;<br>        <span class="hljs-keyword">char</span>[] chArr = str.toCharArray();<br><br>        <span class="hljs-keyword">while</span>(chArr[left] == chArr[right])&#123;<br>            left--;<br>            right++;<br><br>            <span class="hljs-keyword">if</span>(left == -<span class="hljs-number">1</span> || right == chArr.length) <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> right - left - <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="中心扩展-1"><a href="#中心扩展-1" class="headerlink" title="中心扩展"></a>中心扩展</h3><h4 id="思路及算法"><a href="#思路及算法" class="headerlink" title="思路及算法"></a>思路及算法</h4><p>可以发现，所有的状态在转移的时候的可能性都是唯一的。也就是说，我们可以从每一种边界情况开始「扩展」，也可以得出所有的状态对应的答案。</p><p>边界情况即为子串长度为 1 或 2 的情况。我们枚举每一种边界情况，并从对应的子串开始不断地向两边扩展。</p><ul><li>如果两边的字母相同，我们就可以继续扩展，例如从 <code>P(i+1,j−1)</code> 扩展到 <code>P(i,j)</code></li><li>如果两边的字母不同，我们就可以停止扩展，因为在这之后的子串都不能是回文串了。</li></ul><p>聪明的读者此时应该可以发现，「边界情况」对应的子串实际上就是我们「扩展」出的回文串的「回文中心」。方法二的本质即为：我们枚举所有的「回文中心」并尝试「扩展」，直到无法扩展为止，此时的回文串长度即为此「回文中心」下的最长回文串长度。我们对所有的长度求出最大值，即可得到最终的答案。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (s == <span class="hljs-keyword">null</span> || s.length() &lt; <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> start = <span class="hljs-number">0</span>, end = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;<br>            <span class="hljs-keyword">int</span> len1 = expandAroundCenter(s, i, i);<br>            <span class="hljs-keyword">int</span> len2 = expandAroundCenter(s, i, i + <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">int</span> len = Math.max(len1, len2);<br>            <span class="hljs-keyword">if</span> (len &gt; end - start) &#123;<br>                start = i - (len - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>                end = i + len / <span class="hljs-number">2</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> s.substring(start, end + <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">expandAroundCenter</span><span class="hljs-params">(String s, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (left &gt;= <span class="hljs-number">0</span> &amp;&amp; right &lt; s.length() &amp;&amp; s.charAt(left) == s.charAt(right)) &#123;<br>            --left;<br>            ++right;<br>        &#125;<br>        <span class="hljs-keyword">return</span> right - left - <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Notes - 49</title>
    <link href="/2021/09/05/LeetCode-Notes-49/"/>
    <url>/2021/09/05/LeetCode-Notes-49/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-Notes-49"><a href="#Leetcode-Notes-49" class="headerlink" title="Leetcode Notes - 49"></a>Leetcode Notes - 49</h1><p>题目：<strong>49. 字母异位词</strong></p><p>难度：<strong>中等</strong></p><p>遇见次数：<strong>第二次</strong></p><p>涉及知识点：</p><ul><li>哈希表</li><li>将计数融入键</li></ul><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="1-哈希表计数"><a href="#1-哈希表计数" class="headerlink" title="1. 哈希表计数"></a>1. 哈希表计数</h3><p>顺序不对，不给过😭</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;<br>        Map&lt;String, List&lt;String&gt;&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;String, List&lt;String&gt;&gt;();<br>        Map&lt;Character, Integer&gt; mp = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br><br>        <span class="hljs-keyword">for</span> (String str : strs) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> ch : str.toCharArray())&#123;<br>                <span class="hljs-keyword">int</span> cur = mp.getOrDefault(ch, <span class="hljs-number">0</span>);<br>                mp.put(ch, cur + <span class="hljs-number">1</span>);<br>            &#125;<br>            <br>            StringBuffer sb = <span class="hljs-keyword">new</span> StringBuffer();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> ele : mp.keySet())&#123;<br>                sb.append(ele);<br>                sb.append(mp.get(ele));<br>            &#125;<br>            String key = sb.toString();<br>            List&lt;String&gt; list = map.getOrDefault(key, <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;());<br>            list.add(str);<br>            map.put(key, list);<br>            mp.clear();<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArrayList&lt;List&lt;String&gt;&gt;(map.values());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="计数"><a href="#计数" class="headerlink" title="计数"></a>计数</h3><h4 id="思路及算法"><a href="#思路及算法" class="headerlink" title="思路及算法"></a>思路及算法</h4><p>由于互为字母异位词的两个字符串包含的字母相同，因此两个字符串中的相同字母出现的次数一定是相同的，故可以将每个字母出现的次数使用字符串表示，作为哈希表的键。</p><p>由于字符串只包含小写字母，因此对于每个字符串，可以使用长度为 26 的数组记录每个字母出现的次数。</p><p>需要注意的是，在使用数组作为哈希表的键时，不同语言的支持程度不同，因此不同语言的实现方式也不同。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;<br>        Map&lt;String, List&lt;String&gt;&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;String, List&lt;String&gt;&gt;();<br>        <span class="hljs-keyword">for</span> (String str : strs) &#123;<br>            <span class="hljs-keyword">int</span>[] counts = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">26</span>];<br>            <span class="hljs-keyword">int</span> length = str.length();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>                counts[str.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>            &#125;<br>            <span class="hljs-comment">// 将每个出现次数大于 0 的字母和出现次数按顺序拼接成字符串，作为哈希表的键</span><br>            StringBuffer sb = <span class="hljs-keyword">new</span> StringBuffer();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++) &#123;<br>                <span class="hljs-keyword">if</span> (counts[i] != <span class="hljs-number">0</span>) &#123;<br>                    sb.append((<span class="hljs-keyword">char</span>) (<span class="hljs-string">&#x27;a&#x27;</span> + i));<br>                    sb.append(counts[i]);<br>                &#125;<br>            &#125;<br>            String key = sb.toString();<br>            List&lt;String&gt; list = map.getOrDefault(key, <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;());<br>            list.add(str);<br>            map.put(key, list);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArrayList&lt;List&lt;String&gt;&gt;(map.values());<br>    &#125;<br>&#125;<br><br>作者：LeetCode-Solution<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/group-anagrams/solution/zi-mu-yi-wei-ci-fen-zu-by-leetcode-solut-gyoc/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Notes - 43</title>
    <link href="/2021/09/05/LeetCode-Notes-43/"/>
    <url>/2021/09/05/LeetCode-Notes-43/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-Notes-43"><a href="#Leetcode-Notes-43" class="headerlink" title="Leetcode Notes - 43"></a>Leetcode Notes - 43</h1><p>题目：<strong>43. 字符串相乘</strong></p><p>难度：<strong>中等</strong></p><p>遇见次数：<strong>第二次</strong></p><p>涉及知识点：</p><ul><li>模拟</li><li>字符串</li></ul><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="1-模拟"><a href="#1-模拟" class="headerlink" title="1. 模拟"></a>1. 模拟</h3><p>做乘法，无敌！📕</p><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210905162611046.png" alt="模拟"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">multiply</span><span class="hljs-params">(String num1, String num2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(num1.length() &lt; num2.length()) <span class="hljs-keyword">return</span> multiply(num2, num1);<br><br>        <span class="hljs-keyword">if</span> (num1.equals(<span class="hljs-string">&quot;0&quot;</span>) || num2.equals(<span class="hljs-string">&quot;0&quot;</span>)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;0&quot;</span>;<br>        &#125;<br>        <br>        <span class="hljs-comment">// Main Algorithm</span><br>        <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[num1.length() + num2.length()];<br>        <span class="hljs-keyword">char</span>[] n1Arr = num1.toCharArray();<br>        <span class="hljs-keyword">char</span>[] n2Arr = num2.toCharArray();<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = n2Arr.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123;<br>            <span class="hljs-keyword">int</span> ten = n2Arr.length - <span class="hljs-number">1</span> - i;<br><br>            <span class="hljs-keyword">int</span> start = res.length - <span class="hljs-number">1</span> - ten;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = n1Arr.length - <span class="hljs-number">1</span>; k &gt;= <span class="hljs-number">0</span>; k--)&#123;<br>                <span class="hljs-keyword">int</span> cur = (n1Arr[k] - <span class="hljs-string">&#x27;0&#x27;</span>) * (n2Arr[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>                res[start] += cur;<br>                start--;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = res.length - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">1</span>; j--)&#123;<br>            <span class="hljs-keyword">int</span> addOn = res[j] - (res[j] % <span class="hljs-number">10</span>);<br>            res[j - <span class="hljs-number">1</span>] += addOn / <span class="hljs-number">10</span>;<br>            res[j] = res[j] % <span class="hljs-number">10</span>;<br>        &#125;<br><br>        StringBuilder result = <span class="hljs-keyword">new</span> StringBuilder();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; res.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span> &amp;&amp; res[i] == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>            result.append(res[i]);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h3><h4 id="思路及算法"><a href="#思路及算法" class="headerlink" title="思路及算法"></a>思路及算法</h4><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210905162720329.png" alt="官方题解"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">multiply</span><span class="hljs-params">(String num1, String num2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (num1.equals(<span class="hljs-string">&quot;0&quot;</span>) || num2.equals(<span class="hljs-string">&quot;0&quot;</span>)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;0&quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> m = num1.length(), n = num2.length();<br>        <span class="hljs-keyword">int</span>[] ansArr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m + n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = m - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-keyword">int</span> x = num1.charAt(i) - <span class="hljs-string">&#x27;0&#x27;</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = n - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j--) &#123;<br>                <span class="hljs-keyword">int</span> y = num2.charAt(j) - <span class="hljs-string">&#x27;0&#x27;</span>;<br>                ansArr[i + j + <span class="hljs-number">1</span>] += x * y;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = m + n - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--) &#123;<br>            ansArr[i - <span class="hljs-number">1</span>] += ansArr[i] / <span class="hljs-number">10</span>;<br>            ansArr[i] %= <span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> index = ansArr[<span class="hljs-number">0</span>] == <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>        StringBuffer ans = <span class="hljs-keyword">new</span> StringBuffer();<br>        <span class="hljs-keyword">while</span> (index &lt; m + n) &#123;<br>            ans.append(ansArr[index]);<br>            index++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>又优于题解了，非常开心！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Leetcode Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Notes - 290</title>
    <link href="/2021/09/04/LeetCode-Notes-290/"/>
    <url>/2021/09/04/LeetCode-Notes-290/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-Notes-290"><a href="#Leetcode-Notes-290" class="headerlink" title="Leetcode Notes - 290"></a>Leetcode Notes - 290</h1><p>题目：<strong>单词记录</strong></p><p>难度：<strong>简单</strong></p><p>遇见次数：<strong>第二次</strong></p><p>涉及知识点：</p><ul><li>哈希表</li><li>双射</li></ul><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="1-哈希表"><a href="#1-哈希表" class="headerlink" title="1. 哈希表"></a>1. 哈希表</h3><p>哈希表 + 哈希集合记录📕</p><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210904124209478.png" alt="哈希表"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">wordPattern</span><span class="hljs-params">(String pattern, String s)</span> </span>&#123;<br>        Map&lt;String, Character&gt; mp = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        Set&lt;Character&gt; hs = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br><br>        <span class="hljs-keyword">char</span>[] ptArr = pattern.toCharArray();<br>        String[] sArr = s.split(<span class="hljs-string">&quot; &quot;</span>);<br><br>        <span class="hljs-keyword">if</span>(ptArr.length != sArr.length) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; ptArr.length; i++)&#123;<br>            <span class="hljs-keyword">if</span>(mp.containsKey(sArr[i]))&#123;<br>                <span class="hljs-keyword">if</span>(mp.get(sArr[i]) == ptArr[i])&#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">if</span>(hs.contains(ptArr[i]))&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span>&#123;<br>                    mp.put(sArr[i], ptArr[i]);<br>                    hs.add(ptArr[i]);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><h4 id="思路及算法"><a href="#思路及算法" class="headerlink" title="思路及算法"></a>思路及算法</h4><p>在本题中，我们需要判断字符与字符串之间是否恰好一一对应。即任意一个字符都对应着唯一的字符串，任意一个字符串也只被唯一的一个字符对应。在集合论中，这种关系被称为「双射」。</p><p>想要解决本题，我们可以利用哈希表记录每一个字符对应的字符串，以及每一个字符串对应的字符。然后我们枚举每一对字符与字符串的配对过程，不断更新哈希表，如果发生了冲突，则说明给定的输入不满足双射关系。</p><p>在实际代码中，我们枚举 pattern 中的每一个字符，利用双指针来均摊线性地找到该字符在 str 中对应的字符串。每次确定一个字符与字符串的组合，我们就检查是否出现冲突，最后我们再检查两字符串是否比较完毕即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">wordPattern</span><span class="hljs-params">(String pattern, String str)</span> </span>&#123;<br>        Map&lt;String, Character&gt; str2ch = <span class="hljs-keyword">new</span> HashMap&lt;String, Character&gt;();<br>        Map&lt;Character, String&gt; ch2str = <span class="hljs-keyword">new</span> HashMap&lt;Character, String&gt;();<br>        <span class="hljs-keyword">int</span> m = str.length();<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> p = <span class="hljs-number">0</span>; p &lt; pattern.length(); ++p) &#123;<br>            <span class="hljs-keyword">char</span> ch = pattern.charAt(p);<br>            <span class="hljs-keyword">if</span> (i &gt;= m) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">int</span> j = i;<br>            <span class="hljs-keyword">while</span> (j &lt; m &amp;&amp; str.charAt(j) != <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>                j++;<br>            &#125;<br>            String tmp = str.substring(i, j);<br>            <span class="hljs-keyword">if</span> (str2ch.containsKey(tmp) &amp;&amp; str2ch.get(tmp) != ch) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (ch2str.containsKey(ch) &amp;&amp; !tmp.equals(ch2str.get(ch))) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>            str2ch.put(tmp, ch);<br>            ch2str.put(ch, tmp);<br>            i = j + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> i &gt;= m;<br>    &#125;<br>&#125;<br><br>作者：LeetCode-Solution<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/word-pattern/solution/dan-ci-gui-lu-by-leetcode-solution-6vqv/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Notes - 763</title>
    <link href="/2021/09/04/LeetCode-Notes-763/"/>
    <url>/2021/09/04/LeetCode-Notes-763/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-Notes-763"><a href="#Leetcode-Notes-763" class="headerlink" title="Leetcode Notes - 763"></a>Leetcode Notes - 763</h1><p>题目：<strong>763. 划分字母区间</strong></p><p>难度：<strong>中等</strong></p><p>遇见次数：<strong>第二次</strong></p><p>涉及知识点：</p><ul><li>贪心</li></ul><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="1-哈希-贪心"><a href="#1-哈希-贪心" class="headerlink" title="1. 哈希 + 贪心"></a>1. 哈希 + 贪心</h3><p>思路在，就是贪心最关键的一点没到位——当前的片段的结束点绝对不小于当前遍历到的字符的最后出现的位置📕</p><p>为什么这样说？因为我们可以知道，当我们遍历到当前片段的最小结束点 end 时，end 必然是这个片段里所有出现过的字符里终点最大的！</p><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210904132641475.png" alt="哈希 + 贪心"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">partitionLabels</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        <span class="hljs-keyword">char</span>[] chArr = s.toCharArray();<br>        Map&lt;Character, Integer&gt; mpEnd = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; chArr.length; i++)&#123;<br>            mpEnd.put(chArr[i], i);<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> start = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> end = <span class="hljs-number">0</span>;<br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; chArr.length; j++)&#123;<br>            <span class="hljs-keyword">int</span> cur = mpEnd.get(chArr[j]);<br>            end = Math.max(end, cur);<br><br>            <span class="hljs-keyword">if</span>(j == end)&#123;<br>                res.add(end - start + <span class="hljs-number">1</span>);<br>                start = end + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h3><h4 id="思路及算法"><a href="#思路及算法" class="headerlink" title="思路及算法"></a>思路及算法</h4><p>使用贪心的思想寻找每个片段可能的最小结束下标，因此可以保证每个片段的长度一定是符合要求的最短长度，如果取更短的片段，则一定会出现同一个字母出现在多个片段中的情况。由于每次取的片段都是符合要求的最短的片段，因此得到的片段数也是最多的。</p><p>由于每个片段访问结束的标志是访问到下标 end，因此对于每个片段，可以保证当前片段中的每个字母都一定在当前片段中，不可能出现在其他片段，可以保证同一个字母只会出现在同一个片段。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">partitionLabels</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[] last = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">26</span>];<br>        <span class="hljs-keyword">int</span> length = s.length();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>            last[s.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>] = i;<br>        &#125;<br>        List&lt;Integer&gt; partition = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>        <span class="hljs-keyword">int</span> start = <span class="hljs-number">0</span>, end = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>            end = Math.max(end, last[s.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>]);<br>            <span class="hljs-keyword">if</span> (i == end) &#123;<br>                partition.add(end - start + <span class="hljs-number">1</span>);<br>                start = end + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> partition;<br>    &#125;<br>&#125;<br><br>作者：LeetCode-Solution<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/partition-labels/solution/hua-fen-zi-mu-qu-jian-by-leetcode-solution/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Big Data Intro - Chapter 6</title>
    <link href="/2021/09/04/Big-Data-Intro-Chapter-6/"/>
    <url>/2021/09/04/Big-Data-Intro-Chapter-6/</url>
    
    <content type="html"><![CDATA[<h1 id="第06章-Spark基于内存的分布式计算"><a href="#第06章-Spark基于内存的分布式计算" class="headerlink" title="第06章 Spark基于内存的分布式计算"></a>第06章 Spark基于内存的分布式计算</h1><h2 id="Part-1-Spark-概述"><a href="#Part-1-Spark-概述" class="headerlink" title="Part 1 Spark 概述"></a>Part 1 Spark 概述</h2><h3 id="Spark-简介"><a href="#Spark-简介" class="headerlink" title="Spark 简介"></a>Spark 简介</h3><p><strong>Apache Spark</strong> 是一种基于<strong>内存的快速、通用、可扩展的</strong>大数据计算引擎。</p><p>同时，<strong>Spark</strong> 是一站式解决方案，集批处理、实时流处理、交互式查询、图计算与机器学习于一体。</p><h3 id="Spark-应用场景"><a href="#Spark-应用场景" class="headerlink" title="Spark 应用场景"></a>Spark 应用场景</h3><ul><li><strong>批处理</strong>可用于 <strong>ETL（抽取、转换、加载）</strong></li><li><strong>机器学习</strong>可用于自动判断电商的买家评论是好评还是差评</li><li><strong>交互式分析</strong>可用于查询 Hive 数据仓库</li><li><strong>流处理</strong>可用于页面点击流分析，推荐系统，舆情分析等实时业务<ul><li>舆情分析：就是对互联网敏感、热点信息进行监控、分析处理</li></ul></li></ul><blockquote><p>需要反复操作的次数越多，所需读取的数据量越大，受益越大，因为数据已经在内存了</p></blockquote><h3 id="Spark-特点"><a href="#Spark-特点" class="headerlink" title="Spark 特点"></a>Spark 特点</h3><p><strong>Spark</strong> 用十分之一的资源，便可获得 3 倍于 <strong>MapReduce</strong> 的性能</p><h4 id="轻"><a href="#轻" class="headerlink" title="轻"></a>轻</h4><p><strong>Spark 核心代码只有 3 万行</strong></p><ul><li>Scala 语言的简洁和丰富表达力</li><li>巧妙利用了 Hadoop 和 Mesos 的基础设施</li></ul><h4 id="快"><a href="#快" class="headerlink" title="快"></a>快</h4><p><strong>Spark 对小数据集可达到亚秒级的延迟</strong></p><ul><li>对大数据集的迭代机器学习即席查询、图计算等应用，<strong>Spark</strong> 版本比基于 <strong>MapReduce、Hive 和 Pregel</strong> 的实现快</li><li>内存计算、数据本地性和传输优化、调度优化</li></ul><h4 id="灵"><a href="#灵" class="headerlink" title="灵"></a>灵</h4><p><strong>Spark 提供了不同层面的灵活性</strong></p><ul><li>Scala 语言 trait 动态混入策略（如可更换的集群调度器、序列化库）</li><li>允许扩展新的数据算子、新的数据源、新的 <strong>language bindings</strong></li><li><strong>Spark</strong> 支持内存计算、多迭代批量处理、即席查询、流处理和图计算等多种范式</li></ul><h4 id="巧"><a href="#巧" class="headerlink" title="巧"></a>巧</h4><p><strong>巧妙借力现有大数据组件</strong></p><ul><li><strong>Spark</strong> 借 <strong>Hadoop</strong> 之势，与 <strong>Hadoop</strong> 无缝结合</li><li>图计算借用 <strong>Pregel 和 PowerGraph</strong> 的 API 以及 PowerGraph 的点分割思想</li></ul><h2 id="Part-2-Spark-数据结构"><a href="#Part-2-Spark-数据结构" class="headerlink" title="Part 2 Spark 数据结构"></a>Part 2 Spark 数据结构</h2><h3 id="Spark-核心概念-RDD"><a href="#Spark-核心概念-RDD" class="headerlink" title="Spark 核心概念 RDD"></a>Spark 核心概念 RDD</h3><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210904104454432.png" alt="RDD 在 Spark 中的角色"></p><p><strong>RDD（Resilient Distributed Datasets）</strong> 即<strong>弹性分布式数据集</strong>，是一个<strong>只读的，可分区的</strong>分布式数据集</p><ul><li>RDD 默认存储在<strong>内存</strong>，当内存不足时，溢写到磁盘</li><li>RDD 数据以<strong>分区的形式</strong>在集群中存储</li><li>RDD 具有<strong>血统机制（Lineage）</strong>，发生数据丢失时，可快速进行数据恢复</li></ul><p>可以说，<strong>RDD</strong> 是 <strong>Spark</strong> 对基础数据的抽象</p><ul><li><strong>RDD 的生成：</strong><ul><li>从 Hadoop 文件系统（或与 Hadoop 兼容的其它存储系统）输入创建（如 HDFS）</li><li>从父RDD转换得到新的RDD</li></ul></li><li><strong>RDD 的存储：</strong><ul><li>用户可以选择不同的存储级别存储 RDD 以便重用（11种）</li><li>RDD 默认存储于内存，但当内存不足时，RDD会溢出到磁盘中</li></ul></li><li><strong>RDD 的分区：</strong><ul><li>为减少网络传输代价，和进行分布式计算，需对RDD进行分区</li><li>在需要进行分区时会根据每条记录 Key 进行分区，以此保证两个数据集能高效进行 Join 操作</li></ul></li><li><strong>RDD 的优点：</strong><ul><li>RDD是只读的，静态的。因此可提供更高的容错能力</li><li>可以实现推测式执行</li></ul></li></ul><h3 id="RDD-的依赖关系"><a href="#RDD-的依赖关系" class="headerlink" title="RDD 的依赖关系"></a>RDD 的依赖关系</h3><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210904104551904.png" alt="ND 和 WD"></p><h4 id="Dependency（依赖）"><a href="#Dependency（依赖）" class="headerlink" title="Dependency（依赖）"></a>Dependency（依赖）</h4><ul><li>窄依赖是指父 RDD 的<strong>每个分区最多被一个</strong>子 RDD 的一个<strong>分区（即 Partition）</strong>所用</li><li>宽依赖是指父 RDD 的<strong>每个分区对应一个</strong>子 RDD 的多个分区，是 stage 划分的依据</li></ul><h4 id="Lineage（血统）：依赖的链条"><a href="#Lineage（血统）：依赖的链条" class="headerlink" title="Lineage（血统）：依赖的链条"></a>Lineage（血统）：依赖的链条</h4><ul><li>RDD 数据集通过 <strong>Lineage</strong> 记住了它是如何从其他 RDD 中演变过来的</li></ul><h3 id="宽窄依赖的区别"><a href="#宽窄依赖的区别" class="headerlink" title="宽窄依赖的区别"></a>宽窄依赖的区别</h3><h4 id="算子"><a href="#算子" class="headerlink" title="算子"></a>算子</h4><p><strong>窄依赖</strong>指的是每一个父 RDD 的 Partition 最多被子 RDD 的一个 Partition 使用</p><ul><li>如 <code>map</code>、<code>filter</code>，<code>union</code></li></ul><p><strong>宽依赖</strong>指的是多个子 RDD 的 Partition 会依赖同一个父 RDD 的 Partition</p><ul><li>如 <code>groupByKey</code>，<code>reduceByKey</code>，<code>sortByKey</code></li></ul><h4 id="容错性"><a href="#容错性" class="headerlink" title="容错性"></a>容错性</h4><p>假设某个节点出现了故障</p><ul><li>窄依赖：只需要重算与<strong>子 RDD 分区对应的父 RDD 分区</strong>即可</li><li>宽依赖：极端情况下，<strong>所有的父 RDD 分区都要重新计算</strong></li></ul><p>如下图所示，b1 分区丢失，则需要重新计算 a1, a2 和 a3</p><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210904105710231.png" alt="宽依赖故障情况"></p><h4 id="传输"><a href="#传输" class="headerlink" title="传输"></a>传输</h4><p>宽依赖往往对应着 <strong>Shuffle</strong> 操作，需要在运行过程中将同一个父 RDD 的分区传入到不同的子 RDD 分区中，中间可能涉及多个节点之间的数据传输。</p><p>窄依赖的每个父 RDD 的分区只会传入到一个子 RDD 分区中，通常可以在一个节点内完成转换。</p><h3 id="RDD-的-Stage-划分"><a href="#RDD-的-Stage-划分" class="headerlink" title="RDD 的 Stage 划分"></a>RDD 的 Stage 划分</h3><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210904110026807.png" alt="RDD 的 Stage 划分"></p><p>实际应用提交的 Job 中 RDD 依赖关系是十分复杂的，依据这些依赖关系来划分 stage 自然 是十分困难的，Spark 此时就利用了前文提到的依赖关系</p><ul><li>调度器从 DAG 图末端出发，逆向遍历整个依赖关系链</li><li>遇到 <strong>ShuffleDependency（宽依赖关系的一种叫法）</strong>就断开</li><li>遇到 <strong>NarrowDependency</strong> 就将其加入到当前 stage</li></ul><p>stage 中task 数目由 stage 末端的 RDD分区个数来决定，RDD 转换是基于分区的一种<strong>粗粒度计算</strong>，一个 stage 执行的结果就是这几个分区构成的 RDD</p><h3 id="RDD-操作类型"><a href="#RDD-操作类型" class="headerlink" title="RDD 操作类型"></a>RDD 操作类型</h3><p><strong>Spark</strong> 中的操作大致可以分为创建操作、转换操作、控制操作和行为操作</p><ul><li><strong>创建操作（Creation Operation）：</strong>用于 RDD 创建工作。RDD 创建只有两种方法<ul><li>一种是来自于内存集合和外部存储系统</li><li>另一种是通过转换操作生成的 RDD</li></ul></li><li><strong>转换操作（Transformation Operation）：</strong>将 RDD 通过一定的操作转变成新的 RDD，RDD 的转换操作是<strong>惰性操作</strong>，他只是定义了一个新的 RDD，并没有立即执行</li><li><strong>控制操作（Control Operation）：</strong>进行 RDD 持久化，可以让 RDD 按不同的存储策略保存在磁盘或者内存中，比如 cache 接口默认将 RDD 缓存在内存中</li><li><strong>行动操作（Action Operation）：</strong>能够出发 <strong>Spark</strong> 运行的操作，其分为两类——<ul><li>一类操作输出计算结果</li><li>另一类将 RDD 保存到外部文件系统或者数据库中</li></ul></li></ul><p>下面详细介绍这四类操作</p><h4 id="创建操作"><a href="#创建操作" class="headerlink" title="创建操作"></a>创建操作</h4><p>目前有两张类型的基础 RDD：</p><ul><li>并行集合：接受一个已经存在的集合，然后进行并行计算</li><li>外部存储：在一个文件的每条记录上运行函数<ul><li>只要文件系统是 HDFS，或者 Hadoop 支持的任意存储系统即可</li></ul></li></ul><p>这两种类型的 RDD 都可以通过相同的方式进行操作，从而获得子 RDD 等一系列拓展，形成血统关系图。</p><h4 id="控制操作"><a href="#控制操作" class="headerlink" title="控制操作"></a>控制操作</h4><p>Spark 可以将 RDD <strong>持久化</strong>到内存或磁盘文件系统中，把 RDD 持久化到内存中<strong>可以极大地提高迭代计算以及个计算模型之间的数据共享</strong>。</p><p>一般情况下执行节点 60% 内存用于缓存数据，剩下的 40% 用于运行任务。</p><p>Spark 中使用 persist 和 cache 操作进行持久化，其中 cache 是 persist() 的特例。</p><h4 id="转换操作-Transformation-算子"><a href="#转换操作-Transformation-算子" class="headerlink" title="转换操作 - Transformation 算子"></a>转换操作 - Transformation 算子</h4><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210904111602403.png" alt="Transformation 算子"></p><h4 id="行动操作-Action-算子"><a href="#行动操作-Action-算子" class="headerlink" title="行动操作 - Action 算子"></a>行动操作 - Action 算子</h4><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210904111625270.png" alt="Action 算子"></p><h3 id="DataFrame-概念"><a href="#DataFrame-概念" class="headerlink" title="DataFrame 概念"></a>DataFrame 概念</h3><p>与 RDD 类似，<strong>DataFrame</strong> 也是一个<strong>不可变弹性分布式数据集</strong>。除了数据以外，还记录数据的<strong>结构信息</strong>，即 <strong>Schema</strong>，类似二维表格</p><p><strong>DataFrame</strong> 的查询计划可以通过 <strong>Spark Catalyst Optimiser</strong> 进行优化，即使 Spark 经验并不丰富，用 <strong>DataFrame</strong> 写的程序也可以尽量被转化为<strong>高效的形式</strong>予以执行</p><blockquote><p><strong>Catalyst工作流程：</strong></p><ul><li>SQL 语句首先通过 Parser 模块被解析为语法树，此棵树称为 Unresolved Logical Plan</li><li>Unresolved Logical Plan 通过 Analyzer 模块借助于数据元数据解析为 Logical Plan</li><li>此时再通过各种基于规则的优化策略进行深入优化，得到 Optimized Logical Plan</li><li>优化后的逻辑执行计划依然是逻辑的，并不能被 Spark 系统理解，此时需要将此逻辑执行计划转换为Physical Plan</li></ul></blockquote><h3 id="DataSet-概念"><a href="#DataSet-概念" class="headerlink" title="DataSet 概念"></a>DataSet 概念</h3><p><strong>DataFrame</strong> 是 <strong>DataSet</strong> 的特例，**DataFrame = DataSet[Row]**，所以可以通过 <code>as</code> 方法将 DataFrame 转换为 DataSet。</p><p><strong>Row</strong> 是一个通用的类型，所有的表结构信息都用 Row 来表示。</p><p><strong>DataSet</strong> 是强类型的，可以有 <strong>DataSet[Car]，DataSet[Person]</strong></p><h3 id="DataFrame、DataSet、RDD-表现形式的区别"><a href="#DataFrame、DataSet、RDD-表现形式的区别" class="headerlink" title="DataFrame、DataSet、RDD 表现形式的区别"></a>DataFrame、DataSet、RDD 表现形式的区别</h3><p>假设 RDD 中的两行数据长这样</p><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210904112524752.png" alt="RDD 示例"></p><p>那么在 DataFrame 中的数据长这样</p><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210904112559381.png" alt="DataFrame 示例"></p><p>那么 DataSet 中的数据长这样</p><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210904112647391.png" alt="DataSet 示例"></p><p>由上可见——</p><h4 id="DataFrame-与-DataSet-的区别"><a href="#DataFrame-与-DataSet-的区别" class="headerlink" title="DataFrame 与 DataSet 的区别"></a>DataFrame 与 DataSet 的区别</h4><ul><li><strong>DataFrame</strong><ul><li>DataFrame 每一行的类型固定为 Row，只有通过解析才能获取各个字段的值， 每一列的值没法直接访问</li><li>DataFrame 编译器缺少类型安全检查</li></ul></li><li><strong>DataSet</strong><ul><li>每一行是什么类型是不一定的，可以是 Person，也可以是 Row</li><li>DataSet 类型安全</li></ul></li></ul><h4 id="RDD-与-DataFrame-DataSet的区别"><a href="#RDD-与-DataFrame-DataSet的区别" class="headerlink" title="RDD 与 DataFrame / DataSet的区别"></a>RDD 与 DataFrame / DataSet的区别</h4><ul><li><strong>RDD</strong><ul><li>用于 Spark1.X 各模块的 API</li><li>不支持 SparkSQL 操作</li><li>不支持代码自动优化</li></ul></li><li><strong>DataFrame 与 DataSet</strong><ul><li>用于 Spark2.X 各模块的 API</li><li>支持 SparkSQL 操作，还能注册临时表，进行 SQL 语句操作</li><li>支持一些方便的保存方式，比如保存成 csv，json 等格式</li><li>基于 SparkSQL 引擎构建，支持代码自动优化</li></ul></li></ul><h4 id="RDD-与-DataFrame、DataSet-三者的共性"><a href="#RDD-与-DataFrame、DataSet-三者的共性" class="headerlink" title="RDD 与 DataFrame、DataSet 三者的共性"></a>RDD 与 DataFrame、DataSet 三者的共性</h4><ul><li>三者都是<strong>分布式弹性数据集</strong>，支持相互转化</li><li>三者有<strong>许多共同的函数</strong>，如 filter，排序等</li><li>三者<strong>都是 Lazy（惰性操作） 的</strong>，在进行创建、转换时，不会立即执行<ul><li>只有在遇到 Action 算子时，才会开始遍历运算</li></ul></li></ul><h2 id="Part-3-Spark-原理与架构"><a href="#Part-3-Spark-原理与架构" class="headerlink" title="Part 3 Spark 原理与架构"></a>Part 3 Spark 原理与架构</h2><h3 id="Spark-体系架构"><a href="#Spark-体系架构" class="headerlink" title="Spark 体系架构"></a>Spark 体系架构</h3><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210904113924087.png" alt="Spark 体系架构"></p><h4 id="Spark-Core"><a href="#Spark-Core" class="headerlink" title="Spark Core"></a>Spark Core</h4><p>类似于 MapReduce 的分布式内存计算框架，最大的特点是<strong>将中间计算结果直接放在内存中</strong>，提升计算性能。</p><p>自带了 Standalone 模式的资源管理框架，同时，也支持YARN、 MESOS的资源管理系统。</p><p>FI 集成的是 Spark On Yarn 的模式，其它模式暂不支持。</p><h4 id="SparkSQL"><a href="#SparkSQL" class="headerlink" title="SparkSQL"></a>SparkSQL</h4><p>Spark SQL 是一个用于处理结构化数据的 Spark 组件，作为 Apache  Spark 大数据框架的一部分，主要用于<strong>结构化数据处理和对数据执行类SQL查询</strong>。</p><p>通过 Spark SQL，可以针对不同数据格式（如：JSON，Parquet， ORC等）和数据源执行 ETL操作（如：HDFS、数据库等），完成特定的查询操作。</p><h4 id="Spark-Streaming"><a href="#Spark-Streaming" class="headerlink" title="Spark Streaming"></a>Spark Streaming</h4><p>微批处理的流处理引擎，将流数据分片以后用 Spark Core 的计算引擎 中进行处理。相对于Storm，实时性稍差，优势<strong>体现在吞吐量上</strong></p><h4 id="MLlib-和-GraphX"><a href="#MLlib-和-GraphX" class="headerlink" title="MLlib 和 GraphX"></a>MLlib 和 GraphX</h4><p>主要一些算法库（机器学习算法库和图计算算法库）</p><h4 id="Structured-Streaming"><a href="#Structured-Streaming" class="headerlink" title="Structured Streaming"></a>Structured Streaming</h4><p>为 2.0 版本之后的 Spark 独有，吸收了一些 Flink 的特性和功能</p><h3 id="典型案例-WordCount"><a href="#典型案例-WordCount" class="headerlink" title="典型案例 - WordCount"></a>典型案例 - WordCount</h3><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210904114425809.png" alt="WordCount案例"></p><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210904114503856.png" alt="Scala核心代码"></p><h3 id="Spark-SQL-概述"><a href="#Spark-SQL-概述" class="headerlink" title="Spark SQL 概述"></a>Spark SQL 概述</h3><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210904114704510.png" alt="Spark SQL"></p><p><strong>Spark SQL</strong> 是 <strong>Spark</strong> 中用于<strong>结构化数据处理的模块</strong>。在 <strong>Spark</strong> 应用中，可以无缝地使用 SQL 语句亦或是 <strong>DataFrame API</strong> 对结构化数据进行查询。</p><p>Spark SQL 对 SQL 语句的处理和关系型数据库采用了类似的方法，SparkSQL 先会将 SQL 语句进行解析（Parse）形成一个 Tree， 然后使用 Rule 对 Tree 进行绑定、 优化等处理过程</p><ul><li><strong>词法和语法解析（Parse）</strong><ul><li>对读入的 SQL 语句进行词法和语法解析（Parse），分辨出 SQL 语句中那些词是关键词（如 SELECT、FROM、WHERE），哪些是表达式，哪些是 Projection，哪些是 Data Source 等，判断 SQL 语句是否规范，并形成逻辑计划</li></ul></li><li><strong>绑定（Bind）</strong><ul><li>将SQL语句和数据库的数据字典（列、 表和视图等）进行绑定(Bind)，如果相关的 Projection 和 Data Source 等都存在的话，则表示这个 SQL 语句是可以执行的</li></ul></li><li><strong>优化（Optimize）</strong><ul><li>Spark SQL 会提供几个执行计划，返回从数据库查询的数据集</li></ul></li><li><strong>执行（Execute）</strong><ul><li>执行前面步骤获取的最优执行计划，返回从数据库查询的数据集</li></ul></li></ul><h3 id="Spark-SQL-和-Hive-对比"><a href="#Spark-SQL-和-Hive-对比" class="headerlink" title="Spark SQL 和 Hive 对比"></a>Spark SQL 和 Hive 对比</h3><p>两者区别在于——</p><ul><li><strong>Spark SQL</strong> 的执行引擎为 <strong>Spark Core</strong>，<strong>Hive</strong> 默认执行引擎是 <strong>MapReduce</strong></li><li><strong>Spark SQL</strong> 的执行速度是 <strong>Hive</strong> 的 10 - 100 倍</li><li><strong>Spark SQL</strong> 不支持 <strong>buckets，Hive</strong> 支持</li></ul><p>两者的联系在于——</p><ul><li><strong>Spark SQL</strong> 依赖 <strong>Hive</strong> 的元数据</li><li><strong>Spark SQL</strong> 兼容绝大部分 <strong>Hive</strong> 的语法和函数</li><li><strong>Spark SQL</strong> 可以使用 <strong>Hive</strong> 的自定义函数</li></ul><p><strong>Spark SQL</strong> 和 <strong>Hive</strong> 的语法除了<strong>桶表操作外</strong>，基本一致，且 <strong>Spark SQL</strong> 完美兼容 <strong>Hive</strong> 的函数。</p><h3 id="Structured-Streaming-概述"><a href="#Structured-Streaming-概述" class="headerlink" title="Structured Streaming 概述"></a>Structured Streaming 概述</h3><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210904120551029.png" alt="Structured Streaming 概述"></p><p><strong>Structured Streaming</strong> 是构建在 <strong>Spark SQL</strong> 引擎上的流式数据处理引擎，可以像使用静态 RDD 数据那样编写流式计算过程。</p><p>当流数据连续不断的产生时，<strong>Spark SQL</strong> 将会<strong>增量地、持续不断地处理</strong>这些数据，并将结果更新到结果集中。</p><p><strong>Structured Streaming</strong> 的核心是<strong>将流式的数据看成一张数据不断增加的数据库表</strong></p><ul><li>这种流式的数据处理模型类似于数据块处理模型，可以把静态数据库表的一些查询操作应用在流式计算中，Spark 执行标准的 SQL 查询，从无边界表中获取数据</li><li>无边界表：新数据不断到来，旧数据不断丢弃，实际上是一个连续不断的结构化数据流</li></ul><h4 id="计算模型示例"><a href="#计算模型示例" class="headerlink" title="计算模型示例"></a>计算模型示例</h4><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210904120848499.png" alt="Structured Streaming 计算模型示例"></p><ul><li>第一个 lines DataFrame 对象是一张数据输入的 Input Table，最后的 WordCounts  DataFrame 是一个结果集 Result Table</li><li>在 lines DataFrame 数据流之上的查询产生了 WordCounts 的表示方式和在静态的 Static DataFrame 上的使用方式相同。</li><li>然而， Spark 会监控 socket 连接，获取新的持续不断产生的数据。</li><li>当新的数据产生时，Spark 将会在新数据上运行一个增量的 counts 查询，并且整合新的 counts 和之前已经计算出来的 counts，获取更新后的 counts</li></ul><h3 id="Spark-Streaming-概述"><a href="#Spark-Streaming-概述" class="headerlink" title="Spark Streaming 概述"></a>Spark Streaming 概述</h3><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210904121518306.png" alt="Spark Streaming 概述"></p><p><strong>Spark Sreaming</strong> 的基本原理是<strong>将实时输入数据流以时间片（秒级）为单位</strong>进行拆分，然后经 <strong>Spark</strong> 引擎以类似批处理的方式处理每个时间片数据。</p><ul><li>把输入数据以秒（毫秒）为单位切分，再定时提交这些切分后的数据</li></ul><h3 id="窗口间隔和滑动间隔"><a href="#窗口间隔和滑动间隔" class="headerlink" title="窗口间隔和滑动间隔"></a>窗口间隔和滑动间隔</h3><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210904121626600.png" alt="窗口间隔和滑动间隔"></p><p>窗口在 DStream 上华东，合并和操作落入窗口内的 RDDs，产生窗口化的 RDDs</p><ul><li><strong>窗口长度：</strong>窗口的持续时间</li><li><strong>滑动窗口间隔：</strong>窗口操作执行的时间间隔</li></ul><h3 id="Spark-Streaming-和-Storm-对比"><a href="#Spark-Streaming-和-Storm-对比" class="headerlink" title="Spark Streaming 和 Storm 对比"></a>Spark Streaming 和 Storm 对比</h3><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210904121755263.png" alt="Spark Streaming 和 Storm 对比"></p><p>事实上，Spark Streaming 绝对谈不上比 Storm 优秀。这两个框架在实时计算领域中，都很优秀，只是擅长的细分场景并不相同。Spark Streaming <strong>仅仅在吞吐量上</strong>比 Storm 要优秀。</p><h4 id="对于-Storm-来说"><a href="#对于-Storm-来说" class="headerlink" title="对于 Storm 来说"></a>对于 Storm 来说</h4><ul><li>建议在那种需要纯实时，不能忍受1秒以上延迟的场景下使用，比如实时金融系统， 要求纯实时进行金融交易和分析</li><li>如果对于实时计算的功能中，<strong>要求可靠的事务机制和可靠性机制</strong>，即<strong>数据的处理完全精准</strong>，一条也不能多，一条也不能少，也可以考虑使用 Storm</li><li>如果还需要针对高峰低峰时间段，<strong>动态调整实时计算程序的并行度</strong>，以最大限度利用集群资源（通常是在小型公司，集群资源紧张的情况），也可以考虑用 Storm</li><li>如果一个大数据应用系统，它就是<strong>纯粹的实时计算</strong>，不需要在中间执行 SQL 交互式 查询、复杂的 Transformation 算子等，那么用 Storm 是比较好的选择</li></ul><h4 id="对于Spark-Streaming来说"><a href="#对于Spark-Streaming来说" class="headerlink" title="对于Spark Streaming来说"></a>对于Spark Streaming来说</h4><ul><li>如果对上述适用于 Storm 的三点，一条都不满足的实时场景，即不要求纯实时，不要求强大可靠的事务机制，不要求动态调整并行度，那么可以考虑使用 Spark  Streaming</li><li>位于 Spark 生态技术栈中，因此 Spark Streaming 可以和 Spark Core、Spark  SQL 无缝整合，也就意味着，我们可以对实时处理出来的中间数据，立即在程序中无缝进行延迟批处理、交互式查询等操作。这个特点大大增强了 Spark Streaming 的优势和功能</li></ul>]]></content>
    
    
    <categories>
      
      <category>Big Data Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Big Data Intro - Chapter 5</title>
    <link href="/2021/09/03/Big-Data-Intro-Chapter-5/"/>
    <url>/2021/09/03/Big-Data-Intro-Chapter-5/</url>
    
    <content type="html"><![CDATA[<h1 id="第05章-MapReduce和Yarn技术原理"><a href="#第05章-MapReduce和Yarn技术原理" class="headerlink" title="第05章 MapReduce和Yarn技术原理"></a>第05章 MapReduce和Yarn技术原理</h1><h2 id="Part-1-MapReduce-和-YARN-基本介绍"><a href="#Part-1-MapReduce-和-YARN-基本介绍" class="headerlink" title="Part 1 MapReduce 和 YARN 基本介绍"></a>Part 1 MapReduce 和 YARN 基本介绍</h2><h3 id="MapReduce-概述"><a href="#MapReduce-概述" class="headerlink" title="MapReduce 概述"></a>MapReduce 概述</h3><p><strong>MR</strong> 用于大规模数据集（大于1TB）的并行计算和离线计算，具有如下特点：</p><ul><li>高度抽象的编程思想：程序员仅需描述做什么，具体怎么做交由系统的执行框架处理</li><li>良好的扩展性：可通过添加节点以线性扩展集群能力</li><li>高容错性：通过计算迁移或数据迁移等策略提高集群的可用性与容错性</li></ul><p>简而言之，三个作用——</p><ul><li><strong>MapReduce</strong> 是一个<strong>基于集群的高性能并行计算平台</strong></li><li><strong>MapReduce</strong> 是一个<strong>并行计算与运行软件框架</strong></li><li><strong>MapReduce</strong> 是一个<strong>并行程序设计模型与方法</strong></li></ul><h3 id="资源调度与分配"><a href="#资源调度与分配" class="headerlink" title="资源调度与分配"></a>资源调度与分配</h3><p>随着大数据分析的蓬勃发展，就需要更加多样性的分布式编程范式，比如实时数据处理、内存计算、图计算等等。</p><p>编程范式的多样化对运行时环境提出了更大的挑战，即运行时环境需要更通用，以支持不同的编程模型，而不是像 <strong>mapreduce</strong> 框架那样只支持 <strong>mapreduce</strong> 这种编程范式。</p><p>不同的编程范式，或者说不同的计算任务，对资源（如CPU、内存）的需求是不同的，因此需要优秀的调度策略，在满足应用的特殊需求的情况下，最大化利用资源，同时也需要做好任务之间的隔离，避免相互影响。</p><p><strong>MRv1</strong> 中存在着不足——</p><ol><li>单点 master 故障的不可靠问题（依赖于周期性 checkpoint）</li><li>没有区分<strong>作业调度和资源调度</strong></li><li>没有提到<strong>资源隔离与安全性</strong></li></ol><h3 id="YARN-概述"><a href="#YARN-概述" class="headerlink" title="YARN 概述"></a>YARN 概述</h3><p><strong>YARN（Yet Another Resource Negotiator）</strong> 是一个<strong>通用资源管理系统</strong>，可为上层应用提供统一的资源管理和调度。</p><p>并且优于 <strong>Yarn</strong> 是轻量级弹性计算平台，除了 MapReduce 框架，还可以支持其他框架，比如 Spark、 Storm 等。多种框架统一管理，共享集群资源：</p><ul><li>资源利用率高</li><li>运维成本低</li><li>数据共享方便</li></ul><h2 id="Part-2-MapReduce-和-YARN-功能与架构"><a href="#Part-2-MapReduce-和-YARN-功能与架构" class="headerlink" title="Part 2 MapReduce 和 YARN 功能与架构"></a>Part 2 MapReduce 和 YARN 功能与架构</h2><h3 id="MapReduce-过程"><a href="#MapReduce-过程" class="headerlink" title="MapReduce 过程"></a>MapReduce 过程</h3><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210903112315362.png" alt="MapReduce工作流程"></p><p><strong>MapReduce</strong> 计算过程可具体分为两个阶段，<strong>Map</strong> 阶段和 <strong>Reduce</strong> 阶段，其中 <strong>Map</strong> 阶段输出的结果就是 <strong>Reduce</strong> 阶段的输入——</p><ul><li><strong>Map</strong> 阶段面对的是杂乱无章的互不相关的数据，它解析每个数据，从中提取出 <strong>key 和 Value</strong>，也就是提取了<strong>数据的特征</strong></li><li><strong>Reduce</strong> 阶段数据是以 <strong>key</strong> 后面跟着若干个 <strong>value</strong> 来组织的，这些 <strong>value</strong> 具有 <strong>相关性</strong>。在此基础上我们可以做进一步的处理以便得到结果</li></ul><p>同时，<strong>MapReduce</strong> 工作流程也具有一定的特点——</p><ul><li>不同的 <strong>Map</strong> 任务之间<strong>不会进行通信</strong></li><li>不同的 <strong>Reduce</strong> 任务之间也<strong>不会发生任何信息交换</strong></li><li>用户<strong>不能显式地</strong>从一台机器向另一台机器发送消息</li><li><strong>所有的数据交换</strong>都是通过 <strong>MapReduce</strong> 框架<strong>自身</strong>去实现的</li></ul><h4 id="Map-阶段详解"><a href="#Map-阶段详解" class="headerlink" title="Map 阶段详解"></a>Map 阶段详解</h4><p><strong>Job</strong> 提交前，先将待处理的文件进行<strong>分片（Split）</strong>，<strong>MR</strong> 框架默认将一个<strong>块（Block）</strong>作为一个分片。客户端应用可以重新定义<strong>块与分片的映射关系</strong></p><p><strong>Map</strong> 阶段先把数据放入一个环形内存缓冲区，当缓冲区数据达到 80% 左右时发生<strong>溢写（Spill）</strong>，需将缓冲区中的数据写入到本地磁盘，生成 <strong>MapOutFile（MOF）</strong></p><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210903113350466.png" alt="Map 阶段"></p><p><strong>写入本地磁盘之前</strong>通常需要做如下处理</p><ul><li><strong>分区 (Partition)：</strong>默认采用 <strong>Hash 算法</strong>进行分区，<strong>MR</strong> 框架根据 <strong>Reduce Task</strong> 个数来确定分区个数。具备相同 <strong>Key</strong> 值的记录最终被送到相同的 <strong>Reduce Task</strong> 来处理</li><li><strong>排序 (Sort)：</strong>将Map输出的记录排序<ul><li>例如将 (‘Hi’，’1’)，(‘Hello’，’1’) 重新排序为 (‘Hello’，’1’)，(’Hi’，’1’)</li></ul></li><li><strong>组合 (Combine)：</strong>这个动作MR框架默认是可选的<ul><li>例如将 (’Hi’，’1’)，(’Hi’，’1’)，(‘Hello’，’1’)，(Hello’，’1’)进行合并操作为 (’Hi’，’2’)，(‘Hello’，’2’)</li></ul></li><li><strong>合并 (Spill)：</strong> <strong>Map Task</strong> 在处理后会产生很多的<strong>溢出文件（spill file）</strong>，这时需将多个溢出文件进行合并处理，生成一个经过<strong>分区和排序的Spill File (MOF:MapOutFile)</strong><ul><li>为减少写入磁盘的数据量，MR 支持对 MOF 进行压缩后再写入</li></ul></li></ul><p><strong>合并（Combine）和归并（Merge）</strong>的区别，在于对两个键值对 &lt;“a”，1&gt; 和 &lt;“a”，1&gt; 来说：</p><ul><li>如果合并，会得到&lt;“a”，2&gt;</li><li>如果归并，会得到 &lt;“a”，&lt;1，1&gt;&gt;</li></ul><h4 id="Reduce-阶段详解"><a href="#Reduce-阶段详解" class="headerlink" title="Reduce 阶段详解"></a>Reduce 阶段详解</h4><p>在 <strong>Map</strong> 阶段我们提到 <strong>MOF</strong> 文件是经过排序处理的。当 <strong>Reduce Task</strong> 接受的数据量不大时，则直接存放在<strong>内存缓冲区</strong>中。</p><p>随着缓冲区文件的增多，<strong>MR</strong> 后台线程将他们合并成一个更大的有序文件，这便是 <strong>Reduce</strong> 阶段的 <strong>Merge</strong> 操作，过程中会产生许多中间文件，最后一次合并的结果直接输出到用户自定义的 <strong>Reduce</strong> 函数</p><p>当数据很少时，不需要溢写到磁盘，直接<strong>在缓存中归并</strong>，然后输出给<strong>Reduce</strong></p><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210903114440651.png" alt="Reduce 阶段"></p><p>通常在 <strong>Map Task</strong> 任务完成 <strong>MOF</strong> 输出进度到 3% 时启动 <strong>Reduce</strong>，从各个 <strong>Map Task</strong> 获取<strong>MOF</strong> 文件。前面提到 <strong>Reduce Task</strong> 个数由客户端决定，<strong>Reduce Task</strong> 个数决定 <strong>MOF</strong> 文件分区数。 因此 <strong>Map Task</strong> 输出的 <strong>MOF</strong> 文件都能找到相对应的 <strong>Reduce Task</strong>来处理</p><h3 id="Shuffle-过程"><a href="#Shuffle-过程" class="headerlink" title="Shuffle 过程"></a>Shuffle 过程</h3><p><strong>Shuffle</strong> 的定义：<strong>Map</strong> 阶段和 <strong>Reduce</strong> 阶段之间<strong>传递中间数据</strong>，包括 <strong>Reduce Task</strong> 从各个 <strong>Map Task</strong> 获取 <strong>MOF</strong> 文件的过程，以及对 <strong>MOF</strong> 的排序与合并处理</p><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210903114933804.png" alt="Shuffle 过程"></p><p>其中——</p><ul><li>文件归并时，如果溢写文件数量大于预定值（默认是3）则可以再次启动 Combiner，少于 3 不需要</li><li><strong>JobTracker</strong> 会一直监测 <strong>Map</strong> 任务的执行，并通知 <strong>Reduce</strong> 任务来领取数据</li><li><strong>Reduce</strong> 任务通过 <strong>RPC</strong> 向 <strong>JobTracker</strong> 询问 <strong>Map</strong> 任务是否已经完成；若完成，则领取数据</li><li><strong>Reduce</strong> 领取数据先放入缓存，来自不同 <strong>Map</strong> 机器，<strong>先归并，再合并</strong>，写入磁盘</li><li><strong>多个溢写文件</strong>归并成一个或多个大文件，文件中的<strong>键值对是排序过的</strong></li></ul><h3 id="一个典型的-WordCount-案例"><a href="#一个典型的-WordCount-案例" class="headerlink" title="一个典型的 WordCount 案例"></a>一个典型的 WordCount 案例</h3><h4 id="程序功能"><a href="#程序功能" class="headerlink" title="程序功能"></a>程序功能</h4><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210903115517116.png" alt="WordCount程序功能"></p><h4 id="Map-过程"><a href="#Map-过程" class="headerlink" title="Map 过程"></a>Map 过程</h4><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210903115627322.png" alt="Map 过程"></p><h4 id="Reduce-过程"><a href="#Reduce-过程" class="headerlink" title="Reduce 过程"></a>Reduce 过程</h4><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210903115652172.png" alt="Reduce 过程"></p><h3 id="YARN-组件架构"><a href="#YARN-组件架构" class="headerlink" title="YARN 组件架构"></a>YARN 组件架构</h3><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210903115841245.png" alt="Yarn 工作流程"></p><p>在图中有两个客户端向 <strong>Yarn</strong> 提交任务，蓝色表示一个任务流程，棕色表示另一个任务流程</p><ul><li>首先 <strong>client</strong> 提交任务，<strong>ResourceManager</strong> 接收到任务，然后启动并监控起来的第一个 <strong>Container</strong>，也就是 <strong>Application Master</strong></li><li><strong>Application Master</strong> 通知 <strong>NodeManager</strong> 管理资源并启动其他 <strong>Container</strong></li><li>任务最终是运行在 <strong>Container</strong> 当中。</li></ul><h3 id="MapReduce-On-YARN"><a href="#MapReduce-On-YARN" class="headerlink" title="MapReduce On YARN"></a>MapReduce On YARN</h3><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210903121324145.png" alt="MapReduce On YARN"></p><ol><li>用户向 <strong>YARN</strong> 中提交应用程序， 其中包括 <strong>ApplicationMaster</strong> 程序、启动 <strong>ApplicationMaster</strong> 的命令、用户程序等</li><li><strong>ResourceManager</strong> 为该应用程序分配第一个 <strong>Container</strong>， 并与对应的 <strong>NodeManager</strong> 通信，要求它在这个 <strong>Container</strong> 中启动应用程序的 <strong>ApplicationMaster</strong> </li><li><strong>ApplicationMaster</strong> 首先向 <strong>ResourceManager</strong> 注册， 这样用户可以直接通过 <strong>ResourceManager</strong> 查看应用程序的运行状态，然后它将为各个任务申请资源，并监控它的运行状态，直到运行结束，即<strong>重复 4~7</strong></li><li><strong>ApplicationMaster</strong> 采用轮询的方式通过 <strong>RPC</strong> 协议向 <strong>ResourceManager</strong> 申请和领取资源</li><li>一旦 <strong>ApplicationMaster</strong> 申请到资源后，便与对应的 <strong>NodeManager</strong> 通信，要求它启动任务</li><li><strong>NodeManager</strong> 为任务设置好运行环境（包括环境变量、JAR 包、二进制程序等） 后，将任务启动命令写到一个脚本中，并通过运行该脚本启动任务</li><li>各个任务通过某个 <strong>RPC</strong> 协议向 <strong>ApplicationMaster</strong> 汇报自己的状态和进度，以让 <strong>ApplicationMaster</strong> 随时掌握各个任务的运行状态，从而可以在任务失败时重新启动任务。 在应用程序运行过程中，用户可随时通过 <strong>RPC</strong> 向 <strong>ApplicationMaster</strong> 查询应用程序的当前运行状态</li><li>应用程序运行完成后，<strong>ApplicationMaster</strong> 向 <strong>ResourceManager</strong> 注销并关闭自己</li></ol><h3 id="YARN-HA-方案"><a href="#YARN-HA-方案" class="headerlink" title="YARN HA 方案"></a>YARN HA 方案</h3><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210903122041042.png" alt="YARN HA 方案"></p><p><strong>YARN</strong> 中的 <strong>ResourceManager</strong> 负责整个集群的<strong>资源管理和任务调度</strong>，<strong>YARN</strong> 高可用性方案通过引入冗余的 <strong>ResourceManager</strong> 节点的方式，解决了 <strong>ResourceManager</strong> 单点故障问题。</p><p>在未开启自动故障转移时，<strong>Yarn</strong> 集群启动后，管理员需要在命令行中使用 <code>yarn rmadmin</code> 命令手动将其中一个 <strong>ResourceManager</strong> 切换为 <strong>Active</strong> 状态。</p><ul><li>当需要执行计划性维护或故障发 生时，则需要先手动将 <strong>Active</strong> 状态的 <strong>ResourceManager</strong> 切换为 <strong>Standby</strong> 状态，再将另一个 <strong>ResourceManager</strong> 切换为 <strong>Active</strong> 状态。</li></ul><p>开启自动故障转移后，<strong>ResourceManager</strong> 会通过内置的基于 <strong>ZooKeeper</strong> 实现的  <strong>ActiveStandbyElector</strong> 来决定哪一个 <strong>ResouceManager</strong> 应该成为 <strong>Active</strong> 节点。</p><ul><li>当 <strong>Active</strong> 状态的 <strong>ResourceManager</strong> 发生故障时，另一个 <strong>ResourceManager</strong> 将自动被选举为 <strong>Active</strong> 状态以接替故障节点。</li></ul><p>当集群的 <strong>ResourceManager</strong> 以 <strong>HA</strong> 方式部署时，客户端使用的 <strong>“yarn-site.xml”</strong> 需要配置所有 <strong>ResourceManager</strong> 地址。</p><p><strong>客户端（包括 ApplicationMaster 和 NodeManager）</strong>会以轮询的方式寻找 <strong>Active</strong> 状态的 <strong>ResourceManager</strong>。</p><ul><li>如果当前 <strong>Active</strong> 状态的 <strong>ResourceManager</strong> 无法连接，那么会继续使用轮询的方式找到新的 <strong>ResourceManager</strong>。</li></ul><h3 id="YARN-ApplicationMaster-容错机制"><a href="#YARN-ApplicationMaster-容错机制" class="headerlink" title="YARN ApplicationMaster 容错机制"></a>YARN ApplicationMaster 容错机制</h3><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210903122653120.png" alt="YARN ApplicationMaster 容错机制"></p><p>在 <strong>YARN</strong> 中，<strong>ApplicationMaster</strong> 与其他 <strong>Container</strong> 类似也运行在 <strong>NodeManager</strong> 上（忽略未管理的AM）。AM 可能会由于多种原因崩溃、退出或关闭。</p><ul><li>如果 AM 停止运行， ResourceManager 会关闭 <strong>ApplicationAttempt</strong> 中管理的所有 Container，包括当前任务在 NodeManager 上正在运行的<strong>所有 Container</strong>。</li><li>RM 会在另一计算节点上启动新的 <strong>ApplicationAttempt</strong>。</li></ul><p>不同类型的应用希望以多种方式处理 AM 重新启动的事件。<strong>MapReduce</strong> 类应用<strong>目标是不丢失任务状态</strong>，但也<strong>能允许一部分</strong>的状态损失。</p><ul><li>对于<strong>长周期的服务</strong>而言，用户并不希望仅仅由于 AM 的故障而导致整个服务停止运行。</li></ul><p><strong>YARN</strong> 支持在新的 <strong>ApplicationAttempt</strong> 启动时，保留之前 <strong>Container</strong> 的状态，因此运行中的作业可以继续无故障的运行</p><h2 id="Part-3-YARN-的资源管理和任务调度"><a href="#Part-3-YARN-的资源管理和任务调度" class="headerlink" title="Part 3 YARN 的资源管理和任务调度"></a>Part 3 YARN 的资源管理和任务调度</h2><h3 id="资源管理"><a href="#资源管理" class="headerlink" title="资源管理"></a>资源管理</h3><p>每个 <strong>NodeManager</strong> 可分配的<strong>内存和CPU</strong>的数两可以通过配置选项设置（可在 YARN 服务配置页面配置）</p><ul><li><strong>yarn.nodemanager.resource.memory-mb：</strong>表示用于当前 NodeManager 上可以分配给容器的物理内存的大小，单位：MB。<ul><li>必须小于NodeManager服务器上的实际内存大小</li></ul></li><li><strong>yarn.nodemanager.vmem-pmem-ratio：</strong>表示为容器设置内存限制时虚拟内存跟物理内存的比值。<ul><li>容器分配值使用物理内存表示的，虚拟内存使用率超过分配值的比例不允许大于当前这个比例</li></ul></li><li><strong>yarn.nodemanager.resource.cpu-vcore：</strong>表示可分配给container的CPU核数。<ul><li>建议配置为 CPU 核数的 1.5-2 倍</li></ul></li></ul><h3 id="YARN-的三种资源调度器"><a href="#YARN-的三种资源调度器" class="headerlink" title="YARN 的三种资源调度器"></a>YARN 的三种资源调度器</h3><p>在 <strong>YARN</strong> 中，负责给引用分配资源的组件叫做 <strong>Scheduler</strong>，根据不同的策略，共有三种调度器可供选择——</p><ol><li><strong>FIFO Scheduler：</strong>队列式分配资源，把应用按提交顺序排成队列，待头应用需求满足后再给下一个分配，以此类推</li><li><strong>Capacity Scheduler：</strong>允许多个组织共享整个集群，每个组织可以获得集群的一部分计算能力<ul><li>通过为每个组织分配专门的队列，然后再为每个队列分配一定的集群资源</li><li>通过设置多个队列的方式给多个组织提供服务</li><li>除此之外，队列内部又可以垂直划分，这样一个组织内部的多个成员就可以共享这个队列资源了</li><li>队列内部采用 <strong>FIFO</strong> 策略进行资源调度</li></ul></li><li><strong>Fair Scheduler：</strong>为所有的应用分配公平的资源（对公平的定义可以通过参数来设置）</li></ol><p>生产上常用 <strong>Capacity Scheduler</strong></p><h4 id="容量调度器的介绍-——-Capacity-Scheduler"><a href="#容量调度器的介绍-——-Capacity-Scheduler" class="headerlink" title="容量调度器的介绍 —— Capacity Scheduler"></a>容量调度器的介绍 —— Capacity Scheduler</h4><p>容量调度器使得 <strong>Hadoop</strong> 应用能够<strong>共享的、多用户的、操作简便的</strong>运行在集群上</p><ul><li>同时最大化集群的吞吐量和利用率</li></ul><p>容量调度器以<strong>队列为单位</strong>划分资源，每个队列都有资源使用的上下限</p><ul><li>每个用户可以设定资源使用上线</li><li>管理员可以约束单个队列、用户或作业的资源使用</li><li>支持作业优先级，但不支持资源抢占</li></ul><p>在 <strong>Hadoop 3.x</strong> 中，<strong>OrgQueue</strong> 扩展了容量调度器，通过 <strong>REST API</strong> 提供了以编程的方式来改变队列的配置。这样，管理员可以在队列的 <strong>administer——queue ACL</strong> 中自动进行队列配置管理</p><h3 id="资源分配模型"><a href="#资源分配模型" class="headerlink" title="资源分配模型"></a>资源分配模型</h3><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210903124812188.png" alt="资源分配模型"></p><p>调度器维护一群队列的信息，用户可以为一个或多个队列提交应用。</p><p>每次 <strong>NM</strong> 心跳时，调度器根据一定的规则选择一个队列，再在队列上选择一个应用，尝试在这个一个用上分配资源。</p><p>调度器会优先匹配本地资源的申请请求，其次是同机架，最后是任意机器的。</p><h2 id="Part-4-华为大数据平台增强特性"><a href="#Part-4-华为大数据平台增强特性" class="headerlink" title="Part 4 华为大数据平台增强特性"></a>Part 4 华为大数据平台增强特性</h2><h3 id="YARN-动态内存管理"><a href="#YARN-动态内存管理" class="headerlink" title="YARN 动态内存管理"></a>YARN 动态内存管理</h3><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210903125047785.png" alt="YARN 动态内存管理"></p><p>动态内存管理可用来优化 NodeManager 中 Containers 的内存利用率。任务在运行过程中可能产生多个 Container</p><p>当前，当单个节点上的 Container 超过 Container 运行内存大小时，即使节点总的配置内存 利用还很低，NodeManager 也会终止这些 Containers。这样就会经常使用户作业失败</p><p>动态内存管理特性在当前是一个改进，只有当 NodeManager 中的所有 Containers 的总内存使用超过了已确定的阈值，那么那些内存使用过多的 Containers 才会被终止。</p><p>NM 总内存阈值（单位GB）的计算方法是 :</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">yarn</span>.nodemanager.resource.memory-mb * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span> * yarn.nodemanager.dynamic.memory.usage.threshold<br></code></pre></td></tr></table></figure><h3 id="YARN-基于标签调度"><a href="#YARN-基于标签调度" class="headerlink" title="YARN 基于标签调度"></a>YARN 基于标签调度</h3><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210903125453839.png" alt="YARN 基于标签调度"></p><p><strong>Label based scheduling</strong> 是一种调度策略。该策略的基本思想是：</p><ul><li>用户可以为每个 nodemanager 标注一个标签，比如 high-memory，high-IO 等进行分类，以表明该 nodemanager 的特性</li><li>同时，用户可以为调度器中每个队列标注一个标签，即队列与标签绑定</li><li>这样，提交到某个队列中的作业，只会使用标注有对应标签的节点上的资源，即任务实际运行在打有对应标签的节点上</li></ul><p>在没有标签调度之前，任务提交到哪个节点上是无法控制的，会根据一些算法及条件，集 群随机分配到某些节点上。而标签调度<strong>可以指定任务提交到哪些节点</strong>上</p><ul><li>比如之前需要消耗高内存的应用提交上来，由于运行在那些节点不可控，任务可能运行在普通性能的机器上</li><li>将耗内存消耗型的任务提交到绑定了 <strong>high-memry</strong> 的标签的队列上，那么任务就可以运行在 高内存机器上</li></ul>]]></content>
    
    
    <categories>
      
      <category>Big Data Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Notes - 415</title>
    <link href="/2021/09/03/LeetCode-Notes-415/"/>
    <url>/2021/09/03/LeetCode-Notes-415/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-Notes-415"><a href="#Leetcode-Notes-415" class="headerlink" title="Leetcode Notes - 415"></a>Leetcode Notes - 415</h1><p>题目：<strong>415. 字符串相加</strong></p><p>难度：<strong>简单</strong></p><p>遇见次数：<strong>第二次</strong></p><p>涉及知识点：</p><ul><li>模拟</li><li>字符串四则运算</li></ul><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="1-模拟"><a href="#1-模拟" class="headerlink" title="1. 模拟"></a>1. 模拟</h3><p>很拉的模拟😥</p><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210903162803616.png" alt="自己的模拟"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">addStrings</span><span class="hljs-params">(String num1, String num2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(num1.length() &lt; num2.length()) <span class="hljs-keyword">return</span> addStrings(num2, num1);<br>        <br>        <span class="hljs-keyword">while</span>(num2.length() &lt; num1.length())&#123;<br>            num2 = <span class="hljs-string">&quot;0&quot;</span> + num2;<br>        &#125;<br>        <br>        String ans = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">int</span> len = num1.length();<br>        <span class="hljs-keyword">boolean</span> addOn = <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">char</span>[] chArr1 = num1.toCharArray();<br>        <span class="hljs-keyword">char</span>[] chArr2 = num2.toCharArray();<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = len - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123;<br>            <span class="hljs-keyword">int</span> cur = Integer.parseInt(Character.toString(chArr1[i])) + Integer.parseInt(Character.toString(chArr2[i]));<br>            <br>            <span class="hljs-keyword">if</span>(addOn)&#123;<br>                cur++;<br>                addOn = <span class="hljs-keyword">false</span>;<br>            &#125;<br>            <br>            <span class="hljs-comment">// Check whether cur is bigger than 9</span><br>            <span class="hljs-keyword">if</span>(cur &gt; <span class="hljs-number">9</span>)&#123;<br>                addOn = <span class="hljs-keyword">true</span>;<br>                cur = cur - <span class="hljs-number">10</span>;<br>            &#125;<br>            <br>            ans = String.format(<span class="hljs-string">&quot;%d&quot;</span>, cur) + ans;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> addOn ? <span class="hljs-string">&quot;1&quot;</span> + ans : ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h3><h4 id="思路及算法"><a href="#思路及算法" class="headerlink" title="思路及算法"></a>思路及算法</h4><p>利用负数位返回零来作为补零操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">addStrings</span><span class="hljs-params">(String num1, String num2)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> i = num1.length() - <span class="hljs-number">1</span>, j = num2.length() - <span class="hljs-number">1</span>, add = <span class="hljs-number">0</span>;<br>        StringBuffer ans = <span class="hljs-keyword">new</span> StringBuffer();<br>        <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span> || j &gt;= <span class="hljs-number">0</span> || add != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">int</span> x = i &gt;= <span class="hljs-number">0</span> ? num1.charAt(i) - <span class="hljs-string">&#x27;0&#x27;</span> : <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">int</span> y = j &gt;= <span class="hljs-number">0</span> ? num2.charAt(j) - <span class="hljs-string">&#x27;0&#x27;</span> : <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">int</span> result = x + y + add;<br>            ans.append(result % <span class="hljs-number">10</span>);<br>            add = result / <span class="hljs-number">10</span>;<br>            i--;<br>            j--;<br>        &#125;<br>        <span class="hljs-comment">// 计算完以后的答案需要翻转过来</span><br>        ans.reverse();<br>        <span class="hljs-keyword">return</span> ans.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Notes - 409</title>
    <link href="/2021/09/03/LeetCode-Notes-409/"/>
    <url>/2021/09/03/LeetCode-Notes-409/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-Notes-409"><a href="#Leetcode-Notes-409" class="headerlink" title="Leetcode Notes - 409"></a>Leetcode Notes - 409</h1><p>题目：<strong>409. 最长回文串</strong></p><p>难度：<strong>简单</strong></p><p>遇见次数：<strong>第二次</strong></p><p>涉及知识点：</p><ul><li>贪心</li><li>字符串</li></ul><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="1-哈希表"><a href="#1-哈希表" class="headerlink" title="1. 哈希表"></a>1. 哈希表</h3><p>效率不咋地的哈希🛬</p><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210903164227533.png" alt="哈希表"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        Map&lt;Character, Integer&gt; mp = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> ch : s.toCharArray())&#123;<br>            <span class="hljs-keyword">int</span> cur = mp.getOrDefault(ch, <span class="hljs-number">0</span>);<br><br>            mp.put(ch, cur + <span class="hljs-number">1</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">boolean</span> center = <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> ele : mp.keySet())&#123;<br>            <span class="hljs-keyword">int</span> cur = mp.get(ele);<br><br>            <span class="hljs-keyword">if</span>(cur % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)&#123;<br>                count += cur;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">if</span>(center)&#123;<br>                    count = count + cur - <span class="hljs-number">1</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span>&#123;<br>                    count += cur;<br>                    center = <span class="hljs-keyword">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h3><h4 id="思路及算法"><a href="#思路及算法" class="headerlink" title="思路及算法"></a>思路及算法</h4><p>对于每个字符 ch，假设它出现了 v 次，我们可以使用该字符 v / 2 * 2 次，在回文串的左侧和右侧分别放置 v / 2 个字符 ch，其中 / 为整数除法。例如若 “a” 出现了 5 次，那么我们可以使用 “a” 的次数为 4，回文串的左右两侧分别放置 2 个 “a”。</p><p>如果有任何一个字符 ch 的出现次数 v 为奇数（即 v % 2 == 1），那么可以将这个字符作为回文中心，注意只能最多有一个字符作为回文中心。在代码中，我们用 ans 存储回文串的长度，由于在遍历字符时，ans 每次会增加 v / 2 * 2，因此 ans 一直为偶数。但在发现了第一个出现次数为奇数的字符后，我们将 ans 增加 1，这样 ans 变为奇数，在后面发现其它出现奇数次的字符时，我们就不改变 ans 的值了。</p><blockquote><p>很巧妙的利用了语言整除中 round 的特性，就不用再像我那样做判断了</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[] count = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">128</span>];<br>        <span class="hljs-keyword">int</span> length = s.length();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; length; ++i) &#123;<br>            <span class="hljs-keyword">char</span> c = s.charAt(i);<br>            count[c]++;<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> v: count) &#123;<br>            ans += v / <span class="hljs-number">2</span> * <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (v % <span class="hljs-number">2</span> == <span class="hljs-number">1</span> &amp;&amp; ans % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br>                ans++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br><br>作者：LeetCode-Solution<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/longest-palindrome/solution/zui-chang-hui-wen-chuan-by-leetcode-solution/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Notes - 560</title>
    <link href="/2021/09/02/LeetCode-Notes-560/"/>
    <url>/2021/09/02/LeetCode-Notes-560/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-Notes-560"><a href="#Leetcode-Notes-560" class="headerlink" title="Leetcode Notes - 560"></a>Leetcode Notes - 560</h1><p>题目：<strong>560. 和为K的子数组</strong></p><p>难度：<strong>中等</strong></p><p>遇见次数：<strong>第二次</strong></p><p>涉及知识点：</p><ul><li>前缀和</li><li>哈希表</li></ul><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="前缀和-哈希表优化"><a href="#前缀和-哈希表优化" class="headerlink" title="前缀和+哈希表优化"></a>前缀和+哈希表优化</h3><p>理解题解后自己写的版本👇</p><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210902122836379.png" alt="前缀和+哈希表优化"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">subarraySum</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> pre = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>        Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br><br>        map.put(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i : nums)&#123;<br>            pre = pre + i;<br>            <span class="hljs-keyword">int</span> cur = map.getOrDefault(pre, <span class="hljs-number">0</span>);<br><br>            <span class="hljs-keyword">if</span>(map.containsKey(pre - k))&#123;<br>                count = count + map.get(pre - k);<br>            &#125;<br><br>            map.put(pre, cur + <span class="hljs-number">1</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="前缀和-哈希表优化-1"><a href="#前缀和-哈希表优化-1" class="headerlink" title="前缀和+哈希表优化"></a>前缀和+哈希表优化</h3><h4 id="思路及算法"><a href="#思路及算法" class="headerlink" title="思路及算法"></a>思路及算法</h4><ol><li>每个元素对应一个 “前缀和”</li><li>遍历数组，根据当前 “前缀和”，在 map 中寻找「与之相减 == k」的历史前缀和</li><li>当前 “前缀和” 与历史前缀和，差分出一个子数组，该历史前缀和出现过 c 次，等价于当前项找到 c 个子数组求和等于 k</li><li>遍历过程中，c 不断加给 count，最后返回 count</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">subarraySum</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>, pre = <span class="hljs-number">0</span>;<br>        HashMap &lt; Integer, Integer &gt; mp = <span class="hljs-keyword">new</span> HashMap &lt; &gt; ();<br>        mp.put(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            pre += nums[i];<br>            <span class="hljs-keyword">if</span> (mp.containsKey(pre - k)) &#123;<br>                count += mp.get(pre - k);<br>            &#125;<br>            mp.put(pre, mp.getOrDefault(pre, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br><br>作者：LeetCode-Solution<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/subarray-sum-equals-k/solution/he-wei-kde-zi-shu-zu-by-leetcode-solution/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><blockquote><p>气死了！为了写这个题解我健美选修没了，淦！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Leetcode Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Notes - 238</title>
    <link href="/2021/09/02/LeetCode-Notes-238/"/>
    <url>/2021/09/02/LeetCode-Notes-238/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-Notes-238"><a href="#Leetcode-Notes-238" class="headerlink" title="Leetcode Notes -238"></a>Leetcode Notes -238</h1><p>题目：<strong>238. 除自身以外数组的乘积</strong></p><p>难度：<strong>中等</strong></p><p>遇见次数：<strong>第二次</strong></p><p>涉及知识点：</p><ul><li>数组</li></ul><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="1-双向乘法"><a href="#1-双向乘法" class="headerlink" title="1. 双向乘法"></a>1. 双向乘法</h3><p>不擦😊</p><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210902113553113.png" alt="双向乘法"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] productExceptSelf(<span class="hljs-keyword">int</span>[] nums) &#123;<br>        <span class="hljs-keyword">int</span> n = nums.length;<br>        <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br><br>        <span class="hljs-comment">// Left Multiplication</span><br>        <span class="hljs-keyword">int</span> cur = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> val = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>; l &lt; n; l++)&#123;<br>            <span class="hljs-keyword">while</span>(cur &lt; l)&#123;<br>                val *= nums[cur];<br>                cur++;<br>            &#125;<br>            res[l] = val;<br>        &#125;<br><br>        <span class="hljs-comment">// Right Multiplication</span><br>        cur = n - <span class="hljs-number">1</span>;<br>        val = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> r = n - <span class="hljs-number">1</span>; r &gt;= <span class="hljs-number">0</span>; r--)&#123;<br>            <span class="hljs-keyword">while</span>(cur &gt; r)&#123;<br>                val *= nums[cur];<br>                cur--;<br>            &#125;<br><br>            res[r] = res[r] * val;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="空间复杂度为O-1-的方法"><a href="#空间复杂度为O-1-的方法" class="headerlink" title="空间复杂度为O(1)的方法"></a>空间复杂度为O(1)的方法</h3><h4 id="思路及算法"><a href="#思路及算法" class="headerlink" title="思路及算法"></a>思路及算法</h4><p>由于输出数组不算在空间复杂度内，那么我们可以将 L 或 R 数组用输出数组来计算。先把输出数组当作 L 数组来计算，然后再动态构造 R 数组得到结果。让我们来看看基于这个思想的算法。</p><p>初始化 answer 数组，对于给定索引 i，answer[i] 代表的是 i 左侧所有数字的乘积。</p><p>构造方式与之前相同，只是我们试图节省空间，先把 answer 作为方法一的 L 数组。这种方法的唯一变化就是我们没有构造 R 数组。而是用一个遍历来跟踪右边元素的乘积。并更新数组 answer[i] = answer[i] ∗ R。然后 RR 更新为R = R ∗ nums[i]，其中变量 R 表示的就是索引右侧数字的乘积。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] productExceptSelf(<span class="hljs-keyword">int</span>[] nums) &#123;<br>        <span class="hljs-keyword">int</span> length = nums.length;<br>        <span class="hljs-keyword">int</span>[] answer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[length];<br><br>        <span class="hljs-comment">// answer[i] 表示索引 i 左侧所有元素的乘积</span><br>        <span class="hljs-comment">// 因为索引为 &#x27;0&#x27; 的元素左侧没有元素， 所以 answer[0] = 1</span><br>        answer[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; length; i++) &#123;<br>            answer[i] = nums[i - <span class="hljs-number">1</span>] * answer[i - <span class="hljs-number">1</span>];<br>        &#125;<br><br>        <span class="hljs-comment">// R 为右侧所有元素的乘积</span><br>        <span class="hljs-comment">// 刚开始右边没有元素，所以 R = 1</span><br>        <span class="hljs-keyword">int</span> R = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-comment">// 对于索引 i，左边的乘积为 answer[i]，右边的乘积为 R</span><br>            answer[i] = answer[i] * R;<br>            <span class="hljs-comment">// R 需要包含右边所有的乘积，所以计算下一个结果时需要将当前值乘到 R 上</span><br>            R *= nums[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> answer;<br>    &#125;<br>&#125;<br><br>作者：LeetCode-Solution<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/product-of-array-except-self/solution/chu-zi-shen-yi-wai-shu-zu-de-cheng-ji-by-leetcode-/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><blockquote><p>这个算是做过一次就学会了，输出数组不算入空间复杂度</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Leetcode Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Notes - 334</title>
    <link href="/2021/09/02/LeetCode-Notes-334/"/>
    <url>/2021/09/02/LeetCode-Notes-334/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-Notes-334"><a href="#Leetcode-Notes-334" class="headerlink" title="Leetcode Notes - 334"></a>Leetcode Notes - 334</h1><p>题目：<strong>334. 递增的三元子序列</strong></p><p>难度：<strong>中等</strong></p><p>遇见次数：<strong>第二次</strong></p><p>涉及知识点：</p><ul><li>贪心</li></ul><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="1-贪心-？"><a href="#1-贪心-？" class="headerlink" title="1. 贪心 ？"></a>1. 贪心 ？</h3><p>复读版本📕</p><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210902131133263.png" alt="伪DP"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">increasingTriplet</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(nums.length &lt; <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br><br>        <span class="hljs-keyword">int</span> small = Integer.MAX_VALUE;<br>        <span class="hljs-keyword">int</span> mid = Integer.MAX_VALUE;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> cur : nums)&#123;<br>            <span class="hljs-keyword">if</span>(cur &lt;= small)&#123;<br>                small = cur;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cur &lt;= mid)&#123;<br>                mid = cur;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cur &gt; mid)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h4 id="思路及算法"><a href="#思路及算法" class="headerlink" title="思路及算法"></a>思路及算法</h4><p>本题的思路非常的巧妙！</p><p>首先，新建两个变量 small 和 mid ，分别用来保存题目要我们求的长度为 3 的递增子序列的最小值和中间值。</p><p>接着，我们遍历数组，每遇到一个数字，我们将它和 small 和 mid 相比，若小于等于 small ，则替换 small；否则，若小于等于 mid，则替换 mid；否则，若大于 mid，则说明我们找到了长度为 3 的递增数组！</p><p>上面的求解过程中有个问题：当已经找到了长度为 2 的递增序列，这时又来了一个比 small 还小的数字，为什么可以直接替换 small 呢，这样 small 和 mid 在原数组中并不是按照索引递增的关系呀？</p><p>Trick 就在这里了！假如当前的 small 和 mid 为 [3, 5]，这时又来了个 1。假如我们不将 small 替换为 1，那么，当下一个数字是 2，后面再接上一个 3 的时候，我们就没有办法发现这个 [1,2,3] 的递增数组了！也就是说，我们替换最小值，是为了后续能够更好地更新中间值！</p><p>另外，即使我们更新了 small ，这个 small 在 mid 后面，没有严格遵守递增顺序，但它隐含着的真相是，有一个比 small 大比 mid 小的前·最小值出现在 mid 之前。因此，当后续出现比 mid 大的值的时候，我们一样可以通过当前 small 和 mid 推断的确存在着长度为 3 的递增序列。 所以，这样的替换并不会干扰我们后续的计算！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">increasingTriplet</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> len = nums.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">if</span> (len &lt; <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">int</span> small = INT_MAX, mid = INT_MAX;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> num : nums) &#123;<br>      <span class="hljs-keyword">if</span> (num &lt;= small) &#123;<br>        small = num;<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (num &lt;= mid) &#123;<br>        mid = num;<br>      &#125; <br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (num &gt; mid) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    <br>  &#125;<br>&#125;;<br><br>作者：fxxuuu<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/increasing-triplet-subsequence/solution/c-xian-xing-shi-jian-fu-za-du-xiang-xi-jie-xi-da-b/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Big Data Intro - Chapter 4</title>
    <link href="/2021/09/02/Big-Data-Intro-Chapter-4/"/>
    <url>/2021/09/02/Big-Data-Intro-Chapter-4/</url>
    
    <content type="html"><![CDATA[<h1 id="第04章-HBase技术原理"><a href="#第04章-HBase技术原理" class="headerlink" title="第04章 HBase技术原理"></a>第04章 HBase技术原理</h1><h2 id="Part-1-HBase-基本介绍"><a href="#Part-1-HBase-基本介绍" class="headerlink" title="Part 1 HBase 基本介绍"></a>Part 1 HBase 基本介绍</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><strong>HBase</strong> 是一个<strong>高可靠性、高性能、面向列、可伸缩</strong>的分布式存储系统</p><ul><li>适合于<strong>存储大表数据（表的规模可以达到数十亿行以及数百万列）</strong>，并且对达标数据的读、写访问可以达到<strong>实时级别</strong><ul><li>补充：<strong>BigTable结构</strong>，是一个<strong>疏松的分布式的持久的多维排序的map</strong></li><li>这个行map有<strong>行键、列键和时间戳索引</strong>，每一个值都是连续的byte数组</li></ul></li><li>利用 <strong>HDFS</strong> 作为其文件存储系统，提供实时读写的分布式操作系统</li><li>利用 <strong>Zookeeper</strong> 作为协同服务<ul><li>分布式锁</li><li>事件监控</li><li>存储HBase的Region Server数据，充当微型数据库</li></ul></li></ul><h3 id="HBase-与-RDB-的对比"><a href="#HBase-与-RDB-的对比" class="headerlink" title="HBase 与 RDB 的对比"></a>HBase 与 RDB 的对比</h3><h4 id="1-数据索引"><a href="#1-数据索引" class="headerlink" title="1. 数据索引"></a>1. 数据索引</h4><p>关系数据库通常可以针对不同列构建复杂的多个索引，以提高数据访问性能</p><p>HBase只有一个索引——行键，通过巧妙的设计，HBase中的所有访问方法，或者通过行键访问，或者通过行键扫描，从而使得整个系统不会慢下来</p><h4 id="2-数据维护"><a href="#2-数据维护" class="headerlink" title="2. 数据维护"></a>2. 数据维护</h4><p>在关系数据库中，更新操作会用最新的当前值去替换记录中原来的旧值，旧值被覆盖后就不会存在</p><p>在HBase中执行更新操作时，并不会删除数据旧的版本，而是生成一个新的版本，旧有的版本仍然保留</p><h4 id="3-可伸缩性"><a href="#3-可伸缩性" class="headerlink" title="3. 可伸缩性"></a>3. 可伸缩性</h4><p>关系数据库很难实现横向扩展，纵向扩展的空间也比较有限</p><p>相反，HBase 和 <strong>BigTable</strong> 这些分布式数据库就是为了实现灵活的水平扩展而开发的，能够轻易地通过在集群中增加或者减少硬件数量来实现性能的伸缩</p><h2 id="Part-2-HBase-相关概念"><a href="#Part-2-HBase-相关概念" class="headerlink" title="Part 2 HBase 相关概念"></a>Part 2 HBase 相关概念</h2><h3 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h3><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210902194427988.png" alt="HBase表结构"></p><p><strong>单元格 Cell</strong>：在 HBase 表中，通过行，列族和列限定符确定一个“单元格”，单元格中存储的数据没有数据类型，总被视为<strong>字节数组byte[]</strong></p><h3 id="行存储"><a href="#行存储" class="headerlink" title="行存储"></a>行存储</h3><p>数据<strong>按行存储</strong>在底层文件系统中。通常，每一行会被分配固定的空间</p><ul><li>优点：有利于<strong>增加/修改</strong>整行记录等操作；有利于整行数据的<strong>读取操作</strong></li><li>缺点：<strong>单列查询</strong>时，会读取一些不必要的数据</li></ul><h3 id="列存储"><a href="#列存储" class="headerlink" title="列存储"></a>列存储</h3><p>HBase采用<strong>列存储</strong></p><p>数据<strong>以列单位</strong>存储在底层文件系统中</p><ul><li>优点：有利于面向单列数据的<strong>读取/统计</strong>等操作</li><li>缺点：整行读取时，可能需要多次<strong>I/O</strong>操作</li></ul><h2 id="Part-3-HBase-架构"><a href="#Part-3-HBase-架构" class="headerlink" title="Part 3 HBase 架构"></a>Part 3 HBase 架构</h2><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210902195512539.png" alt="HBase整体架构"></p><p><strong>ZooKeeper</strong> 为 HBase 集群中各进程<strong>提供分布式协作服务</strong></p><ul><li>各 <strong>RegionServer</strong> 将自己的信息注册到 <strong>Zookeeper</strong> 中，主用<strong>Master</strong>据此感知各个<strong>RegionServer</strong> 的健康状态</li></ul><p><strong>Client</strong> 使用 HBase 的<strong>RPC</strong>机制与 <strong>Master、RegionServer</strong> 进行通信</p><ul><li><strong>Client</strong> 与 <strong>Master</strong> 进行管理 类通信，与 <strong>RegionServer</strong> 进行数据操作类通信</li></ul><p><strong>RegionServer</strong> 负责提供<strong>表数据读写</strong>等服务，是 HBase 的<strong>数据处理和计算单元</strong></p><ul><li><strong>RegionServer</strong> 一般与 HDFS 集群的 <strong>DataNode</strong> 部署在一起，实现数据的存储功能</li></ul><p><strong>HMaster</strong>，在<strong>HA</strong>模式下，包含 <strong>主用Master和备用Master</strong></p><ul><li>主用Master：负责 HBase 中 RegionServer 的管理，包括表的增删改查；RegionServer 的负载均衡，Region 分布调整；Region 分裂以及分裂后的 Region 分配； RegionServer 失效后的 Region 迁移等</li><li>备用Master：当<strong>主用Master</strong>故障时，备用Master将取代主用Master对外提供服务。 <strong>故障恢复后，原主用Master降为备用</strong></li></ul><p>HDFS 为 HBase 提供<strong>高可靠的文件存储服务</strong>，HBase的数据<strong>全部存储在HDFS</strong>中</p><p>客户端并不依赖 <strong>HMaster</strong>，而是通过 <strong>Zookeeper</strong>来获得 <strong>Region</strong> 位置信息，大多数客户端甚至从来不和 <strong>HMaster</strong> 通信</p><h3 id="主要功能组件"><a href="#主要功能组件" class="headerlink" title="主要功能组件"></a>主要功能组件</h3><p><strong>1. 库函数：链接到每个客户端</strong></p><p><strong>2. 一个 HMaster 主服务器</strong></p><p><strong>3. 多个 HReigonServer</strong></p><p>两个概念——<strong>MemStore 和 StoreFile</strong></p><ul><li>当 <strong>RS</strong> 中的 <strong>MS</strong> 大小达到配置的容量上限时，<strong>RS</strong> 会将 <strong>MS</strong> 中的数据 “flush” 到 HDFS 中</li><li>随着数据的<strong>插入</strong>，一个 <strong>SF</strong> 会产生多个 <strong>SF</strong>，当 <strong>SF</strong> 的个数达到配置的最大时，<strong>RS</strong> 会将多个 <strong>SF</strong> 合并成一个大的 <strong>SF</strong></li></ul><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210902200636355.png" alt="HBase存储架构"></p><h3 id="表和Region"><a href="#表和Region" class="headerlink" title="表和Region"></a>表和Region</h3><ul><li><p>HBase 表开始只有一个 Region，后来不断分裂</p></li><li><p>Region 拆分操作非常快，接近瞬间，拆分过程中的 Region不可读，直到把 Region 存储文件 异步地写到独立的文件之后，才会读取新文件</p></li></ul><h3 id="Region-的定位"><a href="#Region-的定位" class="headerlink" title="Region 的定位"></a>Region 的定位</h3><ul><li>Region 分为 <strong>元数据Region以及用户 Region</strong> 两类</li><li><strong>Meta Region</strong> 记录了每一个 <strong>User Region</strong> 的路由信息</li><li>读写 <strong>Region</strong> 数据的路由，包括如下几步：<ul><li>找寻 <strong>Meta Region</strong> 地址</li><li>再由 <strong>Meta Region</strong> 找寻 <strong>User Region</strong> 地址</li></ul></li></ul><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>客户端包含访问 <strong>HBase</strong> 的接口，同时在缓存中维护着已经访问过的 <strong>Region</strong> 位置信息，用来加快后续数据访问过程</p><p>整体过程是——</p><ol><li>查询 <strong>hbase:meta</strong> 表</li><li>确定 <strong>Region</strong> 的位置</li><li>定位到所需要的区域后，客户端直接访问相应的 <strong>Region（不经过HMaster）</strong>，发起读写请求</li></ol><h3 id="HMaster-和-HRegionServer"><a href="#HMaster-和-HRegionServer" class="headerlink" title="HMaster 和 HRegionServer"></a>HMaster 和 HRegionServer</h3><h4 id="Master"><a href="#Master" class="headerlink" title="Master"></a>Master</h4><p>负责 <strong>表和 Region</strong> 的管理工作</p><ul><li>管理用户对表的<strong>增加、删除、修改、查询</strong>等操作</li><li>实现不同 <strong>HRegionServer</strong> 之间的负载均衡</li><li>在 <strong>Region</strong> 分裂或合并后，负责重新调整 <strong>Region</strong> 的分布</li><li>对发生故障失效的 <strong>HRegionServer</strong> 上的Region进行迁移</li></ul><p>高可用：ZK 可以帮助选举出一个 HMaster作为集群的总管，并保证在任何时刻总有唯一一个 HMaster 在运行，这就避免了 HMaster 的“单点失效”问题</p><h4 id="RegionServer"><a href="#RegionServer" class="headerlink" title="RegionServer"></a>RegionServer</h4><p>HRS 是 HBase 中最核心的模块</p><ul><li>负责维护分配给自己的 Region</li><li>响应用户的读写请求</li></ul><h2 id="Part-3-HBase-关键流程"><a href="#Part-3-HBase-关键流程" class="headerlink" title="Part 3 HBase 关键流程"></a>Part 3 HBase 关键流程</h2><h3 id="用户读写数据过程"><a href="#用户读写数据过程" class="headerlink" title="用户读写数据过程"></a>用户读写数据过程</h3><ol><li>用户写入数据时，被分配到相应 <strong>HRegionServer</strong> 去执行</li><li>用户数据首先被写入 <strong>Hlog</strong> 中，再写入 <strong>MemStore</strong> 中，最终写到磁盘上形成 <strong>StoreFile</strong></li><li>只有当操作写入 <strong>Hlog</strong> 之后，<strong>commit()</strong> 调用才会将其返回给客户端</li><li>当用户读取数据时，<strong>HRegionServer</strong> 首先访问 <strong>MemStore</strong> 缓存，如果找不到，再去磁盘上面的 <strong>StoreFile</strong> 中寻找</li></ol><h3 id="缓存的刷新"><a href="#缓存的刷新" class="headerlink" title="缓存的刷新"></a>缓存的刷新</h3><ol><li>系统会周期性地把 <strong>MemStore</strong> 缓存里的内容刷写到磁盘的 <strong>StoreFIle</strong> 文件中，清空缓存，并在 <strong>Hlog</strong> 里面写入一个标记</li><li>每次刷写都生成一个新的 <strong>StoreFile</strong> 文件，因此，每个 <strong>Store</strong> 包含多个 <strong>StoreFile</strong> 文件</li><li>每个 <strong>HRegionServer</strong> 都有一个自己的 <strong>Hlog</strong> 文件，每次启动都检查该文件，确认最近一次执行缓存刷新操作之后是否发生新的写入操作；如果发现更新，则先写入 <strong>MemStore</strong> ，再刷写到 <strong>StoreFile</strong>，开始为用户提供服务</li></ol><h3 id="StoreFile-的合并"><a href="#StoreFile-的合并" class="headerlink" title="StoreFile 的合并"></a>StoreFile 的合并</h3><ol><li>每次刷写都生成一个新的 <strong>StoreFile</strong>，数量太多，影响查找速度</li><li>调用 <strong>Store.compact()</strong> 把多个合并成一个</li><li>合并操作比较耗费资源，只有数量达到一个阈值才启动合并</li></ol><h3 id="Store-工作原理"><a href="#Store-工作原理" class="headerlink" title="Store 工作原理"></a>Store 工作原理</h3><ol><li><strong>Store</strong> 是 <strong>HRegionServer</strong> 的核心</li><li>多个 <strong>StoreFIle</strong> 合并成一个</li><li>单个 <strong>StoreFile</strong> 过大时，又触发分裂操作，一个父 <strong>Region</strong> 被分裂成两个子 <strong>Region</strong></li></ol><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210902212733671.png" alt="Store 工作原理"></p><h3 id="Hlog-工作原理"><a href="#Hlog-工作原理" class="headerlink" title="Hlog 工作原理"></a>Hlog 工作原理</h3><ol><li>分布式环境必须要考虑系统出错。HBase 采用 <strong>Hlog</strong> 保证系统恢复</li><li>HBase 系统为每个 <strong>HRegionServer</strong> 配置了一个 <strong>Hlog</strong> 文件，它是一种预写式日志（Write Ahead Log）</li><li>用户更新数据必须<strong>首先写入日志</strong>后，才能写入 <strong>MemStore</strong> 缓存，并且，知道 <strong>MemStore</strong> 缓存内容对应的日志已经写入磁盘，该缓存内容才能被刷写到磁盘</li><li><strong>Zookeeper</strong> 会实时检测每个 <strong>HRegionServer</strong> 的状态，当某个 <strong>HRegionServer</strong> 发生故障时，<strong>Zookeeper</strong> 会通知 <strong>HMaster</strong> <ul><li><strong>HMaster</strong> 会首先处理该故障 <strong>HRegionServer</strong> 上面遗留的 <strong>Hlog</strong> 文件，这个遗留的 <strong>Hlog</strong> 文件中包含了来自多个 <strong>Region</strong> 对象的日志记录</li><li>系统会根据<strong>每条日志记录所属的 Region对象</strong> 对 <strong>Hlog</strong> 进行拆分，分别放到对应 <strong>Region 对象</strong> 的目录下，然后，再将失效的 <strong>Region</strong> 重新分配到可用的 <strong>HRegionServer</strong> 中，并把该 <strong>Region对象</strong> 相关的 <strong>Hlog</strong> 日志记录也发送给相应的 <strong>HRegionServer</strong></li><li><strong>HRegionServer</strong> 领取到分配给自己的 <strong>Region</strong> 对象以及与之相关的 <strong>Hlog</strong> 日志记录以后，会重新做一遍日志记录中的各种操作，把日志记录中的数据写入到 <strong>MemStore</strong> 缓存中，然后，刷写到磁盘的 <strong>StoreFile</strong> 文件中，完成数据恢复</li></ul></li><li>共用日志<ul><li>优点：提高对表的写操作性能</li><li>缺点：恢复时需要拆分日志</li></ul></li></ol><h2 id="Part-4-HBase-突出特点"><a href="#Part-4-HBase-突出特点" class="headerlink" title="Part 4 HBase 突出特点"></a>Part 4 HBase 突出特点</h2><h3 id="多-HFile-的影响"><a href="#多-HFile-的影响" class="headerlink" title="多 HFile 的影响"></a>多 HFile 的影响</h3><p><strong>HFile</strong> 文件数目越来越多，读取的时延也越来越大。</p><h3 id="Compaction-压缩"><a href="#Compaction-压缩" class="headerlink" title="Compaction 压缩"></a>Compaction 压缩</h3><p><strong>Compaction</strong> 是为了减少同一个 <strong>Region</strong> 中同一个 <strong>ColumnFamily（列族）</strong> 下面的小文件，即 <strong>HFile</strong> 的数目，从而提升读取的性能</p><p><strong>Compaction</strong> 分为 <strong>Minor和Major</strong> 两类——</p><ul><li>Minor：小范围的压缩。有最少和最大文件数目限制。通常会选择一些<strong>连续时间范围</strong>的小文件惊醒合并</li><li>Major：设计该 <strong>Region</strong> 或者 该 <strong>CF</strong> 下面所有的 <strong>HFile</strong> 文件</li><li><strong>Minor Compaction</strong> 选取文件时，遵循一定的算法</li></ul><p><strong>Compaction</strong> 也会遵循一定的规则</p><ul><li>首先对该 Store 中所有 <strong>HFile</strong> 进行一一排查，排除不满足条件的部分文件：<ul><li>排除当前正在执行 <strong>compact</strong> 的文件及其比这些文件更新的所有文件 ( <strong>SequenceId</strong> 更大)</li><li>排除某些过大的单个文件，如果文件大小大于  <strong>hbase.hzstore.compaction.max.size</strong> (  默认 Long 最大值  )，则被排除，否则会产生大量IO消耗。</li></ul></li></ul><p>经过排除的文件称为<strong>候选文件</strong>，<strong>HBase</strong> 接下来会再判断是否满足 <strong>major compaction</strong> 条件， 如果满足，就会选择全部文件进行合并。判断条件有下面三条，只要满足其中一条就会执行<strong>major compaction</strong></p><ul><li>用户强制执行<strong>major compaction</strong></li><li>长时间没有进行 <strong>compact ( CompactionChecker 的判断条件2 )</strong> 且候选文件数小于 <strong>hbase.hstore.compaction.max (默认10)</strong></li><li><strong>Store</strong> 中含有 <strong>Reference</strong> 文件，<strong>Reference</strong> 文件是 <strong>split region</strong> 产生的临时文件，只是简单的引用文件，一般必须在 <strong>compact</strong> 过程中删除</li></ul><p>如果不满足 <strong>major compaction</strong> 条件，就必然为 <strong>minor compaction</strong></p><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210902215023011.png" alt="Compaction流程"></p><h3 id="OpenScanner"><a href="#OpenScanner" class="headerlink" title="OpenScanner"></a>OpenScanner</h3><p>在寻找到 <strong>rowkey</strong> 所对应的 <strong>RegionServer</strong> 和 <strong>Region</strong> 之后，需要打开一个查找器<strong>Scanner</strong>，由 其具体执行查找数据，<strong>Region</strong> 中会包含<strong>内存数据MemStore</strong>，文件数据<strong>HFile</strong>，那么在 <strong>open  scanner</strong> 的时候就需要分别读取这两块数据，打开对应不同的<strong>scanner</strong> 做查询操作</p><ul><li><strong>HFile</strong> 对应的 <strong>Scanner</strong> 为 <strong>StoreFIleScanner</strong></li><li><strong>MemStore</strong> 对应的 <strong>Scanner</strong> 为 <strong>MemStoreScanner</strong></li></ul><h3 id="BloomFilter"><a href="#BloomFilter" class="headerlink" title="BloomFilter"></a>BloomFilter</h3><ol><li><strong>BloomFilter</strong> 用来优化一些<strong>随机读取</strong>的场景，即 <strong>Get</strong> 场景。它可以被用来快速地判断一条用户数据在一个大的数据集合（该数据集合地大部分数据都没法被加载到内存中）中是否存在</li><li><strong>BloomFilter</strong> 在判断一个数据是否存在时，拥有一定的<strong>误判率</strong>。但对于 “用户数据 XXX不存在” 的判断结果是可信的</li><li><strong>HBase</strong> 的 <strong>BloomFilter</strong> 的相关数据，被保存在 <strong>HFile</strong></li></ol><h2 id="Part-5-HBase-性能优化"><a href="#Part-5-HBase-性能优化" class="headerlink" title="Part 5 HBase 性能优化"></a>Part 5 HBase 性能优化</h2><h3 id="行键（Row-Key）"><a href="#行键（Row-Key）" class="headerlink" title="行键（Row Key）"></a>行键（Row Key）</h3><p>行键是按照 <strong>字典排序</strong> 存储，因此，设计行键时，要充分利用这个排序特点，将经常一起读取的数据存储到一块，将最近可能被访问的数据放在一块</p><p>例子——</p><blockquote><p>如果最近写入 HBase 表中的数据是最可能被访问的，可以考虑将时间戳作为行键的一部分，由于是字典序排序，所以可以使用 Long.MAX_VALUE - timestamp 作为行键，这样能保证新写入的数据在读取时可以被快速命中</p></blockquote><h3 id="构建-HBase-二级索引"><a href="#构建-HBase-二级索引" class="headerlink" title="构建 HBase 二级索引"></a>构建 HBase 二级索引</h3><p>HBase 只有一个针对行键的索引</p><p>访问 HBase 表中的行，只有三种方式：</p><ul><li>通过单个行键访问</li><li>通过一个行键的区间来访问</li><li>全表扫描</li></ul><p><strong>Hindex</strong> 二级索引是华为公司开发的纯 Java 编写的 HBase 二级索引</p><ul><li>多个表索引</li><li>多个列索引</li><li>基于部分列值的索引</li></ul><h2 id="Part-6-HBase-常用-Shell-命令"><a href="#Part-6-HBase-常用-Shell-命令" class="headerlink" title="Part 6 HBase  常用 Shell 命令"></a>Part 6 HBase  常用 Shell 命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 创建表</span><br>create<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 列出 HBase 中所有的表信息</span><br>list<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 向表、行、列指定的单元格添加数据</span><br>put<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 流览表的相关信息</span><br>scan<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 通过表名、行、列、时间戳、时间范围和版本号来获得相应单元格的值</span><br>get<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 使表有效或无效</span><br>enable/disable<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 删除表（对应表需要先处于 diabled 状态）</span><br>drop<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Big Data Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Notes - 240</title>
    <link href="/2021/09/01/LeetCode-Notes-240/"/>
    <url>/2021/09/01/LeetCode-Notes-240/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-Notes-240"><a href="#Leetcode-Notes-240" class="headerlink" title="Leetcode Notes - 240"></a>Leetcode Notes - 240</h1><p>题目：<strong>240. 搜索二维矩阵 II</strong></p><p>难度：<strong>中等</strong></p><p>遇见次数：<strong>第二次</strong></p><p>涉及知识点：</p><ul><li>二分查找</li><li>搜索二维矩阵</li><li>搜索二叉树</li></ul><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="1-错就对了！"><a href="#1-错就对了！" class="headerlink" title="1. 错就对了！"></a>1. 错就对了！</h3><p>暴力法的废物…二分写不出来，麻了😭</p><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210901230057218.png" alt="暴力遍历"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">searchMatrix</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> c = <span class="hljs-number">0</span>; c &lt; matrix[<span class="hljs-number">0</span>].length; c++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> r = <span class="hljs-number">0</span>; r &lt; matrix.length; r++)&#123;<br>                <span class="hljs-keyword">if</span>(matrix[r][c] == target) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="剪枝"><a href="#剪枝" class="headerlink" title="剪枝"></a>剪枝</h3><h4 id="思路及算法"><a href="#思路及算法" class="headerlink" title="思路及算法"></a>思路及算法</h4><p>并不是想不到这个方法，很重要一个弯没有转过来。</p><p>就是向左向右不能是同一个单调性，于是我们有——</p><ul><li>选左上角，往右走和往下走都增大，不能选</li><li>选右下角，往上走和往左走都减小，不能选</li><li>选左下角，往右走增大，往上走减小，可选</li><li>选右上角，往下走增大，往左走减小，可选</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">searchMatrix</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>        <span class="hljs-comment">// start our &quot;pointer&quot; in the bottom-left</span><br>        <span class="hljs-keyword">int</span> row = matrix.length-<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> col = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span> (row &gt;= <span class="hljs-number">0</span> &amp;&amp; col &lt; matrix[<span class="hljs-number">0</span>].length) &#123;<br>            <span class="hljs-keyword">if</span> (matrix[row][col] &gt; target) &#123;<br>                row--;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (matrix[row][col] &lt; target) &#123;<br>                col++;<br>            &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// found it</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Notes - 435</title>
    <link href="/2021/09/01/LeetCode-Notes-435/"/>
    <url>/2021/09/01/LeetCode-Notes-435/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-Notes-435"><a href="#Leetcode-Notes-435" class="headerlink" title="Leetcode Notes - 435"></a>Leetcode Notes - 435</h1><p>题目：<strong>435. 无重叠区间</strong></p><p>难度：<strong>中等</strong></p><p>遇见次数：<strong>第二次</strong></p><p>涉及知识点：</p><ul><li>DP</li><li>贪心</li></ul><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="一直错，哭了，不会贪"><a href="#一直错，哭了，不会贪" class="headerlink" title="一直错，哭了，不会贪"></a>一直错，哭了，不会贪</h3><p>理解题解后重写版本😭</p><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210901234654745.png" alt="贪心"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">eraseOverlapIntervals</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] intervals)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(intervals.length &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        Arrays.sort(intervals, <span class="hljs-keyword">new</span> Comparator&lt;<span class="hljs-keyword">int</span>[]&gt;()&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span> <span class="hljs-params">(<span class="hljs-keyword">int</span>[] v1, <span class="hljs-keyword">int</span>[] v2)</span></span>&#123;<br>                <span class="hljs-keyword">return</span> v1[<span class="hljs-number">1</span>] - v2[<span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;);<br><br>        <span class="hljs-keyword">int</span> best = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> minRight = intervals[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; intervals.length; i++)&#123;<br>            <span class="hljs-keyword">if</span>(intervals[i][<span class="hljs-number">0</span>] &gt;= minRight)&#123;<br>                best++;<br>                minRight = intervals[i][<span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> intervals.length - best;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h3><h4 id="思路及算法"><a href="#思路及算法" class="headerlink" title="思路及算法"></a>思路及算法</h4><p>我们可以不断地寻找右端点在首个区间右端点左侧的新区间，将首个区间替换成该区间。那么当我们无法替换时，首个区间就是所有可以选择的区间中右端点最小的那个区间。因此我们将所有区间按照右端点从小到大进行排序，那么排完序之后的首个区间，就是我们选择的首个区间。</p><p>如果有多个区间的右端点都同样最小怎么办？由于我们选择的是首个区间，因此在左侧不会有其它的区间，那么左端点在何处是不重要的，我们只要任意选择一个右端点最小的区间即可。</p><p>当确定了首个区间之后，所有与首个区间不重合的区间就组成了一个规模更小的子问题。由于我们已经在初始时将所有区间按照右端点排好序了，因此对于这个子问题，我们无需再次进行排序，只要找出其中与首个区间不重合并且右端点最小的区间即可。用相同的方法，我们可以依次确定后续的所有区间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">eraseOverlapIntervals</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] intervals)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (intervals.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <br>        Arrays.sort(intervals, <span class="hljs-keyword">new</span> Comparator&lt;<span class="hljs-keyword">int</span>[]&gt;() &#123;<br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] interval1, <span class="hljs-keyword">int</span>[] interval2)</span> </span>&#123;<br>                <span class="hljs-keyword">return</span> interval1[<span class="hljs-number">1</span>] - interval2[<span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;);<br><br>        <span class="hljs-keyword">int</span> n = intervals.length;<br>        <span class="hljs-keyword">int</span> right = intervals[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (intervals[i][<span class="hljs-number">0</span>] &gt;= right) &#123;<br>                ++ans;<br>                right = intervals[i][<span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> n - ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Big Data Intro - Chapter 3</title>
    <link href="/2021/09/01/Big-Data-Intro-Chapter-3/"/>
    <url>/2021/09/01/Big-Data-Intro-Chapter-3/</url>
    
    <content type="html"><![CDATA[<h1 id="第03章-Hive分布式数据仓库"><a href="#第03章-Hive分布式数据仓库" class="headerlink" title="第03章 Hive分布式数据仓库"></a>第03章 Hive分布式数据仓库</h1><h2 id="Part1-Hive概述"><a href="#Part1-Hive概述" class="headerlink" title="Part1 Hive概述"></a>Part1 Hive概述</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Hive是基于<strong>Hadoop</strong>的<strong>数据仓库软件</strong>，可以<strong>查询和管理PB级别</strong>的分布式数据</p><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ol><li>灵活方便的ETL</li><li>支持Tez，Spark等多种计算引擎</li><li>可直接访问HDFS文件以及HBase</li><li>易用易编程</li></ol><h3 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h3><ol><li><p>Hive构建在基于<strong>静态批处理的Hadoop</strong>之上，而Hadoop通常都有<strong>较高的延迟</strong>并且在作业提交和调度的时候<strong>需要大量的开销</strong></p></li><li><p>Hive并不能在大规模数据集上实现<strong>低延迟快速的查询</strong>，并不适合低时延需求的应用，如OLTP（联合事务处理）</p><blockquote><p>例如Hive在几百MB的数据集上执行查询一般有<strong>分钟级</strong>的时间延迟。</p></blockquote></li><li><p>Hive并不提供<strong>实时的查询</strong>和<strong>基于行级的数据更新操作</strong></p></li><li><p>Hive的最佳使用场景是<strong>打出聚集的批处理作业</strong>，例如网络日志分析</p></li></ol><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol><li>高可靠与高容错<ul><li>HiveServer采用集群模式</li><li>双MetaStore</li><li>超时重试机制</li></ul></li><li>类SQL<ul><li>类似SQL语法</li><li>内置大量函数</li></ul></li><li>可扩展<ul><li>自定义存储格式</li><li>自定义函数</li></ul></li><li>多接口<ul><li>Beeline - Hive的命令行客户端</li><li>JDBC</li><li>Thrift - 一种序列化、通信协议</li><li>ODBC - 基于C/C++的数据库标准接口</li></ul></li></ol><h2 id="Part-2-Hive功能与架构"><a href="#Part-2-Hive功能与架构" class="headerlink" title="Part 2 Hive功能与架构"></a>Part 2 Hive功能与架构</h2><h3 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h3><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210901211737923.png" alt="Hive架构图"></p><p>其中需要补充的有——</p><ul><li><p>Optimizer：优化器，分为<strong>逻辑优化器和物理优化器</strong></p><blockquote><p>分别对HQL生成的执行计划和MapReduce任务进行优化</p></blockquote></li><li><p>Thrift Server：提供<strong>thrift接口</strong>，作为JDBC/ODBC接口，为用户访问提供接口</p></li><li><p>Clients：包含命令行接口Beeline和JDBC/ODBC接口，为用户访问提供接口</p></li></ul><h3 id="运行流程"><a href="#运行流程" class="headerlink" title="运行流程"></a>运行流程</h3><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210901212804665.png" alt="Hive运行流程"></p><h3 id="数据存储模型"><a href="#数据存储模型" class="headerlink" title="数据存储模型"></a>数据存储模型</h3><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210901214238333.png" alt="Hive数据存储模型"></p><p>几个基本概念——</p><ul><li><p>数据库：对应 <strong>Schema</strong>，创建表时如果不指定数据库，则默认为<strong>default</strong>数据库</p></li><li><p>表：物理概念，实际对应HDFS上的一个<strong>目录</strong></p></li><li><p>分区：对应所在表所在目下的一个<strong>子目录</strong></p><ul><li>当表格数据量较大时，可对表格进行分区处理 (Partition)</li><li>这样便于局部数据的查询操作，如按时间分区、按地域分区，将具有相同性质的数据存储到同一磁盘块上，从而加快查询效率</li></ul></li><li><p>桶：对应表或分区所在路径的一个<strong>文件</strong></p><ul><li>Hive是针对某一列进行分桶</li><li>Hive采用对列值哈希，然后除以桶的个数求余的方式决定该条记录存放在哪个桶中</li><li>分桶的好处是可以获得更高的查询处理效率。使取样更高效<ul><li>分桶的应用场景：1）数据抽样 2）提升某些查询操作效率，如：mapside join</li></ul></li></ul></li><li><p>数据的<strong>倾斜和正常</strong>：</p><ul><li><strong>倾斜：</strong>数据集中于个别字段值的场景，比如按照城市分区时，80%的数据都来自某个大城市</li><li><strong>正常：</strong>不存在倾斜的数据</li></ul></li><li><p>Hive可以创建两种表<strong>托管表和外部表</strong></p><ul><li><p>创建Hive表，Hive会将数据移动到<strong>数据仓库目录</strong></p></li><li><p>选择规则——</p><ul><li>如果<strong>所有处理都由Hive完成</strong>，建议使用<strong>托管表</strong></li><li>如果<strong>要用Hive和其他工具来处理同一个数据集</strong>，建议使用<strong>外部表</strong></li></ul></li><li><p>两者主要区别——</p><ul><li><p>Hive 创建表时</p><blockquote><ol><li>创建内部表时，会<strong>将数据移动到数据仓库</strong>指向的路径</li><li>若创建外部表，仅<strong>记录数据所在的路径， 不对数据的位置</strong>做任何改变</li></ol></blockquote></li><li><p>Hive 删除表的时</p><blockquote><ol><li>内部表的元数据和数据会被一起删除</li><li>外部表只删除元数据，不删除数据</li><li>这样外部表相对来说更加安全些，数据组织也更加灵活，方便共享源数据</li></ol></blockquote></li></ul></li></ul></li></ul><h2 id="Part-3-Hive基本操作与使用"><a href="#Part-3-Hive基本操作与使用" class="headerlink" title="Part 3 Hive基本操作与使用"></a>Part 3 Hive基本操作与使用</h2><p>详见后续博客</p>]]></content>
    
    
    <categories>
      
      <category>Big Data Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Big Data Intro - Chapter 2</title>
    <link href="/2021/08/31/Big-Data-Intro-Chapter-2/"/>
    <url>/2021/08/31/Big-Data-Intro-Chapter-2/</url>
    
    <content type="html"><![CDATA[<h1 id="第02章-HDFS分布式文件系统和ZooKeeper"><a href="#第02章-HDFS分布式文件系统和ZooKeeper" class="headerlink" title="第02章 HDFS分布式文件系统和ZooKeeper"></a>第02章 HDFS分布式文件系统和ZooKeeper</h1><h2 id="Part-1-HDFS"><a href="#Part-1-HDFS" class="headerlink" title="Part 1 - HDFS"></a>Part 1 - HDFS</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>是一种旨在商品硬件上运行的<strong>分布式文件系统</strong></p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol><li>具有<strong>高容错能力</strong>，旨在部署在低成本硬件上</li><li>提供<strong>高吞吐量的访问</strong>，适用于具有<strong>大数据集</strong>的应用程序</li><li>放宽一些<strong>POSIX</strong>要求，以实现对文件系统数据的<strong>流式访问</strong></li></ol><h3 id="不适用场景"><a href="#不适用场景" class="headerlink" title="不适用场景"></a>不适用场景</h3><h4 id="1-低时间延迟数据访问的应用（例如几十毫秒的范围）"><a href="#1-低时间延迟数据访问的应用（例如几十毫秒的范围）" class="headerlink" title="1. 低时间延迟数据访问的应用（例如几十毫秒的范围）"></a>1. 低时间延迟数据访问的应用（例如几十毫秒的范围）</h4><p><strong>原因：</strong>HDFS是为高吞吐量应用优化的，这样做会造成以<strong>高时间延迟</strong>为代价</p><h4 id="2-大量小文件"><a href="#2-大量小文件" class="headerlink" title="2. 大量小文件"></a>2. 大量小文件</h4><p><strong>原因：</strong>NameNode启动时，将文件系统的元数据加载到内存，因此文件系统所能存储的文件总数受限于NameNode内存容量。根据经验，每个文件，目录和数据块的存储信息大约占150字节，如果一百万个文件，且每个文件占一个数据块，那至少需要300MB的内存空间，但是如果存储十亿个文件，那么需要的内存空间将是非常大的。</p><h4 id="3-多用户写入，任意修改文件"><a href="#3-多用户写入，任意修改文件" class="headerlink" title="3. 多用户写入，任意修改文件"></a>3. 多用户写入，任意修改文件</h4><p><strong>原因：</strong>现在HDFS文件只有一个writer，而且写操作总是写在文件的末尾。也不支持在文件的任意位置进行修改。可能以后会支持，但相对比较低效</p><h3 id="Block-块"><a href="#Block-块" class="headerlink" title="Block - 块"></a>Block - 块</h3><blockquote><p><strong>HDFS</strong> 默认一个块 <strong>128MB</strong> ,一个文件被分成多个块，以块作为存储单位</p></blockquote><p>块的大小远远大于普通文件系统，这可以<strong>最小化寻址开销</strong></p><p>抽象的块概念可以带来以下几个明显的好处——</p><ul><li>支持大规模文件存储<ul><li>文件可以被拆分</li><li>不会受到单个节点的存储容量限制</li></ul></li><li>简化系统设计<ul><li>简化了存储管理</li><li>方便了元数据的管理</li></ul></li><li>适合数据备份<ul><li>每个块都可以冗余存储</li><li>大大提高系统的容错性和可用性</li></ul></li></ul><h3 id="基本系统架构"><a href="#基本系统架构" class="headerlink" title="基本系统架构"></a>基本系统架构</h3><p>HDFS架构包含三个部分：NameNode，DataNode，Client</p><ul><li>NameNode：NameNode用于存储、生成文件系统的元数据。运行一个实例</li><li>DataNode：DataNode用于存储实际的数据，将自己管理的数据块上报给 NameNode ，运行多个实例</li><li>Client：支持业务访问HDFS，从NameNode ,DataNode获取数据返回给业务。多个 实例，和业务一起运行</li></ul><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210831144335072.png" alt="NameNode和DataNode的关系"></p><h4 id="NameNode-——-名称节点"><a href="#NameNode-——-名称节点" class="headerlink" title="NameNode —— 名称节点"></a>NameNode —— 名称节点</h4><p>在 <strong>NameNode</strong> 中，保存了两个核心的数据结构，分别是 <strong>FsImage</strong> 和 <strong>EditLog</strong></p><ul><li><strong>FsImage</strong> 用于维护<ul><li>文件系统树</li><li>文件树中所有的文件和文件夹的元数据</li></ul></li><li>操作日志文件 <strong>EditLog</strong> 中记录了所有针对文件的创建、删除、重命名等操作</li></ul><p><strong>NameNode</strong> 还记录了每个文件中各个块所在的<strong>数据节点的位置信息</strong></p><h4 id="DataNode-——-数据节点"><a href="#DataNode-——-数据节点" class="headerlink" title="DataNode —— 数据节点"></a>DataNode —— 数据节点</h4><p>数据节点是HDFS的<strong>工作节点</strong>——负责数据的存储和读取</p><ul><li>根据 <strong>Client</strong> 或者 <strong>NameNode</strong> 的调度来进行数据的存储和检索</li><li>定期向 <strong>NameNode</strong> 发送自己所存储的块的列表</li></ul><p>每个数据节点中的数据会被保存在各自节点的本地Linux文件系统中</p><h3 id="HDFS-命名空间管理"><a href="#HDFS-命名空间管理" class="headerlink" title="HDFS 命名空间管理"></a>HDFS 命名空间管理</h3><p>首先，HDFS的命名空间包含目录、文件和块</p><p>其次，HDFS使用的是传统的<strong>分级文件体系</strong></p><p>最后，由 <strong>NameNode</strong> 负责维护文件系统命名空间</p><blockquote><p>对文件系统命名空间或其属性的任何更改均由 <strong>NameNode</strong> 记录</p></blockquote><h3 id="通信协议"><a href="#通信协议" class="headerlink" title="通信协议"></a>通信协议</h3><p>所有的HDFS通信协议都是构建在 <strong>TCP/IP</strong> 协议基础之上</p><p><strong>NN</strong> 和 <strong>DN</strong> 之间通过数据节点协议来进行交互</p><p><strong>Client</strong> 与 <strong>NN 和 DN</strong> 之间的交互是不同的——</p><ul><li>与 <strong>NN</strong> 进行交互是通过向 <strong>NN</strong> 主动发起 TCP 链接，并使用客户端协议与名称节点进行交互</li><li>与 <strong>DN</strong> 是通过<strong>RPC（Remote Procedure Call）</strong> 来实现的。</li></ul><p><strong>NameNode</strong> 不会主动发起 RPC，而是响应来自 <strong>DataNode</strong> 和 <strong>Client</strong> 的 RPC 请求</p><h3 id="单名称节点体系结构的局限性"><a href="#单名称节点体系结构的局限性" class="headerlink" title="单名称节点体系结构的局限性"></a>单名称节点体系结构的局限性</h3><p>HDFS 值设置唯一一个名称节点，虽然可以简化系统设计，但是会带来一些明显的局限</p><ol><li><p>命名空间的限制</p></li><li><p>性能的瓶颈</p></li><li><p>隔离问题</p></li><li><p>集群的可用性</p></li></ol><h3 id="HDFS的一些关键特性"><a href="#HDFS的一些关键特性" class="headerlink" title="HDFS的一些关键特性"></a>HDFS的一些关键特性</h3><h4 id="1-HA-——-高可用性"><a href="#1-HA-——-高可用性" class="headerlink" title="1. HA —— 高可用性"></a>1. HA —— 高可用性</h4><p>Hadoop 2.x 才推出的新特性，主要体现在利用 <strong>zookeeper</strong> 实现主备 <strong>NameNode</strong> ，来解决单点 <strong>NameNode</strong> 的故障问题</p><p>由此，我们引出 <strong>Zookeeper</strong> 的一个主要作用——</p><blockquote><p>用来存储 <strong>HA</strong> 下的状态文件，主备信息</p></blockquote><p>其中，由 <strong>ZKFC（Zookeeper Failover Controller）</strong> 用于监控 <strong>NN</strong> 结点的主备状态</p><blockquote><p><strong>ZKFC</strong> 还控制 <strong>NN</strong> 主备仲裁，两者部署在一起，个数相同</p><ul><li>利用 <strong>Zookeeper</strong> 的分布式锁功能，实现 <strong>主备仲裁</strong></li><li>再通过命令通道，控制 <strong>NN</strong> 的主备状态</li></ul></blockquote><p><strong>JN（Journal Node）</strong> 用于存储 <strong>Active NN（主 NN）</strong>生成的 <strong>Editlog</strong>。由 <strong>Standby NN</strong> 加载 <strong>JN</strong> 上 <strong>Editlog</strong> ,同步元数据</p><h4 id="2-HDFS-Federation"><a href="#2-HDFS-Federation" class="headerlink" title="2. HDFS Federation"></a>2. HDFS Federation</h4><p>即利用 **多个 NN ** 来组成命名空间，且互相之间是独立的，两两之间并不互相通信，单个失效也不会影响其他。简单理解为——</p><blockquote><p>各 <strong>NameNode</strong> 负责自己所属的目录。与Linux挂载磁盘到目录类似， 此时每个 <strong>NameNode</strong> 只负责整个hdfs集群中部分目录。</p><p>如NameNode1负责/database目录，那么在/database目录下的文件元数据都由NameNode1负责。各NameNode间元数据不共享，每个NameNode都有对应的standby。</p></blockquote><p>属于某一命名空间，即 <strong>Namespace</strong> ，的一组数据块，称为 <strong>Block Pool</strong></p><p>在 <strong>联邦</strong> 环境下，每个 <strong>NN</strong> 维护一个 <strong>Namespace Volume</strong> ，包括——</p><ul><li><strong>NS</strong> 的元数据</li><li>在该空间下的文件的所有数据块的 <strong>BP</strong></li></ul><h4 id="3-数据副本机制"><a href="#3-数据副本机制" class="headerlink" title="3. 数据副本机制"></a>3. 数据副本机制</h4><p>副本距离计算公式：</p><ul><li>Distance(Rack1/D1, Rack1/D1)=0</li><li>同一台服务器的距离为0</li><li>Distance(Rack1/D1, Rack1/D3)=2</li><li>同一机架不同的服务器距离为2</li><li>Distance(Rack1/D1, Rack2/D1)=4</li><li>不同机架的服务器距离为4</li><li>不同数据中心的节点距离为6。</li></ul><p>副本放置策略</p><ul><li>第一个副本：放置在上传文件的数据节点；如果是集群外提交，则随机挑选一台磁盘 不太满、CPU不太忙的节点</li><li>第二个副本：放置在与第一个副本不同的机架的节点上</li><li>第三个副本：与第一个副本相同机架的其他节点上</li><li>更多副本：随机节点</li></ul><p>如果写请求方所在机器是其中一个DataNode,则直接存放在本地,否则随机在集群中选择一 个DataNode</p><ul><li>Rack1：表示机架1</li><li>D1：表示DataNode节点1</li><li>B1：表示节点上的block块1</li></ul><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210831152858662.png" alt="数据副本机制"></p><h4 id="4-HDFS-数据完整性保障"><a href="#4-HDFS-数据完整性保障" class="headerlink" title="4. HDFS 数据完整性保障"></a>4. HDFS 数据完整性保障</h4><p>HDFS主要目的是<strong>保证存储数据完整性</strong>，对于各组件的失效，做了可靠性处理——</p><ul><li>重建失效数据盘的副本数据<ul><li>DataNode与NameNode之间通过心跳周期汇报数据状态，NameNode管理数据块是否上报完整</li><li>如果DataNode因硬盘损坏未上报数据块，NameNode将发起副本重建动作以恢复丢失的副本。</li></ul></li><li>集群数据均衡<ul><li>HDFS架构设计了<strong>数据均衡机制</strong>，该机制保证数据在各个 <strong>DataNode</strong> 上分布式平均的</li></ul></li><li>元数据可靠性保证<ul><li>采用日志机制操作元数据，同时元数据存放在主备 <strong>NameNode</strong> 上</li><li>快照机制实现了文件系统常见的快照机制，保证数据误操作时，能及时恢复</li></ul></li><li>安全模式防止故障扩散<ul><li>当节点硬盘故障时，进入安全模式，HDFS只支持访问元数据，此时HDFS上的数据是只读的，其他的操作如创建、删除文件等操作都会导致失败。</li><li>待硬盘问题解决、数据恢复后，再退出安全模式。</li></ul></li></ul><h4 id="5-HDFS架构其他关键设计要点说明"><a href="#5-HDFS架构其他关键设计要点说明" class="headerlink" title="5. HDFS架构其他关键设计要点说明"></a>5. HDFS架构其他关键设计要点说明</h4><ul><li>空间回收机制<ul><li>支持回收站机制以及副本数的动态设置机制</li></ul></li><li>数据组织<ul><li>数据存储以<strong>数据块</strong>为单位，存储在操作系统的HDFS文件系统上</li></ul></li><li>访问方式<ul><li>提供 <strong>JAVA API，HTTP 方式，SHELL 方式</strong> 访问HDFS数据</li></ul></li></ul><h3 id="HDFS-3-0-新特性总结"><a href="#HDFS-3-0-新特性总结" class="headerlink" title="HDFS 3.0 新特性总结"></a>HDFS 3.0 新特性总结</h3><ol><li><p>支持 HDFS 中的纠删码 <strong>Erasure Encoding</strong></p><blockquote><ul><li>通过在原始数据中加入新的校验数据,使得各个部分的数据产生关联性，在一定范围的数据出错情况下，通过纠删码技术都可以进行恢复。EC技术可以防止数据丢失，又可以解决HDFS存储空间翻倍的问题</li><li>创建文件时，将从最近的祖先目录继承EC策略，以确定其块如何存储。与3路复制相比，默认的EC策略可以节省50％的存储空间，同时还可以承受更多的存储故障</li><li>建议EC存储用于冷数据，由于冷数据确实数量大，可以减少副本从而降低存储空间， 另外冷数据稳定，一旦需要恢复数据，对业务不会有太大影响。</li></ul></blockquote></li><li><p>基于 HDFS 路由器的联合</p></li><li><p>支持多个 NameNode</p></li><li><p>DataNode 内部添加了负载均衡 Disk Balancer</p></li></ol><h3 id="HDFS-数据读写流程"><a href="#HDFS-数据读写流程" class="headerlink" title="HDFS 数据读写流程"></a>HDFS 数据读写流程</h3><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210831160054496.png" alt="HDFS 数据写入流程"></p><p>HDFS数据写入流程如下：</p><ul><li>业务应用调用HDFS Client提供的API，请求写入文件</li><li>HDFS Client联系NameNode，NameNode在元数据中创建文件节点</li><li>业务应用调用write API写入文件</li><li>HDFS Client收到业务数据后，从NameNode获取到数据块编号、位置信息后，联系 DataNode，并将需要写入数据的DataNode建立起流水线。完成后，客户端再通过 自有协议写入数据到DataNode1，再由DataNode1复制到DataNode2, DataNode3</li><li>写完的数据，将返回确认信息给HDFS Client</li><li>所有数据确认完成后，业务调用HDFS Client关闭文件</li><li>业务调用close, flush后HDFS Client联系NameNode，确认数据写完成，NameNode 持久化元数据</li></ul><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210831160131833.png" alt="HDFS 读取流程"></p><p>HDFS数据读取流程如下：</p><ul><li>业务应用调用HDFS Client提供的API打开文件</li><li>HDFS Client联系NameNode，获取到文件信息（数据块、DataNode位置信息）</li><li>业务应用调用read API读取文件</li><li>HDFS Client根据从NameNode获取到的信息，联系DataNode，获取相应的数据块。 (Client采用就近原则读取数据)</li><li>HDFS Client会与多个DataNode通讯获取数据块</li><li>数据读取完成后，业务调用close关闭连接</li></ul><h2 id="Part-2-ZooKeeper"><a href="#Part-2-ZooKeeper" class="headerlink" title="Part 2 - ZooKeeper"></a>Part 2 - ZooKeeper</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>主要是用来解决分布式应用中经常遇到的一些数据管理问题，提供分布式、高可用性的协调服务能力。</p><p>总体分为<strong>安全模式</strong>以及<strong>非安全模式</strong>——</p><ul><li>安全模式下依赖于 <strong>Kerberos</strong> 和 <strong>LdapServer</strong> 进行安全认证</li><li>非安全模式下则不依赖</li></ul><p><strong>ZK</strong> 作为底层组件广泛被上层组件使用并依赖，如 <strong>Kafka，HDFS，HBase，Storm</strong>等</p><h3 id="体系架构"><a href="#体系架构" class="headerlink" title="体系架构"></a>体系架构</h3><p>ZooKeeper 集群由一组 Server 节点组成，这一组 Server 节点中存在一个角色为 Leader 的节点， 其他节点都为 Follower，Leader 在启动时选举出。</p><blockquote><p>选举方式，对于 n 个实例的服务，n 可能为奇数或偶数：</p><ul><li>当有 <strong>n = 2x + 1</strong> 个节点时，则成为 <strong>Leader</strong> 的节点需要获得 <strong>x + 1</strong> 票，容灾能力为 <strong>x</strong></li><li>当有 <strong>n = 2x + 2</strong> 个节点时，则成为 <strong>Leader</strong> 的节点需要获得 <strong>x + 2</strong> 票（大于一半），容灾能力为 <strong>x</strong></li></ul></blockquote><p>ZooKeeper 使用了一种自定义的原子消息协议（ZooKeeper Atomic Broadcast Zab协议）， 在消息层的这种原子特性，保证了整个协调系统中的节点数据或状态的一致性。</p><p>Leader节点在接收到数据变更请求后，首先将变更写入本地磁盘，以作恢复之用。当所有 的写请求持久化到磁盘以后，才会将变更应用到内存中。</p><p>当客户端 Client 连接到 ZooKeeper 集群，并且执行写请求时，这些请求会被发送到 Leader 节点上，然后 Leader 节点上数据变更会同步到集群中其他的 Follower 节点。</p><h3 id="关键特性"><a href="#关键特性" class="headerlink" title="关键特性"></a>关键特性</h3><h4 id="1-最终一致性"><a href="#1-最终一致性" class="headerlink" title="1. 最终一致性"></a>1. 最终一致性</h4><p>无论哪个 server，对外展示的均是同一视图</p><h4 id="2-实时性"><a href="#2-实时性" class="headerlink" title="2. 实时性"></a>2. 实时性</h4><p>保证客户端将在一个时间间隔范围内获得服务器的更新信息，或者服务器失效的信息</p><h4 id="3-可靠性"><a href="#3-可靠性" class="headerlink" title="3. 可靠性"></a>3. 可靠性</h4><p>一条消息被一个 server 接收，它将被所有 server 接受</p><h4 id="4-等待无关性"><a href="#4-等待无关性" class="headerlink" title="4. 等待无关性"></a>4. 等待无关性</h4><p>慢的或者失效的 client 不会干预快速的 client 的请求，使得每个 client 都能有有效的等待</p><h4 id="5-原子性"><a href="#5-原子性" class="headerlink" title="5. 原子性"></a>5. 原子性</h4><p>更新只能成功或者失败，没有中间态</p><h4 id="6-顺序一致性"><a href="#6-顺序一致性" class="headerlink" title="6. 顺序一致性"></a>6. 顺序一致性</h4><p>客户端所发送的更新会按照他们被发送的顺序进行应用</p><h3 id="ZooKeeper-的读写特性"><a href="#ZooKeeper-的读写特性" class="headerlink" title="ZooKeeper 的读写特性"></a>ZooKeeper 的读写特性</h3><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210831163621689.png" alt="ZK的读操作"></p><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210831163648575.png" alt="ZK的写操作"></p>]]></content>
    
    
    <categories>
      
      <category>Big Data Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Notes - 59</title>
    <link href="/2021/08/31/LeetCode-Notes-59/"/>
    <url>/2021/08/31/LeetCode-Notes-59/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-Notes-59"><a href="#Leetcode-Notes-59" class="headerlink" title="Leetcode Notes - 59"></a>Leetcode Notes - 59</h1><p>题目：<strong>59. 螺旋矩阵 II</strong></p><p>难度：<strong>中等</strong></p><p>遇见次数：<strong>第二次</strong></p><p>涉及知识点：</p><ul><li>二维数组</li><li>模拟</li></ul><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="1-四指针"><a href="#1-四指针" class="headerlink" title="1. 四指针"></a>1. 四指针</h3><p>太！爽！啦！《关于我写出以前没写出来的题还优于题解这回事》🛫</p><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210831125303137.png" alt="四指针"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[][] generateMatrix(<span class="hljs-keyword">int</span> n) &#123;<br>        <span class="hljs-keyword">int</span>[][] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n][n];<br>        <br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> right = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> top = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> bottom = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> count = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(left &lt;= right &amp;&amp; top &lt;= bottom)&#123;<br>            <span class="hljs-comment">// left 2 right</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> l2r = left; l2r &lt; right; l2r++)&#123;<br>                res[top][l2r] = count;<br>                count++;<br>            &#125;<br><br>            <span class="hljs-comment">// top 2 bottom</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> t2b = top; t2b &lt; bottom; t2b++)&#123;<br>                res[t2b][right] = count;<br>                count++;<br>            &#125;<br><br>            <span class="hljs-comment">// right 2 left</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> r2l = right; r2l &gt; left; r2l--)&#123;<br>                res[bottom][r2l] = count;<br>                count++;<br>            &#125;<br><br>            <span class="hljs-comment">// bottom 2 top</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> b2t = bottom; b2t &gt; top; b2t--)&#123;<br>                res[b2t][left] = count;<br>                count++;<br>            &#125;<br><br>            left++;<br>            right--;<br>            top++;<br>            bottom--;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(n % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) res[(n - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>][(n - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>] = n * n;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h3><h4 id="思路及算法"><a href="#思路及算法" class="headerlink" title="思路及算法"></a>思路及算法</h4><p>模拟矩阵的生成。按照要求，初始位置设为矩阵的左上角，初始方向设为向右。若下一步的位置超出矩阵边界，或者是之前访问过的位置，则顺时针旋转，进入下一个方向。如此反复直至填入 <code>n^2</code> 个元素。</p><p>记 <code>matrix</code> 为生成的矩阵，其初始元素设为 0。由于填入的元素均为正数，我们可以判断当前位置的元素值，若不为 0，则说明已经访问过此位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[][] generateMatrix(<span class="hljs-keyword">int</span> n) &#123;<br>        <span class="hljs-keyword">int</span> maxNum = n * n;<br>        <span class="hljs-keyword">int</span> curNum = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span>[][] matrix = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n][n];<br>        <span class="hljs-keyword">int</span> row = <span class="hljs-number">0</span>, column = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span>[][] directions = &#123;&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;&#125;; <span class="hljs-comment">// 右下左上</span><br>        <span class="hljs-keyword">int</span> directionIndex = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (curNum &lt;= maxNum) &#123;<br>            matrix[row][column] = curNum;<br>            curNum++;<br>            <span class="hljs-keyword">int</span> nextRow = row + directions[directionIndex][<span class="hljs-number">0</span>], nextColumn = column + directions[directionIndex][<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (nextRow &lt; <span class="hljs-number">0</span> || nextRow &gt;= n || nextColumn &lt; <span class="hljs-number">0</span> || nextColumn &gt;= n || matrix[nextRow][nextColumn] != <span class="hljs-number">0</span>) &#123;<br>                directionIndex = (directionIndex + <span class="hljs-number">1</span>) % <span class="hljs-number">4</span>; <span class="hljs-comment">// 顺时针旋转至下一个方向</span><br>            &#125;<br>            row = row + directions[directionIndex][<span class="hljs-number">0</span>];<br>            column = column + directions[directionIndex][<span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> matrix;<br>    &#125;<br>&#125;<br><br>作者：LeetCode-Solution<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/spiral-matrix-ii/solution/luo-xuan-ju-zhen-ii-by-leetcode-solution-f7fp/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><blockquote><p>四指针就是按层模拟，这里学习一下模拟的做法</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Leetcode Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Notes - 48</title>
    <link href="/2021/08/31/LeetCode-Notes-48/"/>
    <url>/2021/08/31/LeetCode-Notes-48/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-Notes-48"><a href="#Leetcode-Notes-48" class="headerlink" title="Leetcode Notes - 48"></a>Leetcode Notes - 48</h1><p>题目：<strong>48. 旋转图像</strong></p><p>难度：<strong>中等</strong></p><p>遇见次数：<strong>第二次</strong></p><p>涉及知识点：</p><ul><li>二维数组</li><li>对角线反转</li></ul><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="1-两次翻转"><a href="#1-两次翻转" class="headerlink" title="1. 两次翻转"></a>1. 两次翻转</h3><p>不擦！一不小心就优于题解了呗🛫</p><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210831123212779.png" alt="两次翻转"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(matrix.length == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">int</span> column = matrix[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-keyword">int</span> row = matrix.length;<br><br>        <span class="hljs-comment">// Horizental rotation</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> hColumn = <span class="hljs-number">0</span>; hColumn &lt; column; hColumn++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> hRow = <span class="hljs-number">0</span>; hRow &lt; row / <span class="hljs-number">2</span>; hRow++)&#123;<br>                <span class="hljs-keyword">int</span> tmp = matrix[hRow][hColumn];<br>                matrix[hRow][hColumn] = matrix[row - hRow - <span class="hljs-number">1</span>][hColumn];<br>                matrix[row - hRow - <span class="hljs-number">1</span>][hColumn] = tmp;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// Main cross line rotation</span><br>        <span class="hljs-keyword">int</span> mcColumn = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> mcRow = <span class="hljs-number">0</span>; mcRow &lt; row; mcRow++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = mcColumn; i &lt; column; i++)&#123;<br>                <span class="hljs-keyword">int</span> tmp = matrix[mcRow][i];<br>                matrix[mcRow][i] = matrix[i][mcRow];<br>                matrix[i][mcRow] = tmp;<br>            &#125;<br>            mcColumn++;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="用翻转代替旋转"><a href="#用翻转代替旋转" class="headerlink" title="用翻转代替旋转"></a>用翻转代替旋转</h3><h4 id="思路及算法"><a href="#思路及算法" class="headerlink" title="思路及算法"></a>思路及算法</h4><p>一样啦，只是把竖直改成水平</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = matrix.length;<br>        <span class="hljs-comment">// 水平翻转</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n / <span class="hljs-number">2</span>; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>                <span class="hljs-keyword">int</span> temp = matrix[i][j];<br>                matrix[i][j] = matrix[n - i - <span class="hljs-number">1</span>][j];<br>                matrix[n - i - <span class="hljs-number">1</span>][j] = temp;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 主对角线翻转</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; ++j) &#123;<br>                <span class="hljs-keyword">int</span> temp = matrix[i][j];<br>                matrix[i][j] = matrix[j][i];<br>                matrix[j][i] = temp;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br>作者：LeetCode-Solution<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/rotate-image/solution/xuan-zhuan-tu-xiang-by-leetcode-solution-vu3m/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Notes - 118</title>
    <link href="/2021/08/31/LeetCode-Notes-118/"/>
    <url>/2021/08/31/LeetCode-Notes-118/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-Notes-118"><a href="#Leetcode-Notes-118" class="headerlink" title="Leetcode Notes - 118"></a>Leetcode Notes - 118</h1><p>题目：<strong>118. 杨辉三角</strong></p><p>难度：<strong>简单</strong></p><p>遇见次数：<strong>第二次</strong></p><p>涉及知识点：</p><ul><li>数学</li><li>线性递推</li></ul><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><p>所谓显式队列😅</p><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210831121026373.png" alt="队列迭代"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">getRow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> rowIndex)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(rowIndex == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;(Arrays.asList(<span class="hljs-number">1</span>)); <br><br>        LinkedList&lt;Integer&gt; doQue = <span class="hljs-keyword">new</span> LinkedList&lt;Integer&gt;();<br>        doQue.offerLast(<span class="hljs-number">0</span>);<br>        doQue.offerLast(<span class="hljs-number">1</span>);<br>        doQue.offerLast(<span class="hljs-number">0</span>);<br><br>        <span class="hljs-keyword">int</span> curIndex = <span class="hljs-number">0</span>;<br>        List&lt;Integer&gt; curList = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br><br>        <span class="hljs-keyword">while</span>(curIndex &lt; rowIndex)&#123;<br>            curList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>            <span class="hljs-keyword">int</span> len = doQue.size();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len - <span class="hljs-number">1</span>; i++)&#123;<br>                <span class="hljs-keyword">int</span> tmp = doQue.poll();<br>                tmp = tmp + doQue.peek();<br>                curList.add(tmp);<br>            &#125;<br><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> ele : curList)&#123;<br>                doQue.offerLast(ele);<br>            &#125;<br>            doQue.offerLast(<span class="hljs-number">0</span>);<br><br>            curIndex++;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> curList;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="数学-线性递推"><a href="#数学-线性递推" class="headerlink" title="数学 - 线性递推"></a>数学 - 线性递推</h3><p>由组合数公式我们，可以得到同一行的相邻组合数的关系——</p><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210831121305506.png" alt="组合数公式"></p><p>利用上述公式我们可以在线性时间计算出第 n 行的所有组合数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">getRow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> rowIndex)</span> </span>&#123;<br>        List&lt;Integer&gt; row = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>        row.add(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= rowIndex; ++i) &#123;<br>            row.add((<span class="hljs-keyword">int</span>) ((<span class="hljs-keyword">long</span>) row.get(i - <span class="hljs-number">1</span>) * (rowIndex - i + <span class="hljs-number">1</span>) / i));<br>        &#125;<br>        <span class="hljs-keyword">return</span> row;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Notes - 706</title>
    <link href="/2021/08/31/LeetCode-Notes-706/"/>
    <url>/2021/08/31/LeetCode-Notes-706/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-Notes-706"><a href="#Leetcode-Notes-706" class="headerlink" title="Leetcode Notes - 706"></a>Leetcode Notes - 706</h1><p>题目：<strong>706. 设计哈希映射</strong></p><p>难度：<strong>简单</strong></p><p>遇见次数：<strong>第二次</strong></p><p>涉及知识点：</p><ul><li>哈希映射</li><li>链地址法</li></ul><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="1-链地址法"><a href="#1-链地址法" class="headerlink" title="1. 链地址法"></a>1. 链地址法</h3><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210831003333051.png" alt="双链表对应"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyHashMap</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> BASE = <span class="hljs-number">769</span>;<br>    <span class="hljs-keyword">private</span> LinkedList[][] data;<br><br>    <span class="hljs-comment">/** Initialize your data structure here. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyHashMap</span><span class="hljs-params">()</span> </span>&#123;<br>        data = <span class="hljs-keyword">new</span> LinkedList[BASE][<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; BASE; ++i) &#123;<br>            data[i][<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> LinkedList&lt;Integer&gt;();<br>            data[i][<span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> LinkedList&lt;Integer&gt;();<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">/** value will always be non-negative. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> h = hash(key);<br>        LinkedList keyList = <span class="hljs-keyword">this</span>.data[h][<span class="hljs-number">0</span>];<br>        LinkedList valueList = <span class="hljs-keyword">this</span>.data[h][<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; keyList.size(); i++)&#123;<br>            Integer curKey = (<span class="hljs-keyword">int</span>) keyList.get(i);<br>            <span class="hljs-keyword">if</span>(curKey == key)&#123;<br>                valueList.set(i, value);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">this</span>.data[h][<span class="hljs-number">0</span>].offerLast(key);<br>        <span class="hljs-keyword">this</span>.data[h][<span class="hljs-number">1</span>].offerLast(value);<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> h = hash(key);<br>        LinkedList keyList = <span class="hljs-keyword">this</span>.data[h][<span class="hljs-number">0</span>];<br>        LinkedList valueList = <span class="hljs-keyword">this</span>.data[h][<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; keyList.size(); i++)&#123;<br>            Integer curKey = (<span class="hljs-keyword">int</span>) keyList.get(i);<br>            <span class="hljs-keyword">if</span>(curKey == key)&#123;<br>                <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>) valueList.get(i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Removes the mapping of the specified value key if this map contains a mapping for the key */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> h = hash(key);<br>        LinkedList keyList = <span class="hljs-keyword">this</span>.data[h][<span class="hljs-number">0</span>];<br>        LinkedList valueList = <span class="hljs-keyword">this</span>.data[h][<span class="hljs-number">1</span>];<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; keyList.size(); i++)&#123;<br>            Integer curKey = (<span class="hljs-keyword">int</span>) keyList.get(i);<br>            <span class="hljs-keyword">if</span>(curKey == key)&#123;<br>                keyList.remove(curKey);<br>                valueList.remove(valueList.get(i));<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> key % BASE;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MyHashMap object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MyHashMap obj = new MyHashMap();</span><br><span class="hljs-comment"> * obj.put(key,value);</span><br><span class="hljs-comment"> * int param_2 = obj.get(key);</span><br><span class="hljs-comment"> * obj.remove(key);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="链地址法"><a href="#链地址法" class="headerlink" title="链地址法"></a>链地址法</h3><h4 id="思路及算法"><a href="#思路及算法" class="headerlink" title="思路及算法"></a>思路及算法</h4><p>官方题解利用了内部私有类，定义了 <code>Pair</code> 来完成 <code>&#123;key, value&#125;</code> 的对应</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyHashMap</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pair</span> </span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> key;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> value;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Pair</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.key = key;<br>            <span class="hljs-keyword">this</span>.value = value;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getKey</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> key;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getValue</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> value;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setValue</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.value = value;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> BASE = <span class="hljs-number">769</span>;<br>    <span class="hljs-keyword">private</span> LinkedList[] data;<br><br>    <span class="hljs-comment">/** Initialize your data structure here. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyHashMap</span><span class="hljs-params">()</span> </span>&#123;<br>        data = <span class="hljs-keyword">new</span> LinkedList[BASE];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; BASE; ++i) &#123;<br>            data[i] = <span class="hljs-keyword">new</span> LinkedList&lt;Pair&gt;();<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">/** value will always be non-negative. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> h = hash(key);<br>        Iterator&lt;Pair&gt; iterator = data[h].iterator();<br>        <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>            Pair pair = iterator.next();<br>            <span class="hljs-keyword">if</span> (pair.getKey() == key) &#123;<br>                pair.setValue(value);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>        data[h].offerLast(<span class="hljs-keyword">new</span> Pair(key, value));<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> h = hash(key);<br>        Iterator&lt;Pair&gt; iterator = data[h].iterator();<br>        <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>            Pair pair = iterator.next();<br>            <span class="hljs-keyword">if</span> (pair.getKey() == key) &#123;<br>                <span class="hljs-keyword">return</span> pair.value;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Removes the mapping of the specified value key if this map contains a mapping for the key */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> h = hash(key);<br>        Iterator&lt;Pair&gt; iterator = data[h].iterator();<br>        <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>            Pair pair = iterator.next();<br>            <span class="hljs-keyword">if</span> (pair.key == key) &#123;<br>                data[h].remove(pair);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> key % BASE;<br>    &#125;<br>&#125;<br><br>作者：LeetCode-Solution<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/design-hashmap/solution/she-ji-ha-xi-ying-she-by-leetcode-soluti-klu9/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Notes - 705</title>
    <link href="/2021/08/31/LeetCode-Notes-705/"/>
    <url>/2021/08/31/LeetCode-Notes-705/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-Notes-705"><a href="#Leetcode-Notes-705" class="headerlink" title="Leetcode Notes - 705"></a>Leetcode Notes - 705</h1><p>题目：<strong>705. 设计哈希集合</strong></p><p>难度：<strong>简单</strong></p><p>遇见次数：<strong>第一次</strong></p><p>涉及知识点：</p><ul><li>哈希映射实现</li><li>哈希函数</li><li>链地址法</li></ul><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="1-链地址法"><a href="#1-链地址法" class="headerlink" title="1. 链地址法"></a>1. 链地址法</h3><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210831001654888.png" alt="链地址法"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyHashSet</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> BASE = <span class="hljs-number">769</span>;<br>    <span class="hljs-keyword">private</span> LinkedList[] dataArr;<br><br>    <span class="hljs-comment">/** Initialize your data structure here. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyHashSet</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.dataArr = <span class="hljs-keyword">new</span> LinkedList[BASE];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; BASE; i++)&#123;<br>            <span class="hljs-keyword">this</span>.dataArr[i] = <span class="hljs-keyword">new</span> LinkedList&lt;Integer&gt;();<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> h = <span class="hljs-keyword">this</span>.hash(key);<br><br>        Iterator&lt;Integer&gt; cur = <span class="hljs-keyword">this</span>.dataArr[h].iterator();<br>        <span class="hljs-keyword">while</span>(cur.hasNext())&#123;<br>            Integer ele = cur.next();<br>            <span class="hljs-keyword">if</span>(ele == key)&#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">this</span>.dataArr[h].offerLast(key);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> h = <span class="hljs-keyword">this</span>.hash(key);<br><br>        Iterator&lt;Integer&gt; cur = <span class="hljs-keyword">this</span>.dataArr[h].iterator();<br>        <span class="hljs-keyword">while</span>(cur.hasNext())&#123;<br>            Integer ele = cur.next();<br>            <span class="hljs-keyword">if</span>(ele == key)&#123;<br>                <span class="hljs-keyword">this</span>.dataArr[h].remove(ele);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Returns true if this set contains the specified element */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">contains</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> h = <span class="hljs-keyword">this</span>.hash(key);<br><br>        Iterator&lt;Integer&gt; cur = <span class="hljs-keyword">this</span>.dataArr[h].iterator();<br>        <span class="hljs-keyword">while</span>(cur.hasNext())&#123;<br>            Integer ele = cur.next();<br>            <span class="hljs-keyword">if</span>(ele == key)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> val % BASE;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MyHashSet object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MyHashSet obj = new MyHashSet();</span><br><span class="hljs-comment"> * obj.add(key);</span><br><span class="hljs-comment"> * obj.remove(key);</span><br><span class="hljs-comment"> * boolean param_3 = obj.contains(key);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="链地址法"><a href="#链地址法" class="headerlink" title="链地址法"></a>链地址法</h3><h4 id="思路及算法"><a href="#思路及算法" class="headerlink" title="思路及算法"></a>思路及算法</h4><p>设哈希表的大小为 <code>base</code>，则可以设计一个简单的哈希函数：<code>hash(x) = x mod base</code>。</p><p>我们开辟一个大小为 <code>base</code> 的数组，数组的每个位置是一个链表。当计算出哈希值之后，就插入到对应位置的链表当中。</p><p>由于我们使用整数除法作为哈希函数，为了尽可能避免冲突，应当将 \textit{base}base 取为一个质数。在这里，我们取 <code>base = 769</code>。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tL0ZpZ3VyZXMvNzA1LzcwNV9saW5rZWRfbGlzdC5wbmc?x-oss-process=image/format,png" alt="fig"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyHashSet</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> BASE = <span class="hljs-number">769</span>;<br>    <span class="hljs-keyword">private</span> LinkedList[] data;<br><br>    <span class="hljs-comment">/** Initialize your data structure here. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyHashSet</span><span class="hljs-params">()</span> </span>&#123;<br>        data = <span class="hljs-keyword">new</span> LinkedList[BASE];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; BASE; ++i) &#123;<br>            data[i] = <span class="hljs-keyword">new</span> LinkedList&lt;Integer&gt;();<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> h = hash(key);<br>        Iterator&lt;Integer&gt; iterator = data[h].iterator();<br>        <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>            Integer element = iterator.next();<br>            <span class="hljs-keyword">if</span> (element == key) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>        data[h].offerLast(key);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> h = hash(key);<br>        Iterator&lt;Integer&gt; iterator = data[h].iterator();<br>        <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>            Integer element = iterator.next();<br>            <span class="hljs-keyword">if</span> (element == key) &#123;<br>                data[h].remove(element);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Returns true if this set contains the specified element */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">contains</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> h = hash(key);<br>        Iterator&lt;Integer&gt; iterator = data[h].iterator();<br>        <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>            Integer element = iterator.next();<br>            <span class="hljs-keyword">if</span> (element == key) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> key % BASE;<br>    &#125;<br>&#125;<br><br>作者：LeetCode-Solution<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/design-hashset/solution/she-ji-ha-xi-ji-he-by-leetcode-solution-xp4t/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><blockquote><p>这里选择769是因为他是质数，能使桶分配的更平均，具体推到和数学原理有待思考！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Leetcode Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Notes - 56</title>
    <link href="/2021/08/31/LeetCode-Notes-56/"/>
    <url>/2021/08/31/LeetCode-Notes-56/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-Notes-56"><a href="#Leetcode-Notes-56" class="headerlink" title="Leetcode Notes - 56"></a>Leetcode Notes - 56</h1><p>题目：<strong>56. 合并区间</strong></p><p>难度：<strong>中等</strong></p><p>遇见次数：<strong>第二次</strong></p><p>涉及知识点：</p><ul><li>二维数组排序</li><li>贪心算法</li></ul><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="1-贪心算法"><a href="#1-贪心算法" class="headerlink" title="1. 贪心算法"></a>1. 贪心算法</h3><p>并不正确的贪心哈哈，没过，但是记录一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[][] merge(<span class="hljs-keyword">int</span>[][] intervals) &#123;<br>        <span class="hljs-keyword">if</span>(intervals.length == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> intervals;<br>        <br>        Arrays.sort(intervals, <span class="hljs-keyword">new</span> Comparator&lt;<span class="hljs-keyword">int</span>[]&gt;()&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] v1, <span class="hljs-keyword">int</span>[] v2)</span></span>&#123;<br>                <span class="hljs-keyword">return</span> v1[<span class="hljs-number">0</span>] - v2[<span class="hljs-number">0</span>];<br>            &#125;<br>        &#125;);<br>        <br>        <span class="hljs-keyword">int</span> p = <span class="hljs-number">1</span>;<br>        List&lt;<span class="hljs-keyword">int</span>[]&gt; resList = <span class="hljs-keyword">new</span> ArrayList&lt;<span class="hljs-keyword">int</span>[]&gt;();<br>        <span class="hljs-keyword">int</span> curLeft = intervals[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">int</span> curRight = intervals[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];<br>        <br>        <span class="hljs-keyword">while</span>(p &lt; intervals.length)&#123;<br>            <span class="hljs-keyword">if</span>(intervals[p][<span class="hljs-number">0</span>] &lt;= curRight)&#123;<br>                <span class="hljs-keyword">if</span>(curRight &lt;= intervals[p][<span class="hljs-number">1</span>])&#123;<br>                    curRight = intervals[p][<span class="hljs-number">1</span>];<br>                &#125;<br>                p++;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">int</span>[] cur = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">2</span>];<br>                cur[<span class="hljs-number">0</span>] = curLeft;<br>                cur[<span class="hljs-number">1</span>] = curRight;<br>                resList.add(cur);<br>                <br>                curLeft = intervals[p][<span class="hljs-number">0</span>];<br>                curRight = intervals[p][<span class="hljs-number">1</span>];<br>                p++;<br>            &#125;   <br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span>(curLeft == intervals[p - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] &amp;&amp; curRight == intervals[p - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>])&#123;<br>            <span class="hljs-keyword">int</span>[] temp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">2</span>];<br>            temp[<span class="hljs-number">0</span>] = curLeft;<br>            temp[<span class="hljs-number">1</span>] = curRight;<br>            resList.add(temp);<br>        &#125;<br>        <br>        <span class="hljs-keyword">int</span>[][] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[resList.size()][<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; resList.size(); i++)&#123;<br>            res[i] = resList.get(i);<br>        &#125;<br>            <br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="排序-贪心"><a href="#排序-贪心" class="headerlink" title="排序 + 贪心"></a>排序 + 贪心</h3><h4 id="思路及算法"><a href="#思路及算法" class="headerlink" title="思路及算法"></a>思路及算法</h4><p>我们用数组 <code>merged</code> 存储最终的答案。</p><p>首先，我们将列表中的区间按照左端点升序排序。然后我们将第一个区间加入 <code>merged</code> 数组中，并按顺序依次考虑之后的每个区间：</p><ul><li>如果当前区间的左端点在数组 <code>merged</code> 中最后一个区间的右端点之后，那么它们不会重合，我们可以直接将这个区间加入数组 <code>merged</code> 的末尾；</li><li>否则，它们重合，我们需要用当前区间的右端点更新数组 <code>merged</code> 中最后一个区间的右端点，将其置为二者的较大值。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[][] merge(<span class="hljs-keyword">int</span>[][] intervals) &#123;<br>        <span class="hljs-keyword">if</span> (intervals.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>];<br>        &#125;<br>        Arrays.sort(intervals, <span class="hljs-keyword">new</span> Comparator&lt;<span class="hljs-keyword">int</span>[]&gt;() &#123;<br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] interval1, <span class="hljs-keyword">int</span>[] interval2)</span> </span>&#123;<br>                <span class="hljs-keyword">return</span> interval1[<span class="hljs-number">0</span>] - interval2[<span class="hljs-number">0</span>];<br>            &#125;<br>        &#125;);<br>        List&lt;<span class="hljs-keyword">int</span>[]&gt; merged = <span class="hljs-keyword">new</span> ArrayList&lt;<span class="hljs-keyword">int</span>[]&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; intervals.length; ++i) &#123;<br>            <span class="hljs-keyword">int</span> L = intervals[i][<span class="hljs-number">0</span>], R = intervals[i][<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (merged.size() == <span class="hljs-number">0</span> || merged.get(merged.size() - <span class="hljs-number">1</span>)[<span class="hljs-number">1</span>] &lt; L) &#123;<br>                merged.add(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;L, R&#125;);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                merged.get(merged.size() - <span class="hljs-number">1</span>)[<span class="hljs-number">1</span>] = Math.max(merged.get(merged.size() - <span class="hljs-number">1</span>)[<span class="hljs-number">1</span>], R);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> merged.toArray(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[merged.size()][]);<br>    &#125;<br>&#125;<br><br>作者：LeetCode-Solution<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/merge-intervals/solution/he-bing-qu-jian-by-leetcode-solution/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Notes - 75</title>
    <link href="/2021/08/31/LeetCode-Notes-75/"/>
    <url>/2021/08/31/LeetCode-Notes-75/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-Notes-75"><a href="#Leetcode-Notes-75" class="headerlink" title="Leetcode Notes -75"></a>Leetcode Notes -75</h1><p>题目：<strong>75. 颜色分类</strong></p><p>难度：<strong>简单</strong></p><p>遇见次数：<strong>第二次</strong></p><p>涉及知识点：</p><ul><li>双指针</li><li>排序</li></ul><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="1-双指针"><a href="#1-双指针" class="headerlink" title="1. 双指针"></a>1. 双指针</h3><p>不正确的双指针😀</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sortColors</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(nums.length &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;<br>        <br>        <span class="hljs-keyword">int</span> p0 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> p2 = nums.length - <span class="hljs-number">1</span>;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++)&#123;<br>            <span class="hljs-keyword">if</span>(i &gt; p2) <span class="hljs-keyword">break</span>;<br>            <br>            <span class="hljs-keyword">int</span> tmp = -<span class="hljs-number">1</span>;<br>            <br>            <span class="hljs-keyword">while</span>(nums[i] != <span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">if</span>(nums[i] == <span class="hljs-number">0</span>)&#123;<br>                    tmp = nums[p0];<br>                    nums[p0] = <span class="hljs-number">0</span>;<br>                    nums[i] = tmp;<br>                    p0++;<br>                &#125;<br><br>                <span class="hljs-keyword">if</span>(nums[i] == <span class="hljs-number">2</span>)&#123;<br>                    tmp = nums[p2];<br>                    nums[p2] = <span class="hljs-number">2</span>;<br>                    nums[i] = tmp;<br>                    p2--;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span>;<br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><h4 id="思路及算法"><a href="#思路及算法" class="headerlink" title="思路及算法"></a>思路及算法</h4><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210831004334916.png" alt="力扣题解"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sortColors</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(nums.length &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;<br>        <br>        <span class="hljs-keyword">int</span> p0 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> p2 = nums.length - <span class="hljs-number">1</span>;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++)&#123;<br>            <span class="hljs-keyword">if</span>(i &gt; p2) <span class="hljs-keyword">break</span>;<br>            <br>            <span class="hljs-keyword">int</span> tmp = -<span class="hljs-number">1</span>;<br>            <br>            <span class="hljs-keyword">while</span>(nums[i] != <span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">if</span>(nums[i] == <span class="hljs-number">0</span>)&#123;<br>                    tmp = nums[p0];<br>                    nums[p0] = <span class="hljs-number">0</span>;<br>                    nums[i] = tmp;<br>                    p0++;<br>                &#125;<br><br>                <span class="hljs-keyword">if</span>(nums[i] == <span class="hljs-number">2</span>)&#123;<br>                    tmp = nums[p2];<br>                    nums[p2] = <span class="hljs-number">2</span>;<br>                    nums[i] = tmp;<br>                    p2--;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span>;<br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Notes - 169</title>
    <link href="/2021/08/31/LeetCode-Notes-169/"/>
    <url>/2021/08/31/LeetCode-Notes-169/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-Notes-169"><a href="#Leetcode-Notes-169" class="headerlink" title="Leetcode Notes - 169"></a>Leetcode Notes - 169</h1><p>题目：<strong>169. 多数元素</strong></p><p>难度：<strong>简单</strong></p><p>遇见次数：<strong>第二次</strong></p><p>涉及知识点：</p><ul><li>哈希</li><li>摩尔投票算法</li></ul><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="1-摩尔投票算法"><a href="#1-摩尔投票算法" class="headerlink" title="1. 摩尔投票算法"></a>1. 摩尔投票算法</h3><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210829220640206.png" alt="摩尔投票算法"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> candidate = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i : nums)&#123;<br>            <span class="hljs-keyword">if</span>(i == candidate)&#123;<br>                count++;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                count--;<br><br>                <span class="hljs-keyword">if</span>(count == <span class="hljs-number">0</span>)&#123;<br>                    candidate = i;<br>                    count = <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> candidate;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="Boyer-Moore-投票算法"><a href="#Boyer-Moore-投票算法" class="headerlink" title="Boyer-Moore 投票算法"></a>Boyer-Moore 投票算法</h3><h4 id="思路及算法"><a href="#思路及算法" class="headerlink" title="思路及算法"></a>思路及算法</h4><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210829220755990.png" alt="LeetCode官方题解"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>        Integer candidate = <span class="hljs-keyword">null</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) &#123;<br>            <span class="hljs-keyword">if</span> (count == <span class="hljs-number">0</span>) &#123;<br>                candidate = num;<br>            &#125;<br>            count += (num == candidate) ? <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> candidate;<br>    &#125;<br>&#125;<br><br>作者：LeetCode-Solution<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/majority-element/solution/duo-shu-yuan-su-by-leetcode-solution/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Notes - 136</title>
    <link href="/2021/08/29/LeetCode-Notes-136/"/>
    <url>/2021/08/29/LeetCode-Notes-136/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-Notes-136"><a href="#Leetcode-Notes-136" class="headerlink" title="Leetcode Notes - 136"></a>Leetcode Notes - 136</h1><p>题目：<strong>136. 只出现一次的数字</strong></p><p>难度：<strong>简单</strong></p><p>遇见次数：<strong>第二次</strong></p><p>涉及知识点：</p><ul><li>位运算</li><li>异或运算</li></ul><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="1-位运算"><a href="#1-位运算" class="headerlink" title="1. 位运算"></a>1. 位运算</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num: nums) &#123;<br>            ans ^= num;<br>            System.out.println(ans);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><h4 id="思路及算法"><a href="#思路及算法" class="headerlink" title="思路及算法"></a>思路及算法</h4><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210829211115524.png" alt="136.题解"></p>]]></content>
    
    
    <categories>
      
      <category>Leetcode Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Notes - 232</title>
    <link href="/2021/07/31/LeetCode-Notes-232/"/>
    <url>/2021/07/31/LeetCode-Notes-232/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-Notes-232"><a href="#Leetcode-Notes-232" class="headerlink" title="Leetcode Notes - 232"></a>Leetcode Notes - 232</h1><p>题目：<strong>232. 用栈实现队列</strong></p><p>难度：<strong>简单</strong></p><p>遇见次数：<strong>第一次</strong></p><p>涉及知识点：</p><ul><li>栈</li></ul><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="作弊"><a href="#作弊" class="headerlink" title="作弊"></a>作弊</h3><p>面向答案的编程😈</p><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210731172343379.png" alt="提交情况"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyQueue</span> </span>&#123;<br>    Queue&lt;Integer&gt; myQueue;<br><br>    <span class="hljs-comment">/** Initialize your data structure here. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyQueue</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.myQueue = <span class="hljs-keyword">new</span> LinkedList&lt;Integer&gt;();<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Push element x to the back of queue. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        myQueue.offer(x);<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Removes the element from in front of queue and returns that element. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> ele = myQueue.poll();<br><br>        <span class="hljs-keyword">return</span> ele;<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Get the front element. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">peek</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> ele = myQueue.peek();<br><br>        <span class="hljs-keyword">return</span> ele;<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Returns whether the queue is empty. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> myQueue.isEmpty();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MyQueue object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MyQueue obj = new MyQueue();</span><br><span class="hljs-comment"> * obj.push(x);</span><br><span class="hljs-comment"> * int param_2 = obj.pop();</span><br><span class="hljs-comment"> * int param_3 = obj.peek();</span><br><span class="hljs-comment"> * boolean param_4 = obj.empty();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="双栈"><a href="#双栈" class="headerlink" title="双栈"></a>双栈</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>将一个栈当作输入栈，用于压入 push 传入的数据；另一个栈当作输出栈，用于 pop 和 peek 操作。</p><p>每次 pop 或 peek 时，若输出栈为空则将输入栈的全部数据依次弹出并压入输出栈，这样输出栈从栈顶往栈底的顺序就是队列从队首往队尾的顺序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyQueue</span> </span>&#123;<br>    Deque&lt;Integer&gt; inStack;<br>    Deque&lt;Integer&gt; outStack;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyQueue</span><span class="hljs-params">()</span> </span>&#123;<br>        inStack = <span class="hljs-keyword">new</span> LinkedList&lt;Integer&gt;();<br>        outStack = <span class="hljs-keyword">new</span> LinkedList&lt;Integer&gt;();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        inStack.push(x);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (outStack.isEmpty()) &#123;<br>            in2out();<br>        &#125;<br>        <span class="hljs-keyword">return</span> outStack.pop();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">peek</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (outStack.isEmpty()) &#123;<br>            in2out();<br>        &#125;<br>        <span class="hljs-keyword">return</span> outStack.peek();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> inStack.isEmpty() &amp;&amp; outStack.isEmpty();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">in2out</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (!inStack.isEmpty()) &#123;<br>            outStack.push(inStack.pop());<br>        &#125;<br>    &#125;<br>&#125;<br><br>作者：LeetCode-Solution<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/implement-queue-using-stacks/solution/yong-zhan-shi-xian-dui-lie-by-leetcode-s-xnb6/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Notes - 20</title>
    <link href="/2021/07/31/LeetCode-Notes-20/"/>
    <url>/2021/07/31/LeetCode-Notes-20/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-Notes-20"><a href="#Leetcode-Notes-20" class="headerlink" title="Leetcode Notes - 20"></a>Leetcode Notes - 20</h1><p>题目：<strong>20. 有效的括号</strong></p><p>难度：<strong>简单</strong></p><p>遇见次数：<strong>第一次</strong></p><p>涉及知识点：</p><ul><li>栈</li></ul><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="1-栈"><a href="#1-栈" class="headerlink" title="1. 栈"></a>1. 栈</h3><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210731171027262.png" alt="提交情况"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValid</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(s.length() % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br><br>        <span class="hljs-keyword">char</span>[] strArr = s.toCharArray();<br>        Stack&lt;Character&gt; myStack = <span class="hljs-keyword">new</span> Stack&lt;Character&gt;();<br><br>        <span class="hljs-keyword">int</span> no = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; strArr.length; i++)&#123;<br>            no = typeJudge(strArr[i]);<br><br>            <span class="hljs-keyword">if</span>(no &lt;= <span class="hljs-number">3</span>)&#123;<br>                myStack.push(strArr[i]);<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">if</span>(myStack.empty()) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br><br>                <span class="hljs-keyword">if</span>(no - typeJudge(myStack.peek()) != <span class="hljs-number">3</span>)&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>                &#125;<br><br>                myStack.pop();<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> myStack.empty() ? <span class="hljs-keyword">true</span> : <span class="hljs-keyword">false</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">typeJudge</span><span class="hljs-params">(<span class="hljs-keyword">char</span> ch)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(ch == <span class="hljs-string">&#x27;(&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(ch == <span class="hljs-string">&#x27;[&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(ch == <span class="hljs-string">&#x27;&#123;&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>        <span class="hljs-keyword">if</span>(ch == <span class="hljs-string">&#x27;)&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">4</span>;<br>        <span class="hljs-keyword">if</span>(ch == <span class="hljs-string">&#x27;]&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">5</span>;<br>        <span class="hljs-keyword">if</span>(ch == <span class="hljs-string">&#x27;&#125;&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">6</span>;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>判断括号的有效性可以使用「栈」这一数据结构来解决。</p><p>我们遍历给定的字符串 s。当我们遇到一个左括号时，我们会期望在后续的遍历中，有一个相同类型的右括号将其闭合。由于后遇到的左括号要先闭合，因此我们可以将这个左括号放入栈顶。</p><p>当我们遇到一个右括号时，我们需要将一个相同类型的左括号闭合。此时，我们可以取出栈顶的左括号并判断它们是否是相同类型的括号。如果不是相同的类型，或者栈中并没有左括号，那么字符串 s 无效，返回 False。为了快速判断括号的类型，我们可以使用哈希表存储每一种括号。哈希表的键为右括号，值为相同类型的左括号。</p><p>在遍历结束后，如果栈中没有左括号，说明我们将字符串 s 中的所有左括号闭合，返回 True，否则返回 False。</p><p>注意到有效字符串的长度一定为偶数，因此如果字符串的长度为奇数，我们可以直接返回 False，省去后续的遍历判断过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValid</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = s.length();<br>        <span class="hljs-keyword">if</span> (n % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br><br>        Map&lt;Character, Character&gt; pairs = <span class="hljs-keyword">new</span> HashMap&lt;Character, Character&gt;() &#123;&#123;<br>            put(<span class="hljs-string">&#x27;)&#x27;</span>, <span class="hljs-string">&#x27;(&#x27;</span>);<br>            put(<span class="hljs-string">&#x27;]&#x27;</span>, <span class="hljs-string">&#x27;[&#x27;</span>);<br>            put(<span class="hljs-string">&#x27;&#125;&#x27;</span>, <span class="hljs-string">&#x27;&#123;&#x27;</span>);<br>        &#125;&#125;;<br>        Deque&lt;Character&gt; stack = <span class="hljs-keyword">new</span> LinkedList&lt;Character&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">char</span> ch = s.charAt(i);<br>            <span class="hljs-keyword">if</span> (pairs.containsKey(ch)) &#123;<br>                <span class="hljs-keyword">if</span> (stack.isEmpty() || stack.peek() != pairs.get(ch)) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>                &#125;<br>                stack.pop();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                stack.push(ch);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> stack.isEmpty();<br>    &#125;<br>&#125;<br><br>作者：LeetCode-Solution<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/valid-parentheses/solution/you-xiao-de-gua-hao-by-leetcode-solution/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Notes - 15</title>
    <link href="/2021/07/30/LeetCode-Notes-15/"/>
    <url>/2021/07/30/LeetCode-Notes-15/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-Notes-15"><a href="#Leetcode-Notes-15" class="headerlink" title="Leetcode Notes - 15"></a>Leetcode Notes - 15</h1><p>题目：<strong>15. 三数之和</strong></p><p>难度：<strong>中等</strong></p><p>遇见次数：<strong>第一次</strong></p><p>涉及知识点：</p><ul><li>双指针</li><li>数组</li></ul><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="1-原地修改"><a href="#1-原地修改" class="headerlink" title="1. 原地修改"></a>1. 原地修改</h3><p><strong>《超 出 时 间 限 制》</strong>🤣</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="hljs-keyword">int</span>[] nums) &#123;<br>        <span class="hljs-keyword">if</span>(nums.length &lt; <span class="hljs-number">3</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();<br>        &#125;<br><br>        Arrays.sort(nums);<br>        <br>        List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();<br>        Map&lt;String, List&lt;Integer&gt;&gt; myHashmap = <span class="hljs-keyword">new</span> HashMap&lt;String, List&lt;Integer&gt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>; a &lt; nums.length - <span class="hljs-number">2</span>; a++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> b = a + <span class="hljs-number">1</span>; b &lt; nums.length - <span class="hljs-number">1</span>; b++)&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> c = b + <span class="hljs-number">1</span>; c &lt; nums.length; c++)&#123;<br>                    <span class="hljs-keyword">if</span>(nums[a] + nums[b] == -nums[c])&#123;<br>                        List&lt;Integer&gt; curNew = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>                        String curStr = <span class="hljs-string">&quot;&quot;</span>;<br>                        <br>                        curNew.add(nums[a]);<br>                        curNew.add(nums[b]);<br>                        curNew.add(nums[c]);<br><br>                        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i : curNew)&#123;<br>                            curStr = curStr + String.format(<span class="hljs-string">&quot;%d&quot;</span>, i);<br>                        &#125;<br><br>                        <span class="hljs-keyword">if</span>(myHashmap.containsKey(curStr))&#123;<br>                            <span class="hljs-keyword">continue</span>;<br>                        &#125;<br>                        <span class="hljs-keyword">else</span>&#123;<br>                            myHashmap.put(curStr,curNew);<br>                            ans.add(curNew);<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="排序-双指针"><a href="#排序-双指针" class="headerlink" title="排序+双指针"></a>排序+双指针</h3><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210730231301770.png" alt="题解"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="hljs-keyword">int</span>[] nums) &#123;<br>    List&lt;List&lt;Integer&gt;&gt; lists = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-comment">//排序</span><br>    Arrays.sort(nums);<br>    <span class="hljs-comment">//双指针</span><br>    <span class="hljs-keyword">int</span> len = nums.length;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; len;++i) &#123;<br>        <span class="hljs-keyword">if</span>(nums[i] &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> lists;<br><br>        <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i-<span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br><br>        <span class="hljs-keyword">int</span> curr = nums[i];<br>        <span class="hljs-keyword">int</span> L = i+<span class="hljs-number">1</span>, R = len-<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (L &lt; R) &#123;<br>            <span class="hljs-keyword">int</span> tmp = curr + nums[L] + nums[R];<br>            <span class="hljs-keyword">if</span>(tmp == <span class="hljs-number">0</span>) &#123;<br>                List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>                list.add(curr);<br>                list.add(nums[L]);<br>                list.add(nums[R]);<br>                lists.add(list);<br>                <span class="hljs-keyword">while</span>(L &lt; R &amp;&amp; nums[L+<span class="hljs-number">1</span>] == nums[L]) ++L;<br>                <span class="hljs-keyword">while</span> (L &lt; R &amp;&amp; nums[R-<span class="hljs-number">1</span>] == nums[R]) --R;<br>                ++L;<br>                --R;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(tmp &lt; <span class="hljs-number">0</span>) &#123;<br>                ++L;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                --R;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> lists;<br>&#125;<br><br>作者：wu_yan_zu<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/3sum/solution/pai-xu-shuang-zhi-zhen-zhu-xing-jie-shi-python3-by/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Notes - 206</title>
    <link href="/2021/07/30/LeetCode-Notes-206/"/>
    <url>/2021/07/30/LeetCode-Notes-206/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-Notes-206"><a href="#Leetcode-Notes-206" class="headerlink" title="Leetcode Notes - 206"></a>Leetcode Notes - 206</h1><p>题目：<strong>206. 反转链表</strong></p><p>难度：<strong>简单</strong></p><p>遇见次数：<strong>第一次</strong></p><p>涉及知识点：</p><ul><li>链表</li></ul><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="1-三指针原地修改"><a href="#1-三指针原地修改" class="headerlink" title="1. 三指针原地修改"></a>1. 三指针原地修改</h3><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210730163151525.png" alt="提交情况"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(head.next == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br><br>        ListNode nextNode = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);<br>        ListNode preNode = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);<br><br>        nextNode.next = head.next;<br>        head.next = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">do</span>&#123;<br>            preNode.next = head;<br><br>            head = nextNode.next;<br><br>            nextNode.next = nextNode.next.next;<br><br>            head.next = preNode.next;<br>        &#125;<span class="hljs-keyword">while</span>(nextNode.next != <span class="hljs-keyword">null</span>);<br><br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><p>在遍历链表时，将当前节点的 <code>next</code> 指针改为指向前一个节点。由于节点没有引用其前一个节点，因此必须事先存储其前一个节点。在更改引用之前，还需要存储后一个节点。最后返回新的头引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>        ListNode prev = <span class="hljs-keyword">null</span>;<br>        ListNode curr = head;<br>        <span class="hljs-keyword">while</span> (curr != <span class="hljs-keyword">null</span>) &#123;<br>            ListNode next = curr.next;<br>            curr.next = prev;<br>            prev = curr;<br>            curr = next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> prev;<br>    &#125;<br>&#125;<br><br>作者：LeetCode-Solution<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/reverse-linked-list/solution/fan-zhuan-lian-biao-by-leetcode-solution-d1k2/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><blockquote><p>优于题解不解释</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Leetcode Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Notes - 83</title>
    <link href="/2021/07/30/LeetCode-Notes-83/"/>
    <url>/2021/07/30/LeetCode-Notes-83/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-Notes-83"><a href="#Leetcode-Notes-83" class="headerlink" title="Leetcode Notes - 83"></a>Leetcode Notes - 83</h1><p>题目：<strong>83. 删除排序链表中的重复元素</strong></p><p>难度：<strong>简单</strong></p><p>遇见次数：<strong>第一次</strong></p><p>涉及知识点：</p><ul><li>链表</li></ul><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="1-快慢指针-哈希表"><a href="#1-快慢指针-哈希表" class="headerlink" title="1. 快慢指针+哈希表"></a>1. 快慢指针+哈希表</h3><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210730180813688.png" alt="提交情况"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">deleteDuplicates</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(head.next == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br><br>        Set&lt;Integer&gt; myHashset = <span class="hljs-keyword">new</span> HashSet&lt;Integer&gt;();<br>        ListNode fast = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>, head.next);<br>        ListNode ans = head;<br><br>        myHashset.add(head.val);<br>        <span class="hljs-keyword">while</span>(fast.next != <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">if</span>(myHashset.contains(fast.next.val))&#123;<br>                head.next = <span class="hljs-keyword">null</span>;<br>                fast.next = fast.next.next;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                myHashset.add(fast.next.val);<br>                head.next = fast.next;<br>                head = head.next;<br>                fast.next = fast.next.next;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="迭代一次遍历"><a href="#迭代一次遍历" class="headerlink" title="迭代一次遍历"></a>迭代一次遍历</h3><h4 id="思路与算法"><a href="#思路与算法" class="headerlink" title="思路与算法"></a>思路与算法</h4><p>由于给定的链表是排好序的，因此重复的元素在链表中出现的位置是连续的，因此我们只需要对链表进行一次遍历，就可以删除重复的元素。</p><p>具体地，我们从指针 cur 指向链表的头节点，随后开始对链表进行遍历。如果当前 cur 与 cur.next 对应的元素相同，那么我们就将 cur.next 从链表中移除；否则说明链表中已经不存在其它与 cur 对应的元素相同的节点，因此可以将 cur 指向 cur.next。</p><p>当遍历完整个链表之后，我们返回链表的头节点即可。</p><h4 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h4><p>当我们遍历到链表的最后一个节点时，cur.next 为空节点，如果不加以判断，访问 cur.next 对应的元素会产生运行错误。因此我们只需要遍历到链表的最后一个节点，而不需要遍历完整个链表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">deleteDuplicates</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br><br>        ListNode cur = head;<br>        <span class="hljs-keyword">while</span> (cur.next != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (cur.val == cur.next.val) &#123;<br>                cur.next = cur.next.next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                cur = cur.next;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;<br><br>作者：LeetCode-Solution<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/remove-duplicates-from-sorted-list/solution/shan-chu-pai-xu-lian-biao-zhong-de-zhong-49v5/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Notes - 3</title>
    <link href="/2021/07/30/LeetCode-Notes-3/"/>
    <url>/2021/07/30/LeetCode-Notes-3/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-Notes-3"><a href="#Leetcode-Notes-3" class="headerlink" title="Leetcode Notes - 3"></a>Leetcode Notes - 3</h1><p>题目：<strong>3. 无重复字符的最长字串</strong></p><p>难度：<strong>简单</strong></p><p>遇见次数：<strong>第二次</strong></p><p>涉及知识点：</p><ul><li>字符串</li><li>哈希集合</li><li>滑动窗口</li></ul><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="1-滑动窗口"><a href="#1-滑动窗口" class="headerlink" title="1. 滑动窗口"></a>1. 滑动窗口</h3><p>学习后重写版本，之前想的确实不对😔</p><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210730154841165.png" alt="提交情况"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(s.length() == <span class="hljs-number">0</span> || s.length() == <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> s.length();<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> maxLen = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">char</span>[] strArr = s.toCharArray();<br>        Set&lt;Character&gt; myHashset = <span class="hljs-keyword">new</span> HashSet&lt;Character&gt;();<br><br>        <span class="hljs-keyword">int</span> right = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br><br>        myHashset.add(strArr[left]);<br>        <span class="hljs-keyword">while</span>(right &lt; strArr.length)&#123;<br>            <span class="hljs-keyword">if</span>(myHashset.contains(strArr[right]))&#123;<br>                myHashset.remove(strArr[left]);<br>                left++;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                maxLen = Math.max(maxLen, right - left + <span class="hljs-number">1</span>);<br>                myHashset.add(strArr[right]);<br>                right++;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> maxLen;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><p>首先，判断当前字符是否包含在map中，如果不包含，将该字符添加到map（字符，字符在数组下标）,<br>此时没有出现重复的字符，左指针不需要变化。</p><p>此时不重复子串的长度为：i-left+1，与原来的maxLen比较，取最大值；</p><p>如果当前字符 ch 包含在 map中，此时有2类情况：</p><ul><li>当前字符包含在当前有效的子段中，如：abca，当我们遍历到第二个a，当前有效最长子段是 abc，我们又遍历到a，那么此时更新 left 为 map.get(a)+1=1，当前有效子段更新为 bca；</li><li>当前字符不包含在当前最长有效子段中，如：abba，我们先添加a,b进map，此时left=0，我们再添加b，发现map中包含b，而且b包含在最长有效子段中，就是1）的情况，我们更新 left=map.get(b)+1=2，此时子段更新为 b，而且map中仍然包含a，map.get(a)=0；</li></ul><p>随后，我们遍历到a，发现a包含在map中，且map.get(a)=0，如果我们像上述第一种情况一样处理，就会发现</p><blockquote><p> left=map.get(a)+1=1</p></blockquote><p>实际上，left此时应该不变，left始终为2，子段变成 ba才对。</p><ul><li>为了处理以上2类情况，我们每次更新left，left=Math.max(left , map.get(ch)+1).</li><li>另外，更新left后，不管原来的 s.charAt(i) 是否在最长子段中，我们都要将 s.charAt(i) 的位置更新为当前的i，因此此时新的 s.charAt(i) 已经进入到 当前最长的子段中！</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        HashMap&lt;Character, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        <span class="hljs-keyword">int</span> maxLen = <span class="hljs-number">0</span>;<span class="hljs-comment">//用于记录最大不重复子串的长度</span><br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<span class="hljs-comment">//滑动窗口左指针</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.length() ; i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(map.containsKey(s.charAt(i)))<br>            &#123;<br>                left = Math.max(left , map.get(s.charAt(i))+<span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-comment">//不管是否更新left，都要更新 s.charAt(i) 的位置！</span><br>            map.put(s.charAt(i) , i);<br>            maxLen = Math.max(maxLen , i-left+<span class="hljs-number">1</span>);<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> maxLen;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Notes - 203</title>
    <link href="/2021/07/29/LeetCode-Notes-203/"/>
    <url>/2021/07/29/LeetCode-Notes-203/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-Notes-203"><a href="#Leetcode-Notes-203" class="headerlink" title="Leetcode Notes - 203"></a>Leetcode Notes - 203</h1><p>题目：<strong>203. 移除链表元素</strong></p><p>难度：<strong>简单</strong></p><p>遇见次数：<strong>第一次</strong></p><p>涉及知识点：</p><ul><li>链表</li></ul><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="1-原地修改"><a href="#1-原地修改" class="headerlink" title="1. 原地修改"></a>1. 原地修改</h3><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210729123540821.png" alt="提交情况"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">removeElements</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>        ListNode ans;<br><br>        <span class="hljs-keyword">while</span>(head != <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">if</span>(head.val == val)&#123;<br>                head = head.next;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        ans = head;<br><br>        <span class="hljs-keyword">if</span>(ans == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> ans;<br>        &#125;<br><br>        <span class="hljs-keyword">while</span>(head.next != <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">if</span>(head.next.val == val)&#123;<br>                head.next = head.next.next;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                head = head.next;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210729123702255.png" alt="官方题解"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">removeElements</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>        ListNode dummyHead = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);<br>        dummyHead.next = head;<br>        ListNode temp = dummyHead;<br>        <span class="hljs-keyword">while</span> (temp.next != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (temp.next.val == val) &#123;<br>                temp.next = temp.next.next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                temp = temp.next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummyHead.next;<br>    &#125;<br>&#125;<br><br>作者：LeetCode-Solution<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/remove-linked-list-elements/solution/yi-chu-lian-biao-yuan-su-by-leetcode-sol-654m/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><blockquote><p>哑头结点创建</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Leetcode Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Notes - 141</title>
    <link href="/2021/07/29/LeetCode-Notes-141/"/>
    <url>/2021/07/29/LeetCode-Notes-141/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-Notes-141"><a href="#Leetcode-Notes-141" class="headerlink" title="Leetcode Notes - 141"></a>Leetcode Notes - 141</h1><p>题目：<strong>141. 环形链表</strong></p><p>难度：<strong>简单</strong></p><p>遇见次数：<strong>第一次</strong></p><p>涉及知识点：</p><ul><li>字符串</li><li>哈希表</li></ul><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="1-哈希记录节点"><a href="#1-哈希记录节点" class="headerlink" title="1. 哈希记录节点"></a>1. 哈希记录节点</h3><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210729110135271.png" alt="提交情况"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode(int x) &#123;</span><br><span class="hljs-comment"> *         val = x;</span><br><span class="hljs-comment"> *         next = null;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br><br>        Set&lt;ListNode&gt; checkMap = <span class="hljs-keyword">new</span> HashSet&lt;ListNode&gt;();<br><br>        <span class="hljs-keyword">while</span>(head != <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">if</span>(checkMap.contains(head))&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br><br>            checkMap.add(head);<br>            head = head.next;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h3><h4 id="思路及算法"><a href="#思路及算法" class="headerlink" title="思路及算法"></a>思路及算法</h4><p>本方法需要读者对「Floyd 判圈算法」（又称龟兔赛跑算法）有所了解。</p><p>假想「乌龟」和「兔子」在链表上移动，「兔子」跑得快，「乌龟」跑得慢。当「乌龟」和「兔子」从链表上的同一个节点开始移动时，如果该链表中没有环，那么「兔子」将一直处于「乌龟」的前方；如果该链表中有环，那么「兔子」会先于「乌龟」进入环，并且一直在环内移动。等到「乌龟」进入环时，由于「兔子」的速度快，它一定会在某个时刻与乌龟相遇，即套了「乌龟」若干圈。</p><p>我们可以根据上述思路来解决本题。具体地，我们定义两个指针，一快一满。慢指针每次只移动一步，而快指针每次移动两步。初始时，慢指针在位置 <code>head</code>，而快指针在位置 <code>head.next</code>。这样一来，如果在移动的过程中，快指针反过来追上慢指针，就说明该链表为环形链表。否则快指针将到达链表尾部，该链表不为环形链表。</p><h4 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h4><p>为什么我们要规定初始时慢指针在位置 <code>head</code>，快指针在位置 <code>head.next</code>，而不是两个指针都在位置 <code>head</code>（即与「乌龟」和「兔子」中的叙述相同）？</p><p>观察下面的代码，我们使用的是 while 循环，循环条件先于循环体。由于循环条件一定是判断快慢指针是否重合，如果我们将两个指针初始都置于 head，那么 while 循环就不会执行。因此，我们可以假想一个在 head 之前的虚拟节点，慢指针从虚拟节点移动一步到达 head，快指针从虚拟节点移动两步到达 head.next，这样我们就可以使用 while 循环了。</p><p>当然，我们也可以使用 do-while 循环。此时，我们就可以把快慢指针的初始值都置为 head。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span> || head.next == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        <br>        ListNode slow = head;<br>        ListNode fast = head;<br>        <span class="hljs-keyword">do</span>&#123;<br>            <span class="hljs-keyword">if</span> (fast == <span class="hljs-keyword">null</span> || fast.next == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>            slow = slow.next;<br>            fast = fast.next.next;<br>        &#125; <span class="hljs-keyword">while</span>(slow != fast);<br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Notes - 21</title>
    <link href="/2021/07/29/LeetCode-Notes-21/"/>
    <url>/2021/07/29/LeetCode-Notes-21/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-Notes-21"><a href="#Leetcode-Notes-21" class="headerlink" title="Leetcode Notes - 21"></a>Leetcode Notes - 21</h1><p>题目：<strong>21. 合并两个有序链表</strong></p><p>难度：<strong>简单</strong></p><p>遇见次数：<strong>第二次</strong></p><p>涉及知识点：</p><ul><li>链表</li></ul><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="1-一次遍历"><a href="#1-一次遍历" class="headerlink" title="1. 一次遍历"></a>1. 一次遍历</h3><p>双指针一次遍历，空间复杂度优于题解🛫</p><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210729130352882.png" alt="提交情况"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(l1 == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> l2;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(l2 == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> l1;<br>        &#125;<br><br>        ListNode ans;<br><br>        ans = l1.val &gt; l2.val ? l2 : l1;<br>        ListNode dummy;<br>        <span class="hljs-keyword">while</span>(l1 != <span class="hljs-keyword">null</span> &amp;&amp; l2 != <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">if</span>(l1.val &lt;= l2.val)&#123;<br>                <span class="hljs-keyword">do</span>&#123;<br>                    dummy = l1;<br>                    l1 = l1.next;<br><br>                    <span class="hljs-keyword">if</span>(l1 == <span class="hljs-keyword">null</span>)&#123;<br>                        dummy.next = l2;<br>                        <span class="hljs-keyword">return</span> ans;<br>                    &#125;<br>                &#125;<span class="hljs-keyword">while</span>(l1.val &lt;= l2.val);<br><br>                dummy.next = l2;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span>(l1.val &gt; l2.val)&#123;<br>                <span class="hljs-keyword">do</span>&#123;<br>                    dummy = l2;<br>                    l2 = l2.next;<br><br>                    <span class="hljs-keyword">if</span>(l2 == <span class="hljs-keyword">null</span>)&#123;<br>                        dummy.next = l1;<br>                        <span class="hljs-keyword">return</span> ans;<br>                    &#125;<br>                &#125;<span class="hljs-keyword">while</span>(l1.val &gt; l2.val);<br><br>                dummy.next = l1;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>我们可以如下递归地定义两个链表里的 <code>merge</code> 操作（忽略边界情况，比如空链表等）：</p><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210729130732855.png" alt="递归条件"></p><p>也就是说，两个链表头部值较小的一个节点与剩下元素的 <code>merge</code> 操作结果合并。</p><h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><p>我们直接将以上递归过程建模，同时需要考虑边界情况。</p><p>如果 <code>l1</code> 或者 <code>l2</code> 一开始就是空链表 ，那么没有任何操作需要合并，所以我们只需要返回非空链表。否则，我们要判断 <code>l1</code> 和 <code>l2</code> 哪一个链表的头节点的值更小，然后递归地决定下一个添加到结果里的节点。如果两个链表有一个为空，递归结束。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (l1 == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> l2;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (l2 == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> l1;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (l1.val &lt; l2.val) &#123;<br>            l1.next = mergeTwoLists(l1.next, l2);<br>            <span class="hljs-keyword">return</span> l1;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            l2.next = mergeTwoLists(l1, l2.next);<br>            <span class="hljs-keyword">return</span> l2;<br>        &#125;<br><br>    &#125;<br>&#125;<br><br>作者：LeetCode-Solution<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/merge-two-sorted-lists/solution/he-bing-liang-ge-you-xu-lian-biao-by-leetcode-solu/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Notes - 383</title>
    <link href="/2021/07/28/LeetCode-Notes-383/"/>
    <url>/2021/07/28/LeetCode-Notes-383/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-Notes-383"><a href="#Leetcode-Notes-383" class="headerlink" title="Leetcode Notes - 383"></a>Leetcode Notes - 383</h1><p>题目：<strong>383. 赎金信</strong></p><p>难度：<strong>简单</strong></p><p>遇见次数：<strong>第一次</strong></p><p>涉及知识点：</p><ul><li>字符串</li><li>哈希表</li></ul><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="1-字母哈希计数"><a href="#1-字母哈希计数" class="headerlink" title="1. 字母哈希计数"></a>1. 字母哈希计数</h3><p><img src="https://typorastroage.oss-cn-beijing.aliyuncs.com/img/image-20210728120715643.png" alt="提交结果"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">canConstruct</span><span class="hljs-params">(String ransomNote, String magazine)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(magazine.length() == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">int</span>[] dicArr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">26</span>];<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> ch1 : magazine.toCharArray())&#123;<br>            dicArr[ch1 - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> ch2 : ransomNote.toCharArray())&#123;<br>            dicArr[ch2 - <span class="hljs-string">&#x27;a&#x27;</span>]--;<br><br>            <span class="hljs-keyword">if</span>(dicArr[ch2 - <span class="hljs-string">&#x27;a&#x27;</span>] &lt; <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ul><li>利用大小26的数组来进行计数</li><li>避免使用 <code>charAt()</code> 方法，因为每次调用它会检查一遍索引值是否越界，时间复杂度就会上去</li></ul>]]></content>
    
    
    <categories>
      
      <category>Leetcode Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2021/07/24/hello-world/"/>
    <url>/2021/07/24/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
