<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>LeetCode Notes - 187</title>
    <link href="/2021/09/06/LeetCode-Notes-187/"/>
    <url>/2021/09/06/LeetCode-Notes-187/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-Notes-187"><a href="#Leetcode-Notes-187" class="headerlink" title="Leetcode Notes - 187"></a>Leetcode Notes - 187</h1><p>题目：<strong>187. 重复的 DNA 序列</strong></p><p>难度：<strong>中等</strong></p><p>遇见次数：<strong>第二次</strong></p><p>涉及知识点：</p><ul><li>哈希表</li><li>双指针</li></ul><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="1-哈希表"><a href="#1-哈希表" class="headerlink" title="1. 哈希表"></a>1. 哈希表</h3><p>已出现的字串作为键📕</p><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210906161750320.png" alt="哈希表"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">findRepeatedDnaSequences</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(s.length() &lt;= <span class="hljs-number">10</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br><br>        Map&lt;String, Integer&gt; mp = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        <span class="hljs-keyword">int</span> len = s.length();<br>        List&lt;String&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i + <span class="hljs-number">9</span> &lt; len; i++)&#123;<br>            String str = s.substring(i, i + <span class="hljs-number">10</span>);<br>            <span class="hljs-keyword">int</span> cur = mp.getOrDefault(str, <span class="hljs-number">0</span>);<br><br>            <span class="hljs-keyword">if</span>(cur == <span class="hljs-number">0</span>)&#123;<br>                mp.put(str, <span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cur == <span class="hljs-number">1</span>)&#123;<br>                mp.put(str, cur + <span class="hljs-number">1</span>);<br>                res.add(str);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="位操作"><a href="#位操作" class="headerlink" title="位操作"></a>位操作</h3><h4 id="思路及算法"><a href="#思路及算法" class="headerlink" title="思路及算法"></a>思路及算法</h4><p>掩码实现滑动窗口切片。</p><p>遍历序列的起始位置：从 1 到 N - L。</p><ul><li>如果 start == 0，计算第一个序列 s [0 : L] 的掩码。</li><li>否则，从前一个掩码计算当前掩码。</li><li>如果掩码在 hashset 中，说明是重复序列，更新输出。</li><li>否则，将该掩码添加到 hashset。</li></ul><p>返回输出列表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">findRepeatedDnaSequences</span><span class="hljs-params">(String s)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> L = <span class="hljs-number">10</span>, n = s.length();<br>    <span class="hljs-keyword">if</span> (n &lt;= L) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArrayList();<br><br>    <span class="hljs-comment">// rolling hash parameters: base a</span><br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">4</span>, aL = (<span class="hljs-keyword">int</span>)Math.pow(a, L);<br><br>    <span class="hljs-comment">// convert string to array of integers</span><br>    Map&lt;Character, Integer&gt; toInt = <span class="hljs-keyword">new</span> HashMap() &#123;&#123;put(<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-number">0</span>); put(<span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-number">1</span>); put(<span class="hljs-string">&#x27;G&#x27;</span>, <span class="hljs-number">2</span>); put(<span class="hljs-string">&#x27;T&#x27;</span>, <span class="hljs-number">3</span>); &#125;&#125;;<br>    <span class="hljs-keyword">int</span>[] nums = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) nums[i] = toInt.get(s.charAt(i));<br><br>    <span class="hljs-keyword">int</span> bitmask = <span class="hljs-number">0</span>;<br>    Set&lt;Integer&gt; seen = <span class="hljs-keyword">new</span> HashSet();<br>    Set&lt;String&gt; output = <span class="hljs-keyword">new</span> HashSet();<br>    <span class="hljs-comment">// iterate over all sequences of length L</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> start = <span class="hljs-number">0</span>; start &lt; n - L + <span class="hljs-number">1</span>; ++start) &#123;<br>      <span class="hljs-comment">// compute bitmask of the current sequence in O(1) time</span><br>      <span class="hljs-keyword">if</span> (start != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// left shift to free the last 2 bit</span><br>        bitmask &lt;&lt;= <span class="hljs-number">2</span>;<br>        <span class="hljs-comment">// add a new 2-bits number in the last two bits</span><br>        bitmask |= nums[start + L - <span class="hljs-number">1</span>];<br>        <span class="hljs-comment">// unset first two bits: 2L-bit and (2L + 1)-bit</span><br>        bitmask &amp;= ~(<span class="hljs-number">3</span> &lt;&lt; <span class="hljs-number">2</span> * L);<br>      &#125;<br>      <span class="hljs-comment">// compute hash of the first sequence in O(L) time</span><br>      <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; L; ++i) &#123;<br>          bitmask &lt;&lt;= <span class="hljs-number">2</span>;<br>          bitmask |= nums[i];<br>        &#125;<br>      &#125;<br>      <span class="hljs-comment">// update output and hashset of seen sequences</span><br>      <span class="hljs-keyword">if</span> (seen.contains(bitmask)) output.add(s.substring(start, start + L));<br>      seen.add(bitmask);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;(output);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Notes - 5</title>
    <link href="/2021/09/06/LeetCode-Notes-5/"/>
    <url>/2021/09/06/LeetCode-Notes-5/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-Notes-5"><a href="#Leetcode-Notes-5" class="headerlink" title="Leetcode Notes - 5"></a>Leetcode Notes - 5</h1><p>题目：<strong>5. 最长回文子串</strong></p><p>难度：<strong>中等</strong></p><p>遇见次数：<strong>第二次</strong></p><p>涉及知识点：</p><ul><li>中心扩展</li><li>动态规划</li></ul><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="中心扩展"><a href="#中心扩展" class="headerlink" title="中心扩展"></a>中心扩展</h3><p>非常非常慢😂</p><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210906161400690.png" alt="预处理后中心扩展"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(s.length() == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> s;<br><br>        <span class="hljs-comment">// Transform</span><br>        StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> ch : s.toCharArray())&#123;<br>            sb.append(<span class="hljs-string">&#x27;#&#x27;</span>);<br>            sb.append(ch);<br>        &#125;<br>        sb.append(<span class="hljs-string">&#x27;#&#x27;</span>);<br>        String tfStr = sb.toString();<br><br>        <span class="hljs-keyword">int</span> maxLen = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> begin = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; tfStr.length(); i++)&#123;<br>            <span class="hljs-keyword">int</span> curLen = expand(i, tfStr);<br><br>            <span class="hljs-keyword">if</span>(curLen &gt; maxLen)&#123;<br>                begin = i;<br>                maxLen = curLen;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(maxLen == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> s.substring(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br><br>        StringBuilder ans = <span class="hljs-keyword">new</span> StringBuilder();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> ele : (tfStr.substring(begin - (maxLen - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>, begin + (maxLen - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>)).toCharArray())&#123;<br>            <span class="hljs-keyword">if</span>(ele != <span class="hljs-string">&#x27;#&#x27;</span>)&#123;<br>                ans.append(ele);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans.toString();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">expand</span><span class="hljs-params">(<span class="hljs-keyword">int</span> curIndex, String str)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> left = curIndex;<br>        <span class="hljs-keyword">int</span> right = curIndex;<br>        <span class="hljs-keyword">char</span>[] chArr = str.toCharArray();<br><br>        <span class="hljs-keyword">while</span>(chArr[left] == chArr[right])&#123;<br>            left--;<br>            right++;<br><br>            <span class="hljs-keyword">if</span>(left == -<span class="hljs-number">1</span> || right == chArr.length) <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> right - left - <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="中心扩展-1"><a href="#中心扩展-1" class="headerlink" title="中心扩展"></a>中心扩展</h3><h4 id="思路及算法"><a href="#思路及算法" class="headerlink" title="思路及算法"></a>思路及算法</h4><p>可以发现，所有的状态在转移的时候的可能性都是唯一的。也就是说，我们可以从每一种边界情况开始「扩展」，也可以得出所有的状态对应的答案。</p><p>边界情况即为子串长度为 1 或 2 的情况。我们枚举每一种边界情况，并从对应的子串开始不断地向两边扩展。</p><ul><li>如果两边的字母相同，我们就可以继续扩展，例如从 <code>P(i+1,j−1)</code> 扩展到 <code>P(i,j)</code></li><li>如果两边的字母不同，我们就可以停止扩展，因为在这之后的子串都不能是回文串了。</li></ul><p>聪明的读者此时应该可以发现，「边界情况」对应的子串实际上就是我们「扩展」出的回文串的「回文中心」。方法二的本质即为：我们枚举所有的「回文中心」并尝试「扩展」，直到无法扩展为止，此时的回文串长度即为此「回文中心」下的最长回文串长度。我们对所有的长度求出最大值，即可得到最终的答案。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (s == <span class="hljs-keyword">null</span> || s.length() &lt; <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> start = <span class="hljs-number">0</span>, end = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;<br>            <span class="hljs-keyword">int</span> len1 = expandAroundCenter(s, i, i);<br>            <span class="hljs-keyword">int</span> len2 = expandAroundCenter(s, i, i + <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">int</span> len = Math.max(len1, len2);<br>            <span class="hljs-keyword">if</span> (len &gt; end - start) &#123;<br>                start = i - (len - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>                end = i + len / <span class="hljs-number">2</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> s.substring(start, end + <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">expandAroundCenter</span><span class="hljs-params">(String s, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (left &gt;= <span class="hljs-number">0</span> &amp;&amp; right &lt; s.length() &amp;&amp; s.charAt(left) == s.charAt(right)) &#123;<br>            --left;<br>            ++right;<br>        &#125;<br>        <span class="hljs-keyword">return</span> right - left - <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Notes - 49</title>
    <link href="/2021/09/05/LeetCode-Notes-49/"/>
    <url>/2021/09/05/LeetCode-Notes-49/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-Notes-49"><a href="#Leetcode-Notes-49" class="headerlink" title="Leetcode Notes - 49"></a>Leetcode Notes - 49</h1><p>题目：<strong>49. 字母异位词</strong></p><p>难度：<strong>中等</strong></p><p>遇见次数：<strong>第二次</strong></p><p>涉及知识点：</p><ul><li>哈希表</li><li>将计数融入键</li></ul><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="1-哈希表计数"><a href="#1-哈希表计数" class="headerlink" title="1. 哈希表计数"></a>1. 哈希表计数</h3><p>顺序不对，不给过😭</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;<br>        Map&lt;String, List&lt;String&gt;&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;String, List&lt;String&gt;&gt;();<br>        Map&lt;Character, Integer&gt; mp = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br><br>        <span class="hljs-keyword">for</span> (String str : strs) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> ch : str.toCharArray())&#123;<br>                <span class="hljs-keyword">int</span> cur = mp.getOrDefault(ch, <span class="hljs-number">0</span>);<br>                mp.put(ch, cur + <span class="hljs-number">1</span>);<br>            &#125;<br>            <br>            StringBuffer sb = <span class="hljs-keyword">new</span> StringBuffer();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> ele : mp.keySet())&#123;<br>                sb.append(ele);<br>                sb.append(mp.get(ele));<br>            &#125;<br>            String key = sb.toString();<br>            List&lt;String&gt; list = map.getOrDefault(key, <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;());<br>            list.add(str);<br>            map.put(key, list);<br>            mp.clear();<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArrayList&lt;List&lt;String&gt;&gt;(map.values());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="计数"><a href="#计数" class="headerlink" title="计数"></a>计数</h3><h4 id="思路及算法"><a href="#思路及算法" class="headerlink" title="思路及算法"></a>思路及算法</h4><p>由于互为字母异位词的两个字符串包含的字母相同，因此两个字符串中的相同字母出现的次数一定是相同的，故可以将每个字母出现的次数使用字符串表示，作为哈希表的键。</p><p>由于字符串只包含小写字母，因此对于每个字符串，可以使用长度为 26 的数组记录每个字母出现的次数。</p><p>需要注意的是，在使用数组作为哈希表的键时，不同语言的支持程度不同，因此不同语言的实现方式也不同。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;<br>        Map&lt;String, List&lt;String&gt;&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;String, List&lt;String&gt;&gt;();<br>        <span class="hljs-keyword">for</span> (String str : strs) &#123;<br>            <span class="hljs-keyword">int</span>[] counts = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">26</span>];<br>            <span class="hljs-keyword">int</span> length = str.length();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>                counts[str.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>            &#125;<br>            <span class="hljs-comment">// 将每个出现次数大于 0 的字母和出现次数按顺序拼接成字符串，作为哈希表的键</span><br>            StringBuffer sb = <span class="hljs-keyword">new</span> StringBuffer();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++) &#123;<br>                <span class="hljs-keyword">if</span> (counts[i] != <span class="hljs-number">0</span>) &#123;<br>                    sb.append((<span class="hljs-keyword">char</span>) (<span class="hljs-string">&#x27;a&#x27;</span> + i));<br>                    sb.append(counts[i]);<br>                &#125;<br>            &#125;<br>            String key = sb.toString();<br>            List&lt;String&gt; list = map.getOrDefault(key, <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;());<br>            list.add(str);<br>            map.put(key, list);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArrayList&lt;List&lt;String&gt;&gt;(map.values());<br>    &#125;<br>&#125;<br><br>作者：LeetCode-Solution<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/group-anagrams/solution/zi-mu-yi-wei-ci-fen-zu-by-leetcode-solut-gyoc/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Notes - 43</title>
    <link href="/2021/09/05/LeetCode-Notes-43/"/>
    <url>/2021/09/05/LeetCode-Notes-43/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-Notes-43"><a href="#Leetcode-Notes-43" class="headerlink" title="Leetcode Notes - 43"></a>Leetcode Notes - 43</h1><p>题目：<strong>43. 字符串相乘</strong></p><p>难度：<strong>中等</strong></p><p>遇见次数：<strong>第二次</strong></p><p>涉及知识点：</p><ul><li>模拟</li><li>字符串</li></ul><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="1-模拟"><a href="#1-模拟" class="headerlink" title="1. 模拟"></a>1. 模拟</h3><p>做乘法，无敌！📕</p><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210905162611046.png" alt="模拟"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">multiply</span><span class="hljs-params">(String num1, String num2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(num1.length() &lt; num2.length()) <span class="hljs-keyword">return</span> multiply(num2, num1);<br><br>        <span class="hljs-keyword">if</span> (num1.equals(<span class="hljs-string">&quot;0&quot;</span>) || num2.equals(<span class="hljs-string">&quot;0&quot;</span>)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;0&quot;</span>;<br>        &#125;<br>        <br>        <span class="hljs-comment">// Main Algorithm</span><br>        <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[num1.length() + num2.length()];<br>        <span class="hljs-keyword">char</span>[] n1Arr = num1.toCharArray();<br>        <span class="hljs-keyword">char</span>[] n2Arr = num2.toCharArray();<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = n2Arr.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123;<br>            <span class="hljs-keyword">int</span> ten = n2Arr.length - <span class="hljs-number">1</span> - i;<br><br>            <span class="hljs-keyword">int</span> start = res.length - <span class="hljs-number">1</span> - ten;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = n1Arr.length - <span class="hljs-number">1</span>; k &gt;= <span class="hljs-number">0</span>; k--)&#123;<br>                <span class="hljs-keyword">int</span> cur = (n1Arr[k] - <span class="hljs-string">&#x27;0&#x27;</span>) * (n2Arr[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>                res[start] += cur;<br>                start--;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = res.length - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">1</span>; j--)&#123;<br>            <span class="hljs-keyword">int</span> addOn = res[j] - (res[j] % <span class="hljs-number">10</span>);<br>            res[j - <span class="hljs-number">1</span>] += addOn / <span class="hljs-number">10</span>;<br>            res[j] = res[j] % <span class="hljs-number">10</span>;<br>        &#125;<br><br>        StringBuilder result = <span class="hljs-keyword">new</span> StringBuilder();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; res.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span> &amp;&amp; res[i] == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>            result.append(res[i]);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h3><h4 id="思路及算法"><a href="#思路及算法" class="headerlink" title="思路及算法"></a>思路及算法</h4><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210905162720329.png" alt="官方题解"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">multiply</span><span class="hljs-params">(String num1, String num2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (num1.equals(<span class="hljs-string">&quot;0&quot;</span>) || num2.equals(<span class="hljs-string">&quot;0&quot;</span>)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;0&quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> m = num1.length(), n = num2.length();<br>        <span class="hljs-keyword">int</span>[] ansArr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m + n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = m - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-keyword">int</span> x = num1.charAt(i) - <span class="hljs-string">&#x27;0&#x27;</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = n - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j--) &#123;<br>                <span class="hljs-keyword">int</span> y = num2.charAt(j) - <span class="hljs-string">&#x27;0&#x27;</span>;<br>                ansArr[i + j + <span class="hljs-number">1</span>] += x * y;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = m + n - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--) &#123;<br>            ansArr[i - <span class="hljs-number">1</span>] += ansArr[i] / <span class="hljs-number">10</span>;<br>            ansArr[i] %= <span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> index = ansArr[<span class="hljs-number">0</span>] == <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>        StringBuffer ans = <span class="hljs-keyword">new</span> StringBuffer();<br>        <span class="hljs-keyword">while</span> (index &lt; m + n) &#123;<br>            ans.append(ansArr[index]);<br>            index++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>又优于题解了，非常开心！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Leetcode Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Notes - 290</title>
    <link href="/2021/09/04/LeetCode-Notes-290/"/>
    <url>/2021/09/04/LeetCode-Notes-290/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-Notes-290"><a href="#Leetcode-Notes-290" class="headerlink" title="Leetcode Notes - 290"></a>Leetcode Notes - 290</h1><p>题目：<strong>单词记录</strong></p><p>难度：<strong>简单</strong></p><p>遇见次数：<strong>第二次</strong></p><p>涉及知识点：</p><ul><li>哈希表</li><li>双射</li></ul><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="1-哈希表"><a href="#1-哈希表" class="headerlink" title="1. 哈希表"></a>1. 哈希表</h3><p>哈希表 + 哈希集合记录📕</p><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210904124209478.png" alt="哈希表"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">wordPattern</span><span class="hljs-params">(String pattern, String s)</span> </span>&#123;<br>        Map&lt;String, Character&gt; mp = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        Set&lt;Character&gt; hs = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br><br>        <span class="hljs-keyword">char</span>[] ptArr = pattern.toCharArray();<br>        String[] sArr = s.split(<span class="hljs-string">&quot; &quot;</span>);<br><br>        <span class="hljs-keyword">if</span>(ptArr.length != sArr.length) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; ptArr.length; i++)&#123;<br>            <span class="hljs-keyword">if</span>(mp.containsKey(sArr[i]))&#123;<br>                <span class="hljs-keyword">if</span>(mp.get(sArr[i]) == ptArr[i])&#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">if</span>(hs.contains(ptArr[i]))&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span>&#123;<br>                    mp.put(sArr[i], ptArr[i]);<br>                    hs.add(ptArr[i]);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><h4 id="思路及算法"><a href="#思路及算法" class="headerlink" title="思路及算法"></a>思路及算法</h4><p>在本题中，我们需要判断字符与字符串之间是否恰好一一对应。即任意一个字符都对应着唯一的字符串，任意一个字符串也只被唯一的一个字符对应。在集合论中，这种关系被称为「双射」。</p><p>想要解决本题，我们可以利用哈希表记录每一个字符对应的字符串，以及每一个字符串对应的字符。然后我们枚举每一对字符与字符串的配对过程，不断更新哈希表，如果发生了冲突，则说明给定的输入不满足双射关系。</p><p>在实际代码中，我们枚举 pattern 中的每一个字符，利用双指针来均摊线性地找到该字符在 str 中对应的字符串。每次确定一个字符与字符串的组合，我们就检查是否出现冲突，最后我们再检查两字符串是否比较完毕即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">wordPattern</span><span class="hljs-params">(String pattern, String str)</span> </span>&#123;<br>        Map&lt;String, Character&gt; str2ch = <span class="hljs-keyword">new</span> HashMap&lt;String, Character&gt;();<br>        Map&lt;Character, String&gt; ch2str = <span class="hljs-keyword">new</span> HashMap&lt;Character, String&gt;();<br>        <span class="hljs-keyword">int</span> m = str.length();<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> p = <span class="hljs-number">0</span>; p &lt; pattern.length(); ++p) &#123;<br>            <span class="hljs-keyword">char</span> ch = pattern.charAt(p);<br>            <span class="hljs-keyword">if</span> (i &gt;= m) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">int</span> j = i;<br>            <span class="hljs-keyword">while</span> (j &lt; m &amp;&amp; str.charAt(j) != <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>                j++;<br>            &#125;<br>            String tmp = str.substring(i, j);<br>            <span class="hljs-keyword">if</span> (str2ch.containsKey(tmp) &amp;&amp; str2ch.get(tmp) != ch) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (ch2str.containsKey(ch) &amp;&amp; !tmp.equals(ch2str.get(ch))) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>            str2ch.put(tmp, ch);<br>            ch2str.put(ch, tmp);<br>            i = j + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> i &gt;= m;<br>    &#125;<br>&#125;<br><br>作者：LeetCode-Solution<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/word-pattern/solution/dan-ci-gui-lu-by-leetcode-solution-6vqv/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Notes - 763</title>
    <link href="/2021/09/04/LeetCode-Notes-763/"/>
    <url>/2021/09/04/LeetCode-Notes-763/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-Notes-763"><a href="#Leetcode-Notes-763" class="headerlink" title="Leetcode Notes - 763"></a>Leetcode Notes - 763</h1><p>题目：<strong>763. 划分字母区间</strong></p><p>难度：<strong>中等</strong></p><p>遇见次数：<strong>第二次</strong></p><p>涉及知识点：</p><ul><li>贪心</li></ul><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="1-哈希-贪心"><a href="#1-哈希-贪心" class="headerlink" title="1. 哈希 + 贪心"></a>1. 哈希 + 贪心</h3><p>思路在，就是贪心最关键的一点没到位——当前的片段的结束点绝对不小于当前遍历到的字符的最后出现的位置📕</p><p>为什么这样说？因为我们可以知道，当我们遍历到当前片段的最小结束点 end 时，end 必然是这个片段里所有出现过的字符里终点最大的！</p><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210904132641475.png" alt="哈希 + 贪心"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">partitionLabels</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        <span class="hljs-keyword">char</span>[] chArr = s.toCharArray();<br>        Map&lt;Character, Integer&gt; mpEnd = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; chArr.length; i++)&#123;<br>            mpEnd.put(chArr[i], i);<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> start = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> end = <span class="hljs-number">0</span>;<br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; chArr.length; j++)&#123;<br>            <span class="hljs-keyword">int</span> cur = mpEnd.get(chArr[j]);<br>            end = Math.max(end, cur);<br><br>            <span class="hljs-keyword">if</span>(j == end)&#123;<br>                res.add(end - start + <span class="hljs-number">1</span>);<br>                start = end + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h3><h4 id="思路及算法"><a href="#思路及算法" class="headerlink" title="思路及算法"></a>思路及算法</h4><p>使用贪心的思想寻找每个片段可能的最小结束下标，因此可以保证每个片段的长度一定是符合要求的最短长度，如果取更短的片段，则一定会出现同一个字母出现在多个片段中的情况。由于每次取的片段都是符合要求的最短的片段，因此得到的片段数也是最多的。</p><p>由于每个片段访问结束的标志是访问到下标 end，因此对于每个片段，可以保证当前片段中的每个字母都一定在当前片段中，不可能出现在其他片段，可以保证同一个字母只会出现在同一个片段。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">partitionLabels</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[] last = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">26</span>];<br>        <span class="hljs-keyword">int</span> length = s.length();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>            last[s.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>] = i;<br>        &#125;<br>        List&lt;Integer&gt; partition = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>        <span class="hljs-keyword">int</span> start = <span class="hljs-number">0</span>, end = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>            end = Math.max(end, last[s.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>]);<br>            <span class="hljs-keyword">if</span> (i == end) &#123;<br>                partition.add(end - start + <span class="hljs-number">1</span>);<br>                start = end + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> partition;<br>    &#125;<br>&#125;<br><br>作者：LeetCode-Solution<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/partition-labels/solution/hua-fen-zi-mu-qu-jian-by-leetcode-solution/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Big Data Intro - Chapter 6</title>
    <link href="/2021/09/04/Big-Data-Intro-Chapter-6/"/>
    <url>/2021/09/04/Big-Data-Intro-Chapter-6/</url>
    
    <content type="html"><![CDATA[<h1 id="第06章-Spark基于内存的分布式计算"><a href="#第06章-Spark基于内存的分布式计算" class="headerlink" title="第06章 Spark基于内存的分布式计算"></a>第06章 Spark基于内存的分布式计算</h1><h2 id="Part-1-Spark-概述"><a href="#Part-1-Spark-概述" class="headerlink" title="Part 1 Spark 概述"></a>Part 1 Spark 概述</h2><h3 id="Spark-简介"><a href="#Spark-简介" class="headerlink" title="Spark 简介"></a>Spark 简介</h3><p><strong>Apache Spark</strong> 是一种基于<strong>内存的快速、通用、可扩展的</strong>大数据计算引擎。</p><p>同时，<strong>Spark</strong> 是一站式解决方案，集批处理、实时流处理、交互式查询、图计算与机器学习于一体。</p><h3 id="Spark-应用场景"><a href="#Spark-应用场景" class="headerlink" title="Spark 应用场景"></a>Spark 应用场景</h3><ul><li><strong>批处理</strong>可用于 <strong>ETL（抽取、转换、加载）</strong></li><li><strong>机器学习</strong>可用于自动判断电商的买家评论是好评还是差评</li><li><strong>交互式分析</strong>可用于查询 Hive 数据仓库</li><li><strong>流处理</strong>可用于页面点击流分析，推荐系统，舆情分析等实时业务<ul><li>舆情分析：就是对互联网敏感、热点信息进行监控、分析处理</li></ul></li></ul><blockquote><p>需要反复操作的次数越多，所需读取的数据量越大，受益越大，因为数据已经在内存了</p></blockquote><h3 id="Spark-特点"><a href="#Spark-特点" class="headerlink" title="Spark 特点"></a>Spark 特点</h3><p><strong>Spark</strong> 用十分之一的资源，便可获得 3 倍于 <strong>MapReduce</strong> 的性能</p><h4 id="轻"><a href="#轻" class="headerlink" title="轻"></a>轻</h4><p><strong>Spark 核心代码只有 3 万行</strong></p><ul><li>Scala 语言的简洁和丰富表达力</li><li>巧妙利用了 Hadoop 和 Mesos 的基础设施</li></ul><h4 id="快"><a href="#快" class="headerlink" title="快"></a>快</h4><p><strong>Spark 对小数据集可达到亚秒级的延迟</strong></p><ul><li>对大数据集的迭代机器学习即席查询、图计算等应用，<strong>Spark</strong> 版本比基于 <strong>MapReduce、Hive 和 Pregel</strong> 的实现快</li><li>内存计算、数据本地性和传输优化、调度优化</li></ul><h4 id="灵"><a href="#灵" class="headerlink" title="灵"></a>灵</h4><p><strong>Spark 提供了不同层面的灵活性</strong></p><ul><li>Scala 语言 trait 动态混入策略（如可更换的集群调度器、序列化库）</li><li>允许扩展新的数据算子、新的数据源、新的 <strong>language bindings</strong></li><li><strong>Spark</strong> 支持内存计算、多迭代批量处理、即席查询、流处理和图计算等多种范式</li></ul><h4 id="巧"><a href="#巧" class="headerlink" title="巧"></a>巧</h4><p><strong>巧妙借力现有大数据组件</strong></p><ul><li><strong>Spark</strong> 借 <strong>Hadoop</strong> 之势，与 <strong>Hadoop</strong> 无缝结合</li><li>图计算借用 <strong>Pregel 和 PowerGraph</strong> 的 API 以及 PowerGraph 的点分割思想</li></ul><h2 id="Part-2-Spark-数据结构"><a href="#Part-2-Spark-数据结构" class="headerlink" title="Part 2 Spark 数据结构"></a>Part 2 Spark 数据结构</h2><h3 id="Spark-核心概念-RDD"><a href="#Spark-核心概念-RDD" class="headerlink" title="Spark 核心概念 RDD"></a>Spark 核心概念 RDD</h3><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210904104454432.png" alt="RDD 在 Spark 中的角色"></p><p><strong>RDD（Resilient Distributed Datasets）</strong> 即<strong>弹性分布式数据集</strong>，是一个<strong>只读的，可分区的</strong>分布式数据集</p><ul><li>RDD 默认存储在<strong>内存</strong>，当内存不足时，溢写到磁盘</li><li>RDD 数据以<strong>分区的形式</strong>在集群中存储</li><li>RDD 具有<strong>血统机制（Lineage）</strong>，发生数据丢失时，可快速进行数据恢复</li></ul><p>可以说，<strong>RDD</strong> 是 <strong>Spark</strong> 对基础数据的抽象</p><ul><li><strong>RDD 的生成：</strong><ul><li>从 Hadoop 文件系统（或与 Hadoop 兼容的其它存储系统）输入创建（如 HDFS）</li><li>从父RDD转换得到新的RDD</li></ul></li><li><strong>RDD 的存储：</strong><ul><li>用户可以选择不同的存储级别存储 RDD 以便重用（11种）</li><li>RDD 默认存储于内存，但当内存不足时，RDD会溢出到磁盘中</li></ul></li><li><strong>RDD 的分区：</strong><ul><li>为减少网络传输代价，和进行分布式计算，需对RDD进行分区</li><li>在需要进行分区时会根据每条记录 Key 进行分区，以此保证两个数据集能高效进行 Join 操作</li></ul></li><li><strong>RDD 的优点：</strong><ul><li>RDD是只读的，静态的。因此可提供更高的容错能力</li><li>可以实现推测式执行</li></ul></li></ul><h3 id="RDD-的依赖关系"><a href="#RDD-的依赖关系" class="headerlink" title="RDD 的依赖关系"></a>RDD 的依赖关系</h3><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210904104551904.png" alt="ND 和 WD"></p><h4 id="Dependency（依赖）"><a href="#Dependency（依赖）" class="headerlink" title="Dependency（依赖）"></a>Dependency（依赖）</h4><ul><li>窄依赖是指父 RDD 的<strong>每个分区最多被一个</strong>子 RDD 的一个<strong>分区（即 Partition）</strong>所用</li><li>宽依赖是指父 RDD 的<strong>每个分区对应一个</strong>子 RDD 的多个分区，是 stage 划分的依据</li></ul><h4 id="Lineage（血统）：依赖的链条"><a href="#Lineage（血统）：依赖的链条" class="headerlink" title="Lineage（血统）：依赖的链条"></a>Lineage（血统）：依赖的链条</h4><ul><li>RDD 数据集通过 <strong>Lineage</strong> 记住了它是如何从其他 RDD 中演变过来的</li></ul><h3 id="宽窄依赖的区别"><a href="#宽窄依赖的区别" class="headerlink" title="宽窄依赖的区别"></a>宽窄依赖的区别</h3><h4 id="算子"><a href="#算子" class="headerlink" title="算子"></a>算子</h4><p><strong>窄依赖</strong>指的是每一个父 RDD 的 Partition 最多被子 RDD 的一个 Partition 使用</p><ul><li>如 <code>map</code>、<code>filter</code>，<code>union</code></li></ul><p><strong>宽依赖</strong>指的是多个子 RDD 的 Partition 会依赖同一个父 RDD 的 Partition</p><ul><li>如 <code>groupByKey</code>，<code>reduceByKey</code>，<code>sortByKey</code></li></ul><h4 id="容错性"><a href="#容错性" class="headerlink" title="容错性"></a>容错性</h4><p>假设某个节点出现了故障</p><ul><li>窄依赖：只需要重算与<strong>子 RDD 分区对应的父 RDD 分区</strong>即可</li><li>宽依赖：极端情况下，<strong>所有的父 RDD 分区都要重新计算</strong></li></ul><p>如下图所示，b1 分区丢失，则需要重新计算 a1, a2 和 a3</p><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210904105710231.png" alt="宽依赖故障情况"></p><h4 id="传输"><a href="#传输" class="headerlink" title="传输"></a>传输</h4><p>宽依赖往往对应着 <strong>Shuffle</strong> 操作，需要在运行过程中将同一个父 RDD 的分区传入到不同的子 RDD 分区中，中间可能涉及多个节点之间的数据传输。</p><p>窄依赖的每个父 RDD 的分区只会传入到一个子 RDD 分区中，通常可以在一个节点内完成转换。</p><h3 id="RDD-的-Stage-划分"><a href="#RDD-的-Stage-划分" class="headerlink" title="RDD 的 Stage 划分"></a>RDD 的 Stage 划分</h3><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210904110026807.png" alt="RDD 的 Stage 划分"></p><p>实际应用提交的 Job 中 RDD 依赖关系是十分复杂的，依据这些依赖关系来划分 stage 自然 是十分困难的，Spark 此时就利用了前文提到的依赖关系</p><ul><li>调度器从 DAG 图末端出发，逆向遍历整个依赖关系链</li><li>遇到 <strong>ShuffleDependency（宽依赖关系的一种叫法）</strong>就断开</li><li>遇到 <strong>NarrowDependency</strong> 就将其加入到当前 stage</li></ul><p>stage 中task 数目由 stage 末端的 RDD分区个数来决定，RDD 转换是基于分区的一种<strong>粗粒度计算</strong>，一个 stage 执行的结果就是这几个分区构成的 RDD</p><h3 id="RDD-操作类型"><a href="#RDD-操作类型" class="headerlink" title="RDD 操作类型"></a>RDD 操作类型</h3><p><strong>Spark</strong> 中的操作大致可以分为创建操作、转换操作、控制操作和行为操作</p><ul><li><strong>创建操作（Creation Operation）：</strong>用于 RDD 创建工作。RDD 创建只有两种方法<ul><li>一种是来自于内存集合和外部存储系统</li><li>另一种是通过转换操作生成的 RDD</li></ul></li><li><strong>转换操作（Transformation Operation）：</strong>将 RDD 通过一定的操作转变成新的 RDD，RDD 的转换操作是<strong>惰性操作</strong>，他只是定义了一个新的 RDD，并没有立即执行</li><li><strong>控制操作（Control Operation）：</strong>进行 RDD 持久化，可以让 RDD 按不同的存储策略保存在磁盘或者内存中，比如 cache 接口默认将 RDD 缓存在内存中</li><li><strong>行动操作（Action Operation）：</strong>能够出发 <strong>Spark</strong> 运行的操作，其分为两类——<ul><li>一类操作输出计算结果</li><li>另一类将 RDD 保存到外部文件系统或者数据库中</li></ul></li></ul><p>下面详细介绍这四类操作</p><h4 id="创建操作"><a href="#创建操作" class="headerlink" title="创建操作"></a>创建操作</h4><p>目前有两张类型的基础 RDD：</p><ul><li>并行集合：接受一个已经存在的集合，然后进行并行计算</li><li>外部存储：在一个文件的每条记录上运行函数<ul><li>只要文件系统是 HDFS，或者 Hadoop 支持的任意存储系统即可</li></ul></li></ul><p>这两种类型的 RDD 都可以通过相同的方式进行操作，从而获得子 RDD 等一系列拓展，形成血统关系图。</p><h4 id="控制操作"><a href="#控制操作" class="headerlink" title="控制操作"></a>控制操作</h4><p>Spark 可以将 RDD <strong>持久化</strong>到内存或磁盘文件系统中，把 RDD 持久化到内存中<strong>可以极大地提高迭代计算以及个计算模型之间的数据共享</strong>。</p><p>一般情况下执行节点 60% 内存用于缓存数据，剩下的 40% 用于运行任务。</p><p>Spark 中使用 persist 和 cache 操作进行持久化，其中 cache 是 persist() 的特例。</p><h4 id="转换操作-Transformation-算子"><a href="#转换操作-Transformation-算子" class="headerlink" title="转换操作 - Transformation 算子"></a>转换操作 - Transformation 算子</h4><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210904111602403.png" alt="Transformation 算子"></p><h4 id="行动操作-Action-算子"><a href="#行动操作-Action-算子" class="headerlink" title="行动操作 - Action 算子"></a>行动操作 - Action 算子</h4><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210904111625270.png" alt="Action 算子"></p><h3 id="DataFrame-概念"><a href="#DataFrame-概念" class="headerlink" title="DataFrame 概念"></a>DataFrame 概念</h3><p>与 RDD 类似，<strong>DataFrame</strong> 也是一个<strong>不可变弹性分布式数据集</strong>。除了数据以外，还记录数据的<strong>结构信息</strong>，即 <strong>Schema</strong>，类似二维表格</p><p><strong>DataFrame</strong> 的查询计划可以通过 <strong>Spark Catalyst Optimiser</strong> 进行优化，即使 Spark 经验并不丰富，用 <strong>DataFrame</strong> 写的程序也可以尽量被转化为<strong>高效的形式</strong>予以执行</p><blockquote><p><strong>Catalyst工作流程：</strong></p><ul><li>SQL 语句首先通过 Parser 模块被解析为语法树，此棵树称为 Unresolved Logical Plan</li><li>Unresolved Logical Plan 通过 Analyzer 模块借助于数据元数据解析为 Logical Plan</li><li>此时再通过各种基于规则的优化策略进行深入优化，得到 Optimized Logical Plan</li><li>优化后的逻辑执行计划依然是逻辑的，并不能被 Spark 系统理解，此时需要将此逻辑执行计划转换为Physical Plan</li></ul></blockquote><h3 id="DataSet-概念"><a href="#DataSet-概念" class="headerlink" title="DataSet 概念"></a>DataSet 概念</h3><p><strong>DataFrame</strong> 是 <strong>DataSet</strong> 的特例，**DataFrame = DataSet[Row]**，所以可以通过 <code>as</code> 方法将 DataFrame 转换为 DataSet。</p><p><strong>Row</strong> 是一个通用的类型，所有的表结构信息都用 Row 来表示。</p><p><strong>DataSet</strong> 是强类型的，可以有 <strong>DataSet[Car]，DataSet[Person]</strong></p><h3 id="DataFrame、DataSet、RDD-表现形式的区别"><a href="#DataFrame、DataSet、RDD-表现形式的区别" class="headerlink" title="DataFrame、DataSet、RDD 表现形式的区别"></a>DataFrame、DataSet、RDD 表现形式的区别</h3><p>假设 RDD 中的两行数据长这样</p><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210904112524752.png" alt="RDD 示例"></p><p>那么在 DataFrame 中的数据长这样</p><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210904112559381.png" alt="DataFrame 示例"></p><p>那么 DataSet 中的数据长这样</p><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210904112647391.png" alt="DataSet 示例"></p><p>由上可见——</p><h4 id="DataFrame-与-DataSet-的区别"><a href="#DataFrame-与-DataSet-的区别" class="headerlink" title="DataFrame 与 DataSet 的区别"></a>DataFrame 与 DataSet 的区别</h4><ul><li><strong>DataFrame</strong><ul><li>DataFrame 每一行的类型固定为 Row，只有通过解析才能获取各个字段的值， 每一列的值没法直接访问</li><li>DataFrame 编译器缺少类型安全检查</li></ul></li><li><strong>DataSet</strong><ul><li>每一行是什么类型是不一定的，可以是 Person，也可以是 Row</li><li>DataSet 类型安全</li></ul></li></ul><h4 id="RDD-与-DataFrame-DataSet的区别"><a href="#RDD-与-DataFrame-DataSet的区别" class="headerlink" title="RDD 与 DataFrame / DataSet的区别"></a>RDD 与 DataFrame / DataSet的区别</h4><ul><li><strong>RDD</strong><ul><li>用于 Spark1.X 各模块的 API</li><li>不支持 SparkSQL 操作</li><li>不支持代码自动优化</li></ul></li><li><strong>DataFrame 与 DataSet</strong><ul><li>用于 Spark2.X 各模块的 API</li><li>支持 SparkSQL 操作，还能注册临时表，进行 SQL 语句操作</li><li>支持一些方便的保存方式，比如保存成 csv，json 等格式</li><li>基于 SparkSQL 引擎构建，支持代码自动优化</li></ul></li></ul><h4 id="RDD-与-DataFrame、DataSet-三者的共性"><a href="#RDD-与-DataFrame、DataSet-三者的共性" class="headerlink" title="RDD 与 DataFrame、DataSet 三者的共性"></a>RDD 与 DataFrame、DataSet 三者的共性</h4><ul><li>三者都是<strong>分布式弹性数据集</strong>，支持相互转化</li><li>三者有<strong>许多共同的函数</strong>，如 filter，排序等</li><li>三者<strong>都是 Lazy（惰性操作） 的</strong>，在进行创建、转换时，不会立即执行<ul><li>只有在遇到 Action 算子时，才会开始遍历运算</li></ul></li></ul><h2 id="Part-3-Spark-原理与架构"><a href="#Part-3-Spark-原理与架构" class="headerlink" title="Part 3 Spark 原理与架构"></a>Part 3 Spark 原理与架构</h2><h3 id="Spark-体系架构"><a href="#Spark-体系架构" class="headerlink" title="Spark 体系架构"></a>Spark 体系架构</h3><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210904113924087.png" alt="Spark 体系架构"></p><h4 id="Spark-Core"><a href="#Spark-Core" class="headerlink" title="Spark Core"></a>Spark Core</h4><p>类似于 MapReduce 的分布式内存计算框架，最大的特点是<strong>将中间计算结果直接放在内存中</strong>，提升计算性能。</p><p>自带了 Standalone 模式的资源管理框架，同时，也支持YARN、 MESOS的资源管理系统。</p><p>FI 集成的是 Spark On Yarn 的模式，其它模式暂不支持。</p><h4 id="SparkSQL"><a href="#SparkSQL" class="headerlink" title="SparkSQL"></a>SparkSQL</h4><p>Spark SQL 是一个用于处理结构化数据的 Spark 组件，作为 Apache  Spark 大数据框架的一部分，主要用于<strong>结构化数据处理和对数据执行类SQL查询</strong>。</p><p>通过 Spark SQL，可以针对不同数据格式（如：JSON，Parquet， ORC等）和数据源执行 ETL操作（如：HDFS、数据库等），完成特定的查询操作。</p><h4 id="Spark-Streaming"><a href="#Spark-Streaming" class="headerlink" title="Spark Streaming"></a>Spark Streaming</h4><p>微批处理的流处理引擎，将流数据分片以后用 Spark Core 的计算引擎 中进行处理。相对于Storm，实时性稍差，优势<strong>体现在吞吐量上</strong></p><h4 id="MLlib-和-GraphX"><a href="#MLlib-和-GraphX" class="headerlink" title="MLlib 和 GraphX"></a>MLlib 和 GraphX</h4><p>主要一些算法库（机器学习算法库和图计算算法库）</p><h4 id="Structured-Streaming"><a href="#Structured-Streaming" class="headerlink" title="Structured Streaming"></a>Structured Streaming</h4><p>为 2.0 版本之后的 Spark 独有，吸收了一些 Flink 的特性和功能</p><h3 id="典型案例-WordCount"><a href="#典型案例-WordCount" class="headerlink" title="典型案例 - WordCount"></a>典型案例 - WordCount</h3><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210904114425809.png" alt="WordCount案例"></p><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210904114503856.png" alt="Scala核心代码"></p><h3 id="Spark-SQL-概述"><a href="#Spark-SQL-概述" class="headerlink" title="Spark SQL 概述"></a>Spark SQL 概述</h3><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210904114704510.png" alt="Spark SQL"></p><p><strong>Spark SQL</strong> 是 <strong>Spark</strong> 中用于<strong>结构化数据处理的模块</strong>。在 <strong>Spark</strong> 应用中，可以无缝地使用 SQL 语句亦或是 <strong>DataFrame API</strong> 对结构化数据进行查询。</p><p>Spark SQL 对 SQL 语句的处理和关系型数据库采用了类似的方法，SparkSQL 先会将 SQL 语句进行解析（Parse）形成一个 Tree， 然后使用 Rule 对 Tree 进行绑定、 优化等处理过程</p><ul><li><strong>词法和语法解析（Parse）</strong><ul><li>对读入的 SQL 语句进行词法和语法解析（Parse），分辨出 SQL 语句中那些词是关键词（如 SELECT、FROM、WHERE），哪些是表达式，哪些是 Projection，哪些是 Data Source 等，判断 SQL 语句是否规范，并形成逻辑计划</li></ul></li><li><strong>绑定（Bind）</strong><ul><li>将SQL语句和数据库的数据字典（列、 表和视图等）进行绑定(Bind)，如果相关的 Projection 和 Data Source 等都存在的话，则表示这个 SQL 语句是可以执行的</li></ul></li><li><strong>优化（Optimize）</strong><ul><li>Spark SQL 会提供几个执行计划，返回从数据库查询的数据集</li></ul></li><li><strong>执行（Execute）</strong><ul><li>执行前面步骤获取的最优执行计划，返回从数据库查询的数据集</li></ul></li></ul><h3 id="Spark-SQL-和-Hive-对比"><a href="#Spark-SQL-和-Hive-对比" class="headerlink" title="Spark SQL 和 Hive 对比"></a>Spark SQL 和 Hive 对比</h3><p>两者区别在于——</p><ul><li><strong>Spark SQL</strong> 的执行引擎为 <strong>Spark Core</strong>，<strong>Hive</strong> 默认执行引擎是 <strong>MapReduce</strong></li><li><strong>Spark SQL</strong> 的执行速度是 <strong>Hive</strong> 的 10 - 100 倍</li><li><strong>Spark SQL</strong> 不支持 <strong>buckets，Hive</strong> 支持</li></ul><p>两者的联系在于——</p><ul><li><strong>Spark SQL</strong> 依赖 <strong>Hive</strong> 的元数据</li><li><strong>Spark SQL</strong> 兼容绝大部分 <strong>Hive</strong> 的语法和函数</li><li><strong>Spark SQL</strong> 可以使用 <strong>Hive</strong> 的自定义函数</li></ul><p><strong>Spark SQL</strong> 和 <strong>Hive</strong> 的语法除了<strong>桶表操作外</strong>，基本一致，且 <strong>Spark SQL</strong> 完美兼容 <strong>Hive</strong> 的函数。</p><h3 id="Structured-Streaming-概述"><a href="#Structured-Streaming-概述" class="headerlink" title="Structured Streaming 概述"></a>Structured Streaming 概述</h3><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210904120551029.png" alt="Structured Streaming 概述"></p><p><strong>Structured Streaming</strong> 是构建在 <strong>Spark SQL</strong> 引擎上的流式数据处理引擎，可以像使用静态 RDD 数据那样编写流式计算过程。</p><p>当流数据连续不断的产生时，<strong>Spark SQL</strong> 将会<strong>增量地、持续不断地处理</strong>这些数据，并将结果更新到结果集中。</p><p><strong>Structured Streaming</strong> 的核心是<strong>将流式的数据看成一张数据不断增加的数据库表</strong></p><ul><li>这种流式的数据处理模型类似于数据块处理模型，可以把静态数据库表的一些查询操作应用在流式计算中，Spark 执行标准的 SQL 查询，从无边界表中获取数据</li><li>无边界表：新数据不断到来，旧数据不断丢弃，实际上是一个连续不断的结构化数据流</li></ul><h4 id="计算模型示例"><a href="#计算模型示例" class="headerlink" title="计算模型示例"></a>计算模型示例</h4><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210904120848499.png" alt="Structured Streaming 计算模型示例"></p><ul><li>第一个 lines DataFrame 对象是一张数据输入的 Input Table，最后的 WordCounts  DataFrame 是一个结果集 Result Table</li><li>在 lines DataFrame 数据流之上的查询产生了 WordCounts 的表示方式和在静态的 Static DataFrame 上的使用方式相同。</li><li>然而， Spark 会监控 socket 连接，获取新的持续不断产生的数据。</li><li>当新的数据产生时，Spark 将会在新数据上运行一个增量的 counts 查询，并且整合新的 counts 和之前已经计算出来的 counts，获取更新后的 counts</li></ul><h3 id="Spark-Streaming-概述"><a href="#Spark-Streaming-概述" class="headerlink" title="Spark Streaming 概述"></a>Spark Streaming 概述</h3><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210904121518306.png" alt="Spark Streaming 概述"></p><p><strong>Spark Sreaming</strong> 的基本原理是<strong>将实时输入数据流以时间片（秒级）为单位</strong>进行拆分，然后经 <strong>Spark</strong> 引擎以类似批处理的方式处理每个时间片数据。</p><ul><li>把输入数据以秒（毫秒）为单位切分，再定时提交这些切分后的数据</li></ul><h3 id="窗口间隔和滑动间隔"><a href="#窗口间隔和滑动间隔" class="headerlink" title="窗口间隔和滑动间隔"></a>窗口间隔和滑动间隔</h3><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210904121626600.png" alt="窗口间隔和滑动间隔"></p><p>窗口在 DStream 上华东，合并和操作落入窗口内的 RDDs，产生窗口化的 RDDs</p><ul><li><strong>窗口长度：</strong>窗口的持续时间</li><li><strong>滑动窗口间隔：</strong>窗口操作执行的时间间隔</li></ul><h3 id="Spark-Streaming-和-Storm-对比"><a href="#Spark-Streaming-和-Storm-对比" class="headerlink" title="Spark Streaming 和 Storm 对比"></a>Spark Streaming 和 Storm 对比</h3><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210904121755263.png" alt="Spark Streaming 和 Storm 对比"></p><p>事实上，Spark Streaming 绝对谈不上比 Storm 优秀。这两个框架在实时计算领域中，都很优秀，只是擅长的细分场景并不相同。Spark Streaming <strong>仅仅在吞吐量上</strong>比 Storm 要优秀。</p><h4 id="对于-Storm-来说"><a href="#对于-Storm-来说" class="headerlink" title="对于 Storm 来说"></a>对于 Storm 来说</h4><ul><li>建议在那种需要纯实时，不能忍受1秒以上延迟的场景下使用，比如实时金融系统， 要求纯实时进行金融交易和分析</li><li>如果对于实时计算的功能中，<strong>要求可靠的事务机制和可靠性机制</strong>，即<strong>数据的处理完全精准</strong>，一条也不能多，一条也不能少，也可以考虑使用 Storm</li><li>如果还需要针对高峰低峰时间段，<strong>动态调整实时计算程序的并行度</strong>，以最大限度利用集群资源（通常是在小型公司，集群资源紧张的情况），也可以考虑用 Storm</li><li>如果一个大数据应用系统，它就是<strong>纯粹的实时计算</strong>，不需要在中间执行 SQL 交互式 查询、复杂的 Transformation 算子等，那么用 Storm 是比较好的选择</li></ul><h4 id="对于Spark-Streaming来说"><a href="#对于Spark-Streaming来说" class="headerlink" title="对于Spark Streaming来说"></a>对于Spark Streaming来说</h4><ul><li>如果对上述适用于 Storm 的三点，一条都不满足的实时场景，即不要求纯实时，不要求强大可靠的事务机制，不要求动态调整并行度，那么可以考虑使用 Spark  Streaming</li><li>位于 Spark 生态技术栈中，因此 Spark Streaming 可以和 Spark Core、Spark  SQL 无缝整合，也就意味着，我们可以对实时处理出来的中间数据，立即在程序中无缝进行延迟批处理、交互式查询等操作。这个特点大大增强了 Spark Streaming 的优势和功能</li></ul>]]></content>
    
    
    <categories>
      
      <category>Big Data Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Big Data Intro - Chapter 5</title>
    <link href="/2021/09/03/Big-Data-Intro-Chapter-5/"/>
    <url>/2021/09/03/Big-Data-Intro-Chapter-5/</url>
    
    <content type="html"><![CDATA[<h1 id="第05章-MapReduce和Yarn技术原理"><a href="#第05章-MapReduce和Yarn技术原理" class="headerlink" title="第05章 MapReduce和Yarn技术原理"></a>第05章 MapReduce和Yarn技术原理</h1><h2 id="Part-1-MapReduce-和-YARN-基本介绍"><a href="#Part-1-MapReduce-和-YARN-基本介绍" class="headerlink" title="Part 1 MapReduce 和 YARN 基本介绍"></a>Part 1 MapReduce 和 YARN 基本介绍</h2><h3 id="MapReduce-概述"><a href="#MapReduce-概述" class="headerlink" title="MapReduce 概述"></a>MapReduce 概述</h3><p><strong>MR</strong> 用于大规模数据集（大于1TB）的并行计算和离线计算，具有如下特点：</p><ul><li>高度抽象的编程思想：程序员仅需描述做什么，具体怎么做交由系统的执行框架处理</li><li>良好的扩展性：可通过添加节点以线性扩展集群能力</li><li>高容错性：通过计算迁移或数据迁移等策略提高集群的可用性与容错性</li></ul><p>简而言之，三个作用——</p><ul><li><strong>MapReduce</strong> 是一个<strong>基于集群的高性能并行计算平台</strong></li><li><strong>MapReduce</strong> 是一个<strong>并行计算与运行软件框架</strong></li><li><strong>MapReduce</strong> 是一个<strong>并行程序设计模型与方法</strong></li></ul><h3 id="资源调度与分配"><a href="#资源调度与分配" class="headerlink" title="资源调度与分配"></a>资源调度与分配</h3><p>随着大数据分析的蓬勃发展，就需要更加多样性的分布式编程范式，比如实时数据处理、内存计算、图计算等等。</p><p>编程范式的多样化对运行时环境提出了更大的挑战，即运行时环境需要更通用，以支持不同的编程模型，而不是像 <strong>mapreduce</strong> 框架那样只支持 <strong>mapreduce</strong> 这种编程范式。</p><p>不同的编程范式，或者说不同的计算任务，对资源（如CPU、内存）的需求是不同的，因此需要优秀的调度策略，在满足应用的特殊需求的情况下，最大化利用资源，同时也需要做好任务之间的隔离，避免相互影响。</p><p><strong>MRv1</strong> 中存在着不足——</p><ol><li>单点 master 故障的不可靠问题（依赖于周期性 checkpoint）</li><li>没有区分<strong>作业调度和资源调度</strong></li><li>没有提到<strong>资源隔离与安全性</strong></li></ol><h3 id="YARN-概述"><a href="#YARN-概述" class="headerlink" title="YARN 概述"></a>YARN 概述</h3><p><strong>YARN（Yet Another Resource Negotiator）</strong> 是一个<strong>通用资源管理系统</strong>，可为上层应用提供统一的资源管理和调度。</p><p>并且优于 <strong>Yarn</strong> 是轻量级弹性计算平台，除了 MapReduce 框架，还可以支持其他框架，比如 Spark、 Storm 等。多种框架统一管理，共享集群资源：</p><ul><li>资源利用率高</li><li>运维成本低</li><li>数据共享方便</li></ul><h2 id="Part-2-MapReduce-和-YARN-功能与架构"><a href="#Part-2-MapReduce-和-YARN-功能与架构" class="headerlink" title="Part 2 MapReduce 和 YARN 功能与架构"></a>Part 2 MapReduce 和 YARN 功能与架构</h2><h3 id="MapReduce-过程"><a href="#MapReduce-过程" class="headerlink" title="MapReduce 过程"></a>MapReduce 过程</h3><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210903112315362.png" alt="MapReduce工作流程"></p><p><strong>MapReduce</strong> 计算过程可具体分为两个阶段，<strong>Map</strong> 阶段和 <strong>Reduce</strong> 阶段，其中 <strong>Map</strong> 阶段输出的结果就是 <strong>Reduce</strong> 阶段的输入——</p><ul><li><strong>Map</strong> 阶段面对的是杂乱无章的互不相关的数据，它解析每个数据，从中提取出 <strong>key 和 Value</strong>，也就是提取了<strong>数据的特征</strong></li><li><strong>Reduce</strong> 阶段数据是以 <strong>key</strong> 后面跟着若干个 <strong>value</strong> 来组织的，这些 <strong>value</strong> 具有 <strong>相关性</strong>。在此基础上我们可以做进一步的处理以便得到结果</li></ul><p>同时，<strong>MapReduce</strong> 工作流程也具有一定的特点——</p><ul><li>不同的 <strong>Map</strong> 任务之间<strong>不会进行通信</strong></li><li>不同的 <strong>Reduce</strong> 任务之间也<strong>不会发生任何信息交换</strong></li><li>用户<strong>不能显式地</strong>从一台机器向另一台机器发送消息</li><li><strong>所有的数据交换</strong>都是通过 <strong>MapReduce</strong> 框架<strong>自身</strong>去实现的</li></ul><h4 id="Map-阶段详解"><a href="#Map-阶段详解" class="headerlink" title="Map 阶段详解"></a>Map 阶段详解</h4><p><strong>Job</strong> 提交前，先将待处理的文件进行<strong>分片（Split）</strong>，<strong>MR</strong> 框架默认将一个<strong>块（Block）</strong>作为一个分片。客户端应用可以重新定义<strong>块与分片的映射关系</strong></p><p><strong>Map</strong> 阶段先把数据放入一个环形内存缓冲区，当缓冲区数据达到 80% 左右时发生<strong>溢写（Spill）</strong>，需将缓冲区中的数据写入到本地磁盘，生成 <strong>MapOutFile（MOF）</strong></p><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210903113350466.png" alt="Map 阶段"></p><p><strong>写入本地磁盘之前</strong>通常需要做如下处理</p><ul><li><strong>分区 (Partition)：</strong>默认采用 <strong>Hash 算法</strong>进行分区，<strong>MR</strong> 框架根据 <strong>Reduce Task</strong> 个数来确定分区个数。具备相同 <strong>Key</strong> 值的记录最终被送到相同的 <strong>Reduce Task</strong> 来处理</li><li><strong>排序 (Sort)：</strong>将Map输出的记录排序<ul><li>例如将 (‘Hi’，’1’)，(‘Hello’，’1’) 重新排序为 (‘Hello’，’1’)，(’Hi’，’1’)</li></ul></li><li><strong>组合 (Combine)：</strong>这个动作MR框架默认是可选的<ul><li>例如将 (’Hi’，’1’)，(’Hi’，’1’)，(‘Hello’，’1’)，(Hello’，’1’)进行合并操作为 (’Hi’，’2’)，(‘Hello’，’2’)</li></ul></li><li><strong>合并 (Spill)：</strong> <strong>Map Task</strong> 在处理后会产生很多的<strong>溢出文件（spill file）</strong>，这时需将多个溢出文件进行合并处理，生成一个经过<strong>分区和排序的Spill File (MOF:MapOutFile)</strong><ul><li>为减少写入磁盘的数据量，MR 支持对 MOF 进行压缩后再写入</li></ul></li></ul><p><strong>合并（Combine）和归并（Merge）</strong>的区别，在于对两个键值对 &lt;“a”，1&gt; 和 &lt;“a”，1&gt; 来说：</p><ul><li>如果合并，会得到&lt;“a”，2&gt;</li><li>如果归并，会得到 &lt;“a”，&lt;1，1&gt;&gt;</li></ul><h4 id="Reduce-阶段详解"><a href="#Reduce-阶段详解" class="headerlink" title="Reduce 阶段详解"></a>Reduce 阶段详解</h4><p>在 <strong>Map</strong> 阶段我们提到 <strong>MOF</strong> 文件是经过排序处理的。当 <strong>Reduce Task</strong> 接受的数据量不大时，则直接存放在<strong>内存缓冲区</strong>中。</p><p>随着缓冲区文件的增多，<strong>MR</strong> 后台线程将他们合并成一个更大的有序文件，这便是 <strong>Reduce</strong> 阶段的 <strong>Merge</strong> 操作，过程中会产生许多中间文件，最后一次合并的结果直接输出到用户自定义的 <strong>Reduce</strong> 函数</p><p>当数据很少时，不需要溢写到磁盘，直接<strong>在缓存中归并</strong>，然后输出给<strong>Reduce</strong></p><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210903114440651.png" alt="Reduce 阶段"></p><p>通常在 <strong>Map Task</strong> 任务完成 <strong>MOF</strong> 输出进度到 3% 时启动 <strong>Reduce</strong>，从各个 <strong>Map Task</strong> 获取<strong>MOF</strong> 文件。前面提到 <strong>Reduce Task</strong> 个数由客户端决定，<strong>Reduce Task</strong> 个数决定 <strong>MOF</strong> 文件分区数。 因此 <strong>Map Task</strong> 输出的 <strong>MOF</strong> 文件都能找到相对应的 <strong>Reduce Task</strong>来处理</p><h3 id="Shuffle-过程"><a href="#Shuffle-过程" class="headerlink" title="Shuffle 过程"></a>Shuffle 过程</h3><p><strong>Shuffle</strong> 的定义：<strong>Map</strong> 阶段和 <strong>Reduce</strong> 阶段之间<strong>传递中间数据</strong>，包括 <strong>Reduce Task</strong> 从各个 <strong>Map Task</strong> 获取 <strong>MOF</strong> 文件的过程，以及对 <strong>MOF</strong> 的排序与合并处理</p><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210903114933804.png" alt="Shuffle 过程"></p><p>其中——</p><ul><li>文件归并时，如果溢写文件数量大于预定值（默认是3）则可以再次启动 Combiner，少于 3 不需要</li><li><strong>JobTracker</strong> 会一直监测 <strong>Map</strong> 任务的执行，并通知 <strong>Reduce</strong> 任务来领取数据</li><li><strong>Reduce</strong> 任务通过 <strong>RPC</strong> 向 <strong>JobTracker</strong> 询问 <strong>Map</strong> 任务是否已经完成；若完成，则领取数据</li><li><strong>Reduce</strong> 领取数据先放入缓存，来自不同 <strong>Map</strong> 机器，<strong>先归并，再合并</strong>，写入磁盘</li><li><strong>多个溢写文件</strong>归并成一个或多个大文件，文件中的<strong>键值对是排序过的</strong></li></ul><h3 id="一个典型的-WordCount-案例"><a href="#一个典型的-WordCount-案例" class="headerlink" title="一个典型的 WordCount 案例"></a>一个典型的 WordCount 案例</h3><h4 id="程序功能"><a href="#程序功能" class="headerlink" title="程序功能"></a>程序功能</h4><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210903115517116.png" alt="WordCount程序功能"></p><h4 id="Map-过程"><a href="#Map-过程" class="headerlink" title="Map 过程"></a>Map 过程</h4><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210903115627322.png" alt="Map 过程"></p><h4 id="Reduce-过程"><a href="#Reduce-过程" class="headerlink" title="Reduce 过程"></a>Reduce 过程</h4><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210903115652172.png" alt="Reduce 过程"></p><h3 id="YARN-组件架构"><a href="#YARN-组件架构" class="headerlink" title="YARN 组件架构"></a>YARN 组件架构</h3><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210903115841245.png" alt="Yarn 工作流程"></p><p>在图中有两个客户端向 <strong>Yarn</strong> 提交任务，蓝色表示一个任务流程，棕色表示另一个任务流程</p><ul><li>首先 <strong>client</strong> 提交任务，<strong>ResourceManager</strong> 接收到任务，然后启动并监控起来的第一个 <strong>Container</strong>，也就是 <strong>Application Master</strong></li><li><strong>Application Master</strong> 通知 <strong>NodeManager</strong> 管理资源并启动其他 <strong>Container</strong></li><li>任务最终是运行在 <strong>Container</strong> 当中。</li></ul><h3 id="MapReduce-On-YARN"><a href="#MapReduce-On-YARN" class="headerlink" title="MapReduce On YARN"></a>MapReduce On YARN</h3><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210903121324145.png" alt="MapReduce On YARN"></p><ol><li>用户向 <strong>YARN</strong> 中提交应用程序， 其中包括 <strong>ApplicationMaster</strong> 程序、启动 <strong>ApplicationMaster</strong> 的命令、用户程序等</li><li><strong>ResourceManager</strong> 为该应用程序分配第一个 <strong>Container</strong>， 并与对应的 <strong>NodeManager</strong> 通信，要求它在这个 <strong>Container</strong> 中启动应用程序的 <strong>ApplicationMaster</strong> </li><li><strong>ApplicationMaster</strong> 首先向 <strong>ResourceManager</strong> 注册， 这样用户可以直接通过 <strong>ResourceManager</strong> 查看应用程序的运行状态，然后它将为各个任务申请资源，并监控它的运行状态，直到运行结束，即<strong>重复 4~7</strong></li><li><strong>ApplicationMaster</strong> 采用轮询的方式通过 <strong>RPC</strong> 协议向 <strong>ResourceManager</strong> 申请和领取资源</li><li>一旦 <strong>ApplicationMaster</strong> 申请到资源后，便与对应的 <strong>NodeManager</strong> 通信，要求它启动任务</li><li><strong>NodeManager</strong> 为任务设置好运行环境（包括环境变量、JAR 包、二进制程序等） 后，将任务启动命令写到一个脚本中，并通过运行该脚本启动任务</li><li>各个任务通过某个 <strong>RPC</strong> 协议向 <strong>ApplicationMaster</strong> 汇报自己的状态和进度，以让 <strong>ApplicationMaster</strong> 随时掌握各个任务的运行状态，从而可以在任务失败时重新启动任务。 在应用程序运行过程中，用户可随时通过 <strong>RPC</strong> 向 <strong>ApplicationMaster</strong> 查询应用程序的当前运行状态</li><li>应用程序运行完成后，<strong>ApplicationMaster</strong> 向 <strong>ResourceManager</strong> 注销并关闭自己</li></ol><h3 id="YARN-HA-方案"><a href="#YARN-HA-方案" class="headerlink" title="YARN HA 方案"></a>YARN HA 方案</h3><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210903122041042.png" alt="YARN HA 方案"></p><p><strong>YARN</strong> 中的 <strong>ResourceManager</strong> 负责整个集群的<strong>资源管理和任务调度</strong>，<strong>YARN</strong> 高可用性方案通过引入冗余的 <strong>ResourceManager</strong> 节点的方式，解决了 <strong>ResourceManager</strong> 单点故障问题。</p><p>在未开启自动故障转移时，<strong>Yarn</strong> 集群启动后，管理员需要在命令行中使用 <code>yarn rmadmin</code> 命令手动将其中一个 <strong>ResourceManager</strong> 切换为 <strong>Active</strong> 状态。</p><ul><li>当需要执行计划性维护或故障发 生时，则需要先手动将 <strong>Active</strong> 状态的 <strong>ResourceManager</strong> 切换为 <strong>Standby</strong> 状态，再将另一个 <strong>ResourceManager</strong> 切换为 <strong>Active</strong> 状态。</li></ul><p>开启自动故障转移后，<strong>ResourceManager</strong> 会通过内置的基于 <strong>ZooKeeper</strong> 实现的  <strong>ActiveStandbyElector</strong> 来决定哪一个 <strong>ResouceManager</strong> 应该成为 <strong>Active</strong> 节点。</p><ul><li>当 <strong>Active</strong> 状态的 <strong>ResourceManager</strong> 发生故障时，另一个 <strong>ResourceManager</strong> 将自动被选举为 <strong>Active</strong> 状态以接替故障节点。</li></ul><p>当集群的 <strong>ResourceManager</strong> 以 <strong>HA</strong> 方式部署时，客户端使用的 <strong>“yarn-site.xml”</strong> 需要配置所有 <strong>ResourceManager</strong> 地址。</p><p><strong>客户端（包括 ApplicationMaster 和 NodeManager）</strong>会以轮询的方式寻找 <strong>Active</strong> 状态的 <strong>ResourceManager</strong>。</p><ul><li>如果当前 <strong>Active</strong> 状态的 <strong>ResourceManager</strong> 无法连接，那么会继续使用轮询的方式找到新的 <strong>ResourceManager</strong>。</li></ul><h3 id="YARN-ApplicationMaster-容错机制"><a href="#YARN-ApplicationMaster-容错机制" class="headerlink" title="YARN ApplicationMaster 容错机制"></a>YARN ApplicationMaster 容错机制</h3><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210903122653120.png" alt="YARN ApplicationMaster 容错机制"></p><p>在 <strong>YARN</strong> 中，<strong>ApplicationMaster</strong> 与其他 <strong>Container</strong> 类似也运行在 <strong>NodeManager</strong> 上（忽略未管理的AM）。AM 可能会由于多种原因崩溃、退出或关闭。</p><ul><li>如果 AM 停止运行， ResourceManager 会关闭 <strong>ApplicationAttempt</strong> 中管理的所有 Container，包括当前任务在 NodeManager 上正在运行的<strong>所有 Container</strong>。</li><li>RM 会在另一计算节点上启动新的 <strong>ApplicationAttempt</strong>。</li></ul><p>不同类型的应用希望以多种方式处理 AM 重新启动的事件。<strong>MapReduce</strong> 类应用<strong>目标是不丢失任务状态</strong>，但也<strong>能允许一部分</strong>的状态损失。</p><ul><li>对于<strong>长周期的服务</strong>而言，用户并不希望仅仅由于 AM 的故障而导致整个服务停止运行。</li></ul><p><strong>YARN</strong> 支持在新的 <strong>ApplicationAttempt</strong> 启动时，保留之前 <strong>Container</strong> 的状态，因此运行中的作业可以继续无故障的运行</p><h2 id="Part-3-YARN-的资源管理和任务调度"><a href="#Part-3-YARN-的资源管理和任务调度" class="headerlink" title="Part 3 YARN 的资源管理和任务调度"></a>Part 3 YARN 的资源管理和任务调度</h2><h3 id="资源管理"><a href="#资源管理" class="headerlink" title="资源管理"></a>资源管理</h3><p>每个 <strong>NodeManager</strong> 可分配的<strong>内存和CPU</strong>的数两可以通过配置选项设置（可在 YARN 服务配置页面配置）</p><ul><li><strong>yarn.nodemanager.resource.memory-mb：</strong>表示用于当前 NodeManager 上可以分配给容器的物理内存的大小，单位：MB。<ul><li>必须小于NodeManager服务器上的实际内存大小</li></ul></li><li><strong>yarn.nodemanager.vmem-pmem-ratio：</strong>表示为容器设置内存限制时虚拟内存跟物理内存的比值。<ul><li>容器分配值使用物理内存表示的，虚拟内存使用率超过分配值的比例不允许大于当前这个比例</li></ul></li><li><strong>yarn.nodemanager.resource.cpu-vcore：</strong>表示可分配给container的CPU核数。<ul><li>建议配置为 CPU 核数的 1.5-2 倍</li></ul></li></ul><h3 id="YARN-的三种资源调度器"><a href="#YARN-的三种资源调度器" class="headerlink" title="YARN 的三种资源调度器"></a>YARN 的三种资源调度器</h3><p>在 <strong>YARN</strong> 中，负责给引用分配资源的组件叫做 <strong>Scheduler</strong>，根据不同的策略，共有三种调度器可供选择——</p><ol><li><strong>FIFO Scheduler：</strong>队列式分配资源，把应用按提交顺序排成队列，待头应用需求满足后再给下一个分配，以此类推</li><li><strong>Capacity Scheduler：</strong>允许多个组织共享整个集群，每个组织可以获得集群的一部分计算能力<ul><li>通过为每个组织分配专门的队列，然后再为每个队列分配一定的集群资源</li><li>通过设置多个队列的方式给多个组织提供服务</li><li>除此之外，队列内部又可以垂直划分，这样一个组织内部的多个成员就可以共享这个队列资源了</li><li>队列内部采用 <strong>FIFO</strong> 策略进行资源调度</li></ul></li><li><strong>Fair Scheduler：</strong>为所有的应用分配公平的资源（对公平的定义可以通过参数来设置）</li></ol><p>生产上常用 <strong>Capacity Scheduler</strong></p><h4 id="容量调度器的介绍-——-Capacity-Scheduler"><a href="#容量调度器的介绍-——-Capacity-Scheduler" class="headerlink" title="容量调度器的介绍 —— Capacity Scheduler"></a>容量调度器的介绍 —— Capacity Scheduler</h4><p>容量调度器使得 <strong>Hadoop</strong> 应用能够<strong>共享的、多用户的、操作简便的</strong>运行在集群上</p><ul><li>同时最大化集群的吞吐量和利用率</li></ul><p>容量调度器以<strong>队列为单位</strong>划分资源，每个队列都有资源使用的上下限</p><ul><li>每个用户可以设定资源使用上线</li><li>管理员可以约束单个队列、用户或作业的资源使用</li><li>支持作业优先级，但不支持资源抢占</li></ul><p>在 <strong>Hadoop 3.x</strong> 中，<strong>OrgQueue</strong> 扩展了容量调度器，通过 <strong>REST API</strong> 提供了以编程的方式来改变队列的配置。这样，管理员可以在队列的 <strong>administer——queue ACL</strong> 中自动进行队列配置管理</p><h3 id="资源分配模型"><a href="#资源分配模型" class="headerlink" title="资源分配模型"></a>资源分配模型</h3><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210903124812188.png" alt="资源分配模型"></p><p>调度器维护一群队列的信息，用户可以为一个或多个队列提交应用。</p><p>每次 <strong>NM</strong> 心跳时，调度器根据一定的规则选择一个队列，再在队列上选择一个应用，尝试在这个一个用上分配资源。</p><p>调度器会优先匹配本地资源的申请请求，其次是同机架，最后是任意机器的。</p><h2 id="Part-4-华为大数据平台增强特性"><a href="#Part-4-华为大数据平台增强特性" class="headerlink" title="Part 4 华为大数据平台增强特性"></a>Part 4 华为大数据平台增强特性</h2><h3 id="YARN-动态内存管理"><a href="#YARN-动态内存管理" class="headerlink" title="YARN 动态内存管理"></a>YARN 动态内存管理</h3><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210903125047785.png" alt="YARN 动态内存管理"></p><p>动态内存管理可用来优化 NodeManager 中 Containers 的内存利用率。任务在运行过程中可能产生多个 Container</p><p>当前，当单个节点上的 Container 超过 Container 运行内存大小时，即使节点总的配置内存 利用还很低，NodeManager 也会终止这些 Containers。这样就会经常使用户作业失败</p><p>动态内存管理特性在当前是一个改进，只有当 NodeManager 中的所有 Containers 的总内存使用超过了已确定的阈值，那么那些内存使用过多的 Containers 才会被终止。</p><p>NM 总内存阈值（单位GB）的计算方法是 :</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">yarn</span>.nodemanager.resource.memory-mb * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span> * yarn.nodemanager.dynamic.memory.usage.threshold<br></code></pre></td></tr></table></figure><h3 id="YARN-基于标签调度"><a href="#YARN-基于标签调度" class="headerlink" title="YARN 基于标签调度"></a>YARN 基于标签调度</h3><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210903125453839.png" alt="YARN 基于标签调度"></p><p><strong>Label based scheduling</strong> 是一种调度策略。该策略的基本思想是：</p><ul><li>用户可以为每个 nodemanager 标注一个标签，比如 high-memory，high-IO 等进行分类，以表明该 nodemanager 的特性</li><li>同时，用户可以为调度器中每个队列标注一个标签，即队列与标签绑定</li><li>这样，提交到某个队列中的作业，只会使用标注有对应标签的节点上的资源，即任务实际运行在打有对应标签的节点上</li></ul><p>在没有标签调度之前，任务提交到哪个节点上是无法控制的，会根据一些算法及条件，集 群随机分配到某些节点上。而标签调度<strong>可以指定任务提交到哪些节点</strong>上</p><ul><li>比如之前需要消耗高内存的应用提交上来，由于运行在那些节点不可控，任务可能运行在普通性能的机器上</li><li>将耗内存消耗型的任务提交到绑定了 <strong>high-memry</strong> 的标签的队列上，那么任务就可以运行在 高内存机器上</li></ul>]]></content>
    
    
    <categories>
      
      <category>Big Data Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Notes - 415</title>
    <link href="/2021/09/03/LeetCode-Notes-415/"/>
    <url>/2021/09/03/LeetCode-Notes-415/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-Notes-415"><a href="#Leetcode-Notes-415" class="headerlink" title="Leetcode Notes - 415"></a>Leetcode Notes - 415</h1><p>题目：<strong>415. 字符串相加</strong></p><p>难度：<strong>简单</strong></p><p>遇见次数：<strong>第二次</strong></p><p>涉及知识点：</p><ul><li>模拟</li><li>字符串四则运算</li></ul><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="1-模拟"><a href="#1-模拟" class="headerlink" title="1. 模拟"></a>1. 模拟</h3><p>很拉的模拟😥</p><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210903162803616.png" alt="自己的模拟"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">addStrings</span><span class="hljs-params">(String num1, String num2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(num1.length() &lt; num2.length()) <span class="hljs-keyword">return</span> addStrings(num2, num1);<br>        <br>        <span class="hljs-keyword">while</span>(num2.length() &lt; num1.length())&#123;<br>            num2 = <span class="hljs-string">&quot;0&quot;</span> + num2;<br>        &#125;<br>        <br>        String ans = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">int</span> len = num1.length();<br>        <span class="hljs-keyword">boolean</span> addOn = <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">char</span>[] chArr1 = num1.toCharArray();<br>        <span class="hljs-keyword">char</span>[] chArr2 = num2.toCharArray();<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = len - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123;<br>            <span class="hljs-keyword">int</span> cur = Integer.parseInt(Character.toString(chArr1[i])) + Integer.parseInt(Character.toString(chArr2[i]));<br>            <br>            <span class="hljs-keyword">if</span>(addOn)&#123;<br>                cur++;<br>                addOn = <span class="hljs-keyword">false</span>;<br>            &#125;<br>            <br>            <span class="hljs-comment">// Check whether cur is bigger than 9</span><br>            <span class="hljs-keyword">if</span>(cur &gt; <span class="hljs-number">9</span>)&#123;<br>                addOn = <span class="hljs-keyword">true</span>;<br>                cur = cur - <span class="hljs-number">10</span>;<br>            &#125;<br>            <br>            ans = String.format(<span class="hljs-string">&quot;%d&quot;</span>, cur) + ans;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> addOn ? <span class="hljs-string">&quot;1&quot;</span> + ans : ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h3><h4 id="思路及算法"><a href="#思路及算法" class="headerlink" title="思路及算法"></a>思路及算法</h4><p>利用负数位返回零来作为补零操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">addStrings</span><span class="hljs-params">(String num1, String num2)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> i = num1.length() - <span class="hljs-number">1</span>, j = num2.length() - <span class="hljs-number">1</span>, add = <span class="hljs-number">0</span>;<br>        StringBuffer ans = <span class="hljs-keyword">new</span> StringBuffer();<br>        <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span> || j &gt;= <span class="hljs-number">0</span> || add != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">int</span> x = i &gt;= <span class="hljs-number">0</span> ? num1.charAt(i) - <span class="hljs-string">&#x27;0&#x27;</span> : <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">int</span> y = j &gt;= <span class="hljs-number">0</span> ? num2.charAt(j) - <span class="hljs-string">&#x27;0&#x27;</span> : <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">int</span> result = x + y + add;<br>            ans.append(result % <span class="hljs-number">10</span>);<br>            add = result / <span class="hljs-number">10</span>;<br>            i--;<br>            j--;<br>        &#125;<br>        <span class="hljs-comment">// 计算完以后的答案需要翻转过来</span><br>        ans.reverse();<br>        <span class="hljs-keyword">return</span> ans.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Notes - 409</title>
    <link href="/2021/09/03/LeetCode-Notes-409/"/>
    <url>/2021/09/03/LeetCode-Notes-409/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-Notes-409"><a href="#Leetcode-Notes-409" class="headerlink" title="Leetcode Notes - 409"></a>Leetcode Notes - 409</h1><p>题目：<strong>409. 最长回文串</strong></p><p>难度：<strong>简单</strong></p><p>遇见次数：<strong>第二次</strong></p><p>涉及知识点：</p><ul><li>贪心</li><li>字符串</li></ul><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="1-哈希表"><a href="#1-哈希表" class="headerlink" title="1. 哈希表"></a>1. 哈希表</h3><p>效率不咋地的哈希🛬</p><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210903164227533.png" alt="哈希表"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        Map&lt;Character, Integer&gt; mp = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> ch : s.toCharArray())&#123;<br>            <span class="hljs-keyword">int</span> cur = mp.getOrDefault(ch, <span class="hljs-number">0</span>);<br><br>            mp.put(ch, cur + <span class="hljs-number">1</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">boolean</span> center = <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> ele : mp.keySet())&#123;<br>            <span class="hljs-keyword">int</span> cur = mp.get(ele);<br><br>            <span class="hljs-keyword">if</span>(cur % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)&#123;<br>                count += cur;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">if</span>(center)&#123;<br>                    count = count + cur - <span class="hljs-number">1</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span>&#123;<br>                    count += cur;<br>                    center = <span class="hljs-keyword">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h3><h4 id="思路及算法"><a href="#思路及算法" class="headerlink" title="思路及算法"></a>思路及算法</h4><p>对于每个字符 ch，假设它出现了 v 次，我们可以使用该字符 v / 2 * 2 次，在回文串的左侧和右侧分别放置 v / 2 个字符 ch，其中 / 为整数除法。例如若 “a” 出现了 5 次，那么我们可以使用 “a” 的次数为 4，回文串的左右两侧分别放置 2 个 “a”。</p><p>如果有任何一个字符 ch 的出现次数 v 为奇数（即 v % 2 == 1），那么可以将这个字符作为回文中心，注意只能最多有一个字符作为回文中心。在代码中，我们用 ans 存储回文串的长度，由于在遍历字符时，ans 每次会增加 v / 2 * 2，因此 ans 一直为偶数。但在发现了第一个出现次数为奇数的字符后，我们将 ans 增加 1，这样 ans 变为奇数，在后面发现其它出现奇数次的字符时，我们就不改变 ans 的值了。</p><blockquote><p>很巧妙的利用了语言整除中 round 的特性，就不用再像我那样做判断了</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[] count = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">128</span>];<br>        <span class="hljs-keyword">int</span> length = s.length();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; length; ++i) &#123;<br>            <span class="hljs-keyword">char</span> c = s.charAt(i);<br>            count[c]++;<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> v: count) &#123;<br>            ans += v / <span class="hljs-number">2</span> * <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (v % <span class="hljs-number">2</span> == <span class="hljs-number">1</span> &amp;&amp; ans % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br>                ans++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br><br>作者：LeetCode-Solution<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/longest-palindrome/solution/zui-chang-hui-wen-chuan-by-leetcode-solution/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Notes - 560</title>
    <link href="/2021/09/02/LeetCode-Notes-560/"/>
    <url>/2021/09/02/LeetCode-Notes-560/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-Notes-560"><a href="#Leetcode-Notes-560" class="headerlink" title="Leetcode Notes - 560"></a>Leetcode Notes - 560</h1><p>题目：<strong>560. 和为K的子数组</strong></p><p>难度：<strong>中等</strong></p><p>遇见次数：<strong>第二次</strong></p><p>涉及知识点：</p><ul><li>前缀和</li><li>哈希表</li></ul><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="前缀和-哈希表优化"><a href="#前缀和-哈希表优化" class="headerlink" title="前缀和+哈希表优化"></a>前缀和+哈希表优化</h3><p>理解题解后自己写的版本👇</p><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210902122836379.png" alt="前缀和+哈希表优化"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">subarraySum</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> pre = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>        Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br><br>        map.put(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i : nums)&#123;<br>            pre = pre + i;<br>            <span class="hljs-keyword">int</span> cur = map.getOrDefault(pre, <span class="hljs-number">0</span>);<br><br>            <span class="hljs-keyword">if</span>(map.containsKey(pre - k))&#123;<br>                count = count + map.get(pre - k);<br>            &#125;<br><br>            map.put(pre, cur + <span class="hljs-number">1</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="前缀和-哈希表优化-1"><a href="#前缀和-哈希表优化-1" class="headerlink" title="前缀和+哈希表优化"></a>前缀和+哈希表优化</h3><h4 id="思路及算法"><a href="#思路及算法" class="headerlink" title="思路及算法"></a>思路及算法</h4><ol><li>每个元素对应一个 “前缀和”</li><li>遍历数组，根据当前 “前缀和”，在 map 中寻找「与之相减 == k」的历史前缀和</li><li>当前 “前缀和” 与历史前缀和，差分出一个子数组，该历史前缀和出现过 c 次，等价于当前项找到 c 个子数组求和等于 k</li><li>遍历过程中，c 不断加给 count，最后返回 count</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">subarraySum</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>, pre = <span class="hljs-number">0</span>;<br>        HashMap &lt; Integer, Integer &gt; mp = <span class="hljs-keyword">new</span> HashMap &lt; &gt; ();<br>        mp.put(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            pre += nums[i];<br>            <span class="hljs-keyword">if</span> (mp.containsKey(pre - k)) &#123;<br>                count += mp.get(pre - k);<br>            &#125;<br>            mp.put(pre, mp.getOrDefault(pre, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br><br>作者：LeetCode-Solution<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/subarray-sum-equals-k/solution/he-wei-kde-zi-shu-zu-by-leetcode-solution/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><blockquote><p>气死了！为了写这个题解我健美选修没了，淦！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Leetcode Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Notes - 238</title>
    <link href="/2021/09/02/LeetCode-Notes-238/"/>
    <url>/2021/09/02/LeetCode-Notes-238/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-Notes-238"><a href="#Leetcode-Notes-238" class="headerlink" title="Leetcode Notes -238"></a>Leetcode Notes -238</h1><p>题目：<strong>238. 除自身以外数组的乘积</strong></p><p>难度：<strong>中等</strong></p><p>遇见次数：<strong>第二次</strong></p><p>涉及知识点：</p><ul><li>数组</li></ul><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="1-双向乘法"><a href="#1-双向乘法" class="headerlink" title="1. 双向乘法"></a>1. 双向乘法</h3><p>不擦😊</p><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210902113553113.png" alt="双向乘法"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] productExceptSelf(<span class="hljs-keyword">int</span>[] nums) &#123;<br>        <span class="hljs-keyword">int</span> n = nums.length;<br>        <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br><br>        <span class="hljs-comment">// Left Multiplication</span><br>        <span class="hljs-keyword">int</span> cur = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> val = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>; l &lt; n; l++)&#123;<br>            <span class="hljs-keyword">while</span>(cur &lt; l)&#123;<br>                val *= nums[cur];<br>                cur++;<br>            &#125;<br>            res[l] = val;<br>        &#125;<br><br>        <span class="hljs-comment">// Right Multiplication</span><br>        cur = n - <span class="hljs-number">1</span>;<br>        val = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> r = n - <span class="hljs-number">1</span>; r &gt;= <span class="hljs-number">0</span>; r--)&#123;<br>            <span class="hljs-keyword">while</span>(cur &gt; r)&#123;<br>                val *= nums[cur];<br>                cur--;<br>            &#125;<br><br>            res[r] = res[r] * val;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="空间复杂度为O-1-的方法"><a href="#空间复杂度为O-1-的方法" class="headerlink" title="空间复杂度为O(1)的方法"></a>空间复杂度为O(1)的方法</h3><h4 id="思路及算法"><a href="#思路及算法" class="headerlink" title="思路及算法"></a>思路及算法</h4><p>由于输出数组不算在空间复杂度内，那么我们可以将 L 或 R 数组用输出数组来计算。先把输出数组当作 L 数组来计算，然后再动态构造 R 数组得到结果。让我们来看看基于这个思想的算法。</p><p>初始化 answer 数组，对于给定索引 i，answer[i] 代表的是 i 左侧所有数字的乘积。</p><p>构造方式与之前相同，只是我们试图节省空间，先把 answer 作为方法一的 L 数组。这种方法的唯一变化就是我们没有构造 R 数组。而是用一个遍历来跟踪右边元素的乘积。并更新数组 answer[i] = answer[i] ∗ R。然后 RR 更新为R = R ∗ nums[i]，其中变量 R 表示的就是索引右侧数字的乘积。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] productExceptSelf(<span class="hljs-keyword">int</span>[] nums) &#123;<br>        <span class="hljs-keyword">int</span> length = nums.length;<br>        <span class="hljs-keyword">int</span>[] answer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[length];<br><br>        <span class="hljs-comment">// answer[i] 表示索引 i 左侧所有元素的乘积</span><br>        <span class="hljs-comment">// 因为索引为 &#x27;0&#x27; 的元素左侧没有元素， 所以 answer[0] = 1</span><br>        answer[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; length; i++) &#123;<br>            answer[i] = nums[i - <span class="hljs-number">1</span>] * answer[i - <span class="hljs-number">1</span>];<br>        &#125;<br><br>        <span class="hljs-comment">// R 为右侧所有元素的乘积</span><br>        <span class="hljs-comment">// 刚开始右边没有元素，所以 R = 1</span><br>        <span class="hljs-keyword">int</span> R = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-comment">// 对于索引 i，左边的乘积为 answer[i]，右边的乘积为 R</span><br>            answer[i] = answer[i] * R;<br>            <span class="hljs-comment">// R 需要包含右边所有的乘积，所以计算下一个结果时需要将当前值乘到 R 上</span><br>            R *= nums[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> answer;<br>    &#125;<br>&#125;<br><br>作者：LeetCode-Solution<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/product-of-array-except-self/solution/chu-zi-shen-yi-wai-shu-zu-de-cheng-ji-by-leetcode-/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><blockquote><p>这个算是做过一次就学会了，输出数组不算入空间复杂度</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Leetcode Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Notes - 334</title>
    <link href="/2021/09/02/LeetCode-Notes-334/"/>
    <url>/2021/09/02/LeetCode-Notes-334/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-Notes-334"><a href="#Leetcode-Notes-334" class="headerlink" title="Leetcode Notes - 334"></a>Leetcode Notes - 334</h1><p>题目：<strong>334. 递增的三元子序列</strong></p><p>难度：<strong>中等</strong></p><p>遇见次数：<strong>第二次</strong></p><p>涉及知识点：</p><ul><li>贪心</li></ul><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="1-贪心-？"><a href="#1-贪心-？" class="headerlink" title="1. 贪心 ？"></a>1. 贪心 ？</h3><p>复读版本📕</p><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210902131133263.png" alt="伪DP"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">increasingTriplet</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(nums.length &lt; <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br><br>        <span class="hljs-keyword">int</span> small = Integer.MAX_VALUE;<br>        <span class="hljs-keyword">int</span> mid = Integer.MAX_VALUE;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> cur : nums)&#123;<br>            <span class="hljs-keyword">if</span>(cur &lt;= small)&#123;<br>                small = cur;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cur &lt;= mid)&#123;<br>                mid = cur;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cur &gt; mid)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h4 id="思路及算法"><a href="#思路及算法" class="headerlink" title="思路及算法"></a>思路及算法</h4><p>本题的思路非常的巧妙！</p><p>首先，新建两个变量 small 和 mid ，分别用来保存题目要我们求的长度为 3 的递增子序列的最小值和中间值。</p><p>接着，我们遍历数组，每遇到一个数字，我们将它和 small 和 mid 相比，若小于等于 small ，则替换 small；否则，若小于等于 mid，则替换 mid；否则，若大于 mid，则说明我们找到了长度为 3 的递增数组！</p><p>上面的求解过程中有个问题：当已经找到了长度为 2 的递增序列，这时又来了一个比 small 还小的数字，为什么可以直接替换 small 呢，这样 small 和 mid 在原数组中并不是按照索引递增的关系呀？</p><p>Trick 就在这里了！假如当前的 small 和 mid 为 [3, 5]，这时又来了个 1。假如我们不将 small 替换为 1，那么，当下一个数字是 2，后面再接上一个 3 的时候，我们就没有办法发现这个 [1,2,3] 的递增数组了！也就是说，我们替换最小值，是为了后续能够更好地更新中间值！</p><p>另外，即使我们更新了 small ，这个 small 在 mid 后面，没有严格遵守递增顺序，但它隐含着的真相是，有一个比 small 大比 mid 小的前·最小值出现在 mid 之前。因此，当后续出现比 mid 大的值的时候，我们一样可以通过当前 small 和 mid 推断的确存在着长度为 3 的递增序列。 所以，这样的替换并不会干扰我们后续的计算！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">increasingTriplet</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> len = nums.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">if</span> (len &lt; <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">int</span> small = INT_MAX, mid = INT_MAX;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> num : nums) &#123;<br>      <span class="hljs-keyword">if</span> (num &lt;= small) &#123;<br>        small = num;<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (num &lt;= mid) &#123;<br>        mid = num;<br>      &#125; <br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (num &gt; mid) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    <br>  &#125;<br>&#125;;<br><br>作者：fxxuuu<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/increasing-triplet-subsequence/solution/c-xian-xing-shi-jian-fu-za-du-xiang-xi-jie-xi-da-b/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Big Data Intro - Chapter 4</title>
    <link href="/2021/09/02/Big-Data-Intro-Chapter-4/"/>
    <url>/2021/09/02/Big-Data-Intro-Chapter-4/</url>
    
    <content type="html"><![CDATA[<h1 id="第04章-HBase技术原理"><a href="#第04章-HBase技术原理" class="headerlink" title="第04章 HBase技术原理"></a>第04章 HBase技术原理</h1><h2 id="Part-1-HBase-基本介绍"><a href="#Part-1-HBase-基本介绍" class="headerlink" title="Part 1 HBase 基本介绍"></a>Part 1 HBase 基本介绍</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><strong>HBase</strong> 是一个<strong>高可靠性、高性能、面向列、可伸缩</strong>的分布式存储系统</p><ul><li>适合于<strong>存储大表数据（表的规模可以达到数十亿行以及数百万列）</strong>，并且对达标数据的读、写访问可以达到<strong>实时级别</strong><ul><li>补充：<strong>BigTable结构</strong>，是一个<strong>疏松的分布式的持久的多维排序的map</strong></li><li>这个行map有<strong>行键、列键和时间戳索引</strong>，每一个值都是连续的byte数组</li></ul></li><li>利用 <strong>HDFS</strong> 作为其文件存储系统，提供实时读写的分布式操作系统</li><li>利用 <strong>Zookeeper</strong> 作为协同服务<ul><li>分布式锁</li><li>事件监控</li><li>存储HBase的Region Server数据，充当微型数据库</li></ul></li></ul><h3 id="HBase-与-RDB-的对比"><a href="#HBase-与-RDB-的对比" class="headerlink" title="HBase 与 RDB 的对比"></a>HBase 与 RDB 的对比</h3><h4 id="1-数据索引"><a href="#1-数据索引" class="headerlink" title="1. 数据索引"></a>1. 数据索引</h4><p>关系数据库通常可以针对不同列构建复杂的多个索引，以提高数据访问性能</p><p>HBase只有一个索引——行键，通过巧妙的设计，HBase中的所有访问方法，或者通过行键访问，或者通过行键扫描，从而使得整个系统不会慢下来</p><h4 id="2-数据维护"><a href="#2-数据维护" class="headerlink" title="2. 数据维护"></a>2. 数据维护</h4><p>在关系数据库中，更新操作会用最新的当前值去替换记录中原来的旧值，旧值被覆盖后就不会存在</p><p>在HBase中执行更新操作时，并不会删除数据旧的版本，而是生成一个新的版本，旧有的版本仍然保留</p><h4 id="3-可伸缩性"><a href="#3-可伸缩性" class="headerlink" title="3. 可伸缩性"></a>3. 可伸缩性</h4><p>关系数据库很难实现横向扩展，纵向扩展的空间也比较有限</p><p>相反，HBase 和 <strong>BigTable</strong> 这些分布式数据库就是为了实现灵活的水平扩展而开发的，能够轻易地通过在集群中增加或者减少硬件数量来实现性能的伸缩</p><h2 id="Part-2-HBase-相关概念"><a href="#Part-2-HBase-相关概念" class="headerlink" title="Part 2 HBase 相关概念"></a>Part 2 HBase 相关概念</h2><h3 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h3><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210902194427988.png" alt="HBase表结构"></p><p><strong>单元格 Cell</strong>：在 HBase 表中，通过行，列族和列限定符确定一个“单元格”，单元格中存储的数据没有数据类型，总被视为<strong>字节数组byte[]</strong></p><h3 id="行存储"><a href="#行存储" class="headerlink" title="行存储"></a>行存储</h3><p>数据<strong>按行存储</strong>在底层文件系统中。通常，每一行会被分配固定的空间</p><ul><li>优点：有利于<strong>增加/修改</strong>整行记录等操作；有利于整行数据的<strong>读取操作</strong></li><li>缺点：<strong>单列查询</strong>时，会读取一些不必要的数据</li></ul><h3 id="列存储"><a href="#列存储" class="headerlink" title="列存储"></a>列存储</h3><p>HBase采用<strong>列存储</strong></p><p>数据<strong>以列单位</strong>存储在底层文件系统中</p><ul><li>优点：有利于面向单列数据的<strong>读取/统计</strong>等操作</li><li>缺点：整行读取时，可能需要多次<strong>I/O</strong>操作</li></ul><h2 id="Part-3-HBase-架构"><a href="#Part-3-HBase-架构" class="headerlink" title="Part 3 HBase 架构"></a>Part 3 HBase 架构</h2><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210902195512539.png" alt="HBase整体架构"></p><p><strong>ZooKeeper</strong> 为 HBase 集群中各进程<strong>提供分布式协作服务</strong></p><ul><li>各 <strong>RegionServer</strong> 将自己的信息注册到 <strong>Zookeeper</strong> 中，主用<strong>Master</strong>据此感知各个<strong>RegionServer</strong> 的健康状态</li></ul><p><strong>Client</strong> 使用 HBase 的<strong>RPC</strong>机制与 <strong>Master、RegionServer</strong> 进行通信</p><ul><li><strong>Client</strong> 与 <strong>Master</strong> 进行管理 类通信，与 <strong>RegionServer</strong> 进行数据操作类通信</li></ul><p><strong>RegionServer</strong> 负责提供<strong>表数据读写</strong>等服务，是 HBase 的<strong>数据处理和计算单元</strong></p><ul><li><strong>RegionServer</strong> 一般与 HDFS 集群的 <strong>DataNode</strong> 部署在一起，实现数据的存储功能</li></ul><p><strong>HMaster</strong>，在<strong>HA</strong>模式下，包含 <strong>主用Master和备用Master</strong></p><ul><li>主用Master：负责 HBase 中 RegionServer 的管理，包括表的增删改查；RegionServer 的负载均衡，Region 分布调整；Region 分裂以及分裂后的 Region 分配； RegionServer 失效后的 Region 迁移等</li><li>备用Master：当<strong>主用Master</strong>故障时，备用Master将取代主用Master对外提供服务。 <strong>故障恢复后，原主用Master降为备用</strong></li></ul><p>HDFS 为 HBase 提供<strong>高可靠的文件存储服务</strong>，HBase的数据<strong>全部存储在HDFS</strong>中</p><p>客户端并不依赖 <strong>HMaster</strong>，而是通过 <strong>Zookeeper</strong>来获得 <strong>Region</strong> 位置信息，大多数客户端甚至从来不和 <strong>HMaster</strong> 通信</p><h3 id="主要功能组件"><a href="#主要功能组件" class="headerlink" title="主要功能组件"></a>主要功能组件</h3><p><strong>1. 库函数：链接到每个客户端</strong></p><p><strong>2. 一个 HMaster 主服务器</strong></p><p><strong>3. 多个 HReigonServer</strong></p><p>两个概念——<strong>MemStore 和 StoreFile</strong></p><ul><li>当 <strong>RS</strong> 中的 <strong>MS</strong> 大小达到配置的容量上限时，<strong>RS</strong> 会将 <strong>MS</strong> 中的数据 “flush” 到 HDFS 中</li><li>随着数据的<strong>插入</strong>，一个 <strong>SF</strong> 会产生多个 <strong>SF</strong>，当 <strong>SF</strong> 的个数达到配置的最大时，<strong>RS</strong> 会将多个 <strong>SF</strong> 合并成一个大的 <strong>SF</strong></li></ul><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210902200636355.png" alt="HBase存储架构"></p><h3 id="表和Region"><a href="#表和Region" class="headerlink" title="表和Region"></a>表和Region</h3><ul><li><p>HBase 表开始只有一个 Region，后来不断分裂</p></li><li><p>Region 拆分操作非常快，接近瞬间，拆分过程中的 Region不可读，直到把 Region 存储文件 异步地写到独立的文件之后，才会读取新文件</p></li></ul><h3 id="Region-的定位"><a href="#Region-的定位" class="headerlink" title="Region 的定位"></a>Region 的定位</h3><ul><li>Region 分为 <strong>元数据Region以及用户 Region</strong> 两类</li><li><strong>Meta Region</strong> 记录了每一个 <strong>User Region</strong> 的路由信息</li><li>读写 <strong>Region</strong> 数据的路由，包括如下几步：<ul><li>找寻 <strong>Meta Region</strong> 地址</li><li>再由 <strong>Meta Region</strong> 找寻 <strong>User Region</strong> 地址</li></ul></li></ul><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>客户端包含访问 <strong>HBase</strong> 的接口，同时在缓存中维护着已经访问过的 <strong>Region</strong> 位置信息，用来加快后续数据访问过程</p><p>整体过程是——</p><ol><li>查询 <strong>hbase:meta</strong> 表</li><li>确定 <strong>Region</strong> 的位置</li><li>定位到所需要的区域后，客户端直接访问相应的 <strong>Region（不经过HMaster）</strong>，发起读写请求</li></ol><h3 id="HMaster-和-HRegionServer"><a href="#HMaster-和-HRegionServer" class="headerlink" title="HMaster 和 HRegionServer"></a>HMaster 和 HRegionServer</h3><h4 id="Master"><a href="#Master" class="headerlink" title="Master"></a>Master</h4><p>负责 <strong>表和 Region</strong> 的管理工作</p><ul><li>管理用户对表的<strong>增加、删除、修改、查询</strong>等操作</li><li>实现不同 <strong>HRegionServer</strong> 之间的负载均衡</li><li>在 <strong>Region</strong> 分裂或合并后，负责重新调整 <strong>Region</strong> 的分布</li><li>对发生故障失效的 <strong>HRegionServer</strong> 上的Region进行迁移</li></ul><p>高可用：ZK 可以帮助选举出一个 HMaster作为集群的总管，并保证在任何时刻总有唯一一个 HMaster 在运行，这就避免了 HMaster 的“单点失效”问题</p><h4 id="RegionServer"><a href="#RegionServer" class="headerlink" title="RegionServer"></a>RegionServer</h4><p>HRS 是 HBase 中最核心的模块</p><ul><li>负责维护分配给自己的 Region</li><li>响应用户的读写请求</li></ul><h2 id="Part-3-HBase-关键流程"><a href="#Part-3-HBase-关键流程" class="headerlink" title="Part 3 HBase 关键流程"></a>Part 3 HBase 关键流程</h2><h3 id="用户读写数据过程"><a href="#用户读写数据过程" class="headerlink" title="用户读写数据过程"></a>用户读写数据过程</h3><ol><li>用户写入数据时，被分配到相应 <strong>HRegionServer</strong> 去执行</li><li>用户数据首先被写入 <strong>Hlog</strong> 中，再写入 <strong>MemStore</strong> 中，最终写到磁盘上形成 <strong>StoreFile</strong></li><li>只有当操作写入 <strong>Hlog</strong> 之后，<strong>commit()</strong> 调用才会将其返回给客户端</li><li>当用户读取数据时，<strong>HRegionServer</strong> 首先访问 <strong>MemStore</strong> 缓存，如果找不到，再去磁盘上面的 <strong>StoreFile</strong> 中寻找</li></ol><h3 id="缓存的刷新"><a href="#缓存的刷新" class="headerlink" title="缓存的刷新"></a>缓存的刷新</h3><ol><li>系统会周期性地把 <strong>MemStore</strong> 缓存里的内容刷写到磁盘的 <strong>StoreFIle</strong> 文件中，清空缓存，并在 <strong>Hlog</strong> 里面写入一个标记</li><li>每次刷写都生成一个新的 <strong>StoreFile</strong> 文件，因此，每个 <strong>Store</strong> 包含多个 <strong>StoreFile</strong> 文件</li><li>每个 <strong>HRegionServer</strong> 都有一个自己的 <strong>Hlog</strong> 文件，每次启动都检查该文件，确认最近一次执行缓存刷新操作之后是否发生新的写入操作；如果发现更新，则先写入 <strong>MemStore</strong> ，再刷写到 <strong>StoreFile</strong>，开始为用户提供服务</li></ol><h3 id="StoreFile-的合并"><a href="#StoreFile-的合并" class="headerlink" title="StoreFile 的合并"></a>StoreFile 的合并</h3><ol><li>每次刷写都生成一个新的 <strong>StoreFile</strong>，数量太多，影响查找速度</li><li>调用 <strong>Store.compact()</strong> 把多个合并成一个</li><li>合并操作比较耗费资源，只有数量达到一个阈值才启动合并</li></ol><h3 id="Store-工作原理"><a href="#Store-工作原理" class="headerlink" title="Store 工作原理"></a>Store 工作原理</h3><ol><li><strong>Store</strong> 是 <strong>HRegionServer</strong> 的核心</li><li>多个 <strong>StoreFIle</strong> 合并成一个</li><li>单个 <strong>StoreFile</strong> 过大时，又触发分裂操作，一个父 <strong>Region</strong> 被分裂成两个子 <strong>Region</strong></li></ol><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210902212733671.png" alt="Store 工作原理"></p><h3 id="Hlog-工作原理"><a href="#Hlog-工作原理" class="headerlink" title="Hlog 工作原理"></a>Hlog 工作原理</h3><ol><li>分布式环境必须要考虑系统出错。HBase 采用 <strong>Hlog</strong> 保证系统恢复</li><li>HBase 系统为每个 <strong>HRegionServer</strong> 配置了一个 <strong>Hlog</strong> 文件，它是一种预写式日志（Write Ahead Log）</li><li>用户更新数据必须<strong>首先写入日志</strong>后，才能写入 <strong>MemStore</strong> 缓存，并且，知道 <strong>MemStore</strong> 缓存内容对应的日志已经写入磁盘，该缓存内容才能被刷写到磁盘</li><li><strong>Zookeeper</strong> 会实时检测每个 <strong>HRegionServer</strong> 的状态，当某个 <strong>HRegionServer</strong> 发生故障时，<strong>Zookeeper</strong> 会通知 <strong>HMaster</strong> <ul><li><strong>HMaster</strong> 会首先处理该故障 <strong>HRegionServer</strong> 上面遗留的 <strong>Hlog</strong> 文件，这个遗留的 <strong>Hlog</strong> 文件中包含了来自多个 <strong>Region</strong> 对象的日志记录</li><li>系统会根据<strong>每条日志记录所属的 Region对象</strong> 对 <strong>Hlog</strong> 进行拆分，分别放到对应 <strong>Region 对象</strong> 的目录下，然后，再将失效的 <strong>Region</strong> 重新分配到可用的 <strong>HRegionServer</strong> 中，并把该 <strong>Region对象</strong> 相关的 <strong>Hlog</strong> 日志记录也发送给相应的 <strong>HRegionServer</strong></li><li><strong>HRegionServer</strong> 领取到分配给自己的 <strong>Region</strong> 对象以及与之相关的 <strong>Hlog</strong> 日志记录以后，会重新做一遍日志记录中的各种操作，把日志记录中的数据写入到 <strong>MemStore</strong> 缓存中，然后，刷写到磁盘的 <strong>StoreFile</strong> 文件中，完成数据恢复</li></ul></li><li>共用日志<ul><li>优点：提高对表的写操作性能</li><li>缺点：恢复时需要拆分日志</li></ul></li></ol><h2 id="Part-4-HBase-突出特点"><a href="#Part-4-HBase-突出特点" class="headerlink" title="Part 4 HBase 突出特点"></a>Part 4 HBase 突出特点</h2><h3 id="多-HFile-的影响"><a href="#多-HFile-的影响" class="headerlink" title="多 HFile 的影响"></a>多 HFile 的影响</h3><p><strong>HFile</strong> 文件数目越来越多，读取的时延也越来越大。</p><h3 id="Compaction-压缩"><a href="#Compaction-压缩" class="headerlink" title="Compaction 压缩"></a>Compaction 压缩</h3><p><strong>Compaction</strong> 是为了减少同一个 <strong>Region</strong> 中同一个 <strong>ColumnFamily（列族）</strong> 下面的小文件，即 <strong>HFile</strong> 的数目，从而提升读取的性能</p><p><strong>Compaction</strong> 分为 <strong>Minor和Major</strong> 两类——</p><ul><li>Minor：小范围的压缩。有最少和最大文件数目限制。通常会选择一些<strong>连续时间范围</strong>的小文件惊醒合并</li><li>Major：设计该 <strong>Region</strong> 或者 该 <strong>CF</strong> 下面所有的 <strong>HFile</strong> 文件</li><li><strong>Minor Compaction</strong> 选取文件时，遵循一定的算法</li></ul><p><strong>Compaction</strong> 也会遵循一定的规则</p><ul><li>首先对该 Store 中所有 <strong>HFile</strong> 进行一一排查，排除不满足条件的部分文件：<ul><li>排除当前正在执行 <strong>compact</strong> 的文件及其比这些文件更新的所有文件 ( <strong>SequenceId</strong> 更大)</li><li>排除某些过大的单个文件，如果文件大小大于  <strong>hbase.hzstore.compaction.max.size</strong> (  默认 Long 最大值  )，则被排除，否则会产生大量IO消耗。</li></ul></li></ul><p>经过排除的文件称为<strong>候选文件</strong>，<strong>HBase</strong> 接下来会再判断是否满足 <strong>major compaction</strong> 条件， 如果满足，就会选择全部文件进行合并。判断条件有下面三条，只要满足其中一条就会执行<strong>major compaction</strong></p><ul><li>用户强制执行<strong>major compaction</strong></li><li>长时间没有进行 <strong>compact ( CompactionChecker 的判断条件2 )</strong> 且候选文件数小于 <strong>hbase.hstore.compaction.max (默认10)</strong></li><li><strong>Store</strong> 中含有 <strong>Reference</strong> 文件，<strong>Reference</strong> 文件是 <strong>split region</strong> 产生的临时文件，只是简单的引用文件，一般必须在 <strong>compact</strong> 过程中删除</li></ul><p>如果不满足 <strong>major compaction</strong> 条件，就必然为 <strong>minor compaction</strong></p><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210902215023011.png" alt="Compaction流程"></p><h3 id="OpenScanner"><a href="#OpenScanner" class="headerlink" title="OpenScanner"></a>OpenScanner</h3><p>在寻找到 <strong>rowkey</strong> 所对应的 <strong>RegionServer</strong> 和 <strong>Region</strong> 之后，需要打开一个查找器<strong>Scanner</strong>，由 其具体执行查找数据，<strong>Region</strong> 中会包含<strong>内存数据MemStore</strong>，文件数据<strong>HFile</strong>，那么在 <strong>open  scanner</strong> 的时候就需要分别读取这两块数据，打开对应不同的<strong>scanner</strong> 做查询操作</p><ul><li><strong>HFile</strong> 对应的 <strong>Scanner</strong> 为 <strong>StoreFIleScanner</strong></li><li><strong>MemStore</strong> 对应的 <strong>Scanner</strong> 为 <strong>MemStoreScanner</strong></li></ul><h3 id="BloomFilter"><a href="#BloomFilter" class="headerlink" title="BloomFilter"></a>BloomFilter</h3><ol><li><strong>BloomFilter</strong> 用来优化一些<strong>随机读取</strong>的场景，即 <strong>Get</strong> 场景。它可以被用来快速地判断一条用户数据在一个大的数据集合（该数据集合地大部分数据都没法被加载到内存中）中是否存在</li><li><strong>BloomFilter</strong> 在判断一个数据是否存在时，拥有一定的<strong>误判率</strong>。但对于 “用户数据 XXX不存在” 的判断结果是可信的</li><li><strong>HBase</strong> 的 <strong>BloomFilter</strong> 的相关数据，被保存在 <strong>HFile</strong></li></ol><h2 id="Part-5-HBase-性能优化"><a href="#Part-5-HBase-性能优化" class="headerlink" title="Part 5 HBase 性能优化"></a>Part 5 HBase 性能优化</h2><h3 id="行键（Row-Key）"><a href="#行键（Row-Key）" class="headerlink" title="行键（Row Key）"></a>行键（Row Key）</h3><p>行键是按照 <strong>字典排序</strong> 存储，因此，设计行键时，要充分利用这个排序特点，将经常一起读取的数据存储到一块，将最近可能被访问的数据放在一块</p><p>例子——</p><blockquote><p>如果最近写入 HBase 表中的数据是最可能被访问的，可以考虑将时间戳作为行键的一部分，由于是字典序排序，所以可以使用 Long.MAX_VALUE - timestamp 作为行键，这样能保证新写入的数据在读取时可以被快速命中</p></blockquote><h3 id="构建-HBase-二级索引"><a href="#构建-HBase-二级索引" class="headerlink" title="构建 HBase 二级索引"></a>构建 HBase 二级索引</h3><p>HBase 只有一个针对行键的索引</p><p>访问 HBase 表中的行，只有三种方式：</p><ul><li>通过单个行键访问</li><li>通过一个行键的区间来访问</li><li>全表扫描</li></ul><p><strong>Hindex</strong> 二级索引是华为公司开发的纯 Java 编写的 HBase 二级索引</p><ul><li>多个表索引</li><li>多个列索引</li><li>基于部分列值的索引</li></ul><h2 id="Part-6-HBase-常用-Shell-命令"><a href="#Part-6-HBase-常用-Shell-命令" class="headerlink" title="Part 6 HBase  常用 Shell 命令"></a>Part 6 HBase  常用 Shell 命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 创建表</span><br>create<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 列出 HBase 中所有的表信息</span><br>list<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 向表、行、列指定的单元格添加数据</span><br>put<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 流览表的相关信息</span><br>scan<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 通过表名、行、列、时间戳、时间范围和版本号来获得相应单元格的值</span><br>get<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 使表有效或无效</span><br>enable/disable<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 删除表（对应表需要先处于 diabled 状态）</span><br>drop<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Big Data Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Notes - 240</title>
    <link href="/2021/09/01/LeetCode-Notes-240/"/>
    <url>/2021/09/01/LeetCode-Notes-240/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-Notes-240"><a href="#Leetcode-Notes-240" class="headerlink" title="Leetcode Notes - 240"></a>Leetcode Notes - 240</h1><p>题目：<strong>240. 搜索二维矩阵 II</strong></p><p>难度：<strong>中等</strong></p><p>遇见次数：<strong>第二次</strong></p><p>涉及知识点：</p><ul><li>二分查找</li><li>搜索二维矩阵</li><li>搜索二叉树</li></ul><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="1-错就对了！"><a href="#1-错就对了！" class="headerlink" title="1. 错就对了！"></a>1. 错就对了！</h3><p>暴力法的废物…二分写不出来，麻了😭</p><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210901230057218.png" alt="暴力遍历"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">searchMatrix</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> c = <span class="hljs-number">0</span>; c &lt; matrix[<span class="hljs-number">0</span>].length; c++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> r = <span class="hljs-number">0</span>; r &lt; matrix.length; r++)&#123;<br>                <span class="hljs-keyword">if</span>(matrix[r][c] == target) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="剪枝"><a href="#剪枝" class="headerlink" title="剪枝"></a>剪枝</h3><h4 id="思路及算法"><a href="#思路及算法" class="headerlink" title="思路及算法"></a>思路及算法</h4><p>并不是想不到这个方法，很重要一个弯没有转过来。</p><p>就是向左向右不能是同一个单调性，于是我们有——</p><ul><li>选左上角，往右走和往下走都增大，不能选</li><li>选右下角，往上走和往左走都减小，不能选</li><li>选左下角，往右走增大，往上走减小，可选</li><li>选右上角，往下走增大，往左走减小，可选</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">searchMatrix</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>        <span class="hljs-comment">// start our &quot;pointer&quot; in the bottom-left</span><br>        <span class="hljs-keyword">int</span> row = matrix.length-<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> col = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span> (row &gt;= <span class="hljs-number">0</span> &amp;&amp; col &lt; matrix[<span class="hljs-number">0</span>].length) &#123;<br>            <span class="hljs-keyword">if</span> (matrix[row][col] &gt; target) &#123;<br>                row--;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (matrix[row][col] &lt; target) &#123;<br>                col++;<br>            &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// found it</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Notes - 435</title>
    <link href="/2021/09/01/LeetCode-Notes-435/"/>
    <url>/2021/09/01/LeetCode-Notes-435/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-Notes-435"><a href="#Leetcode-Notes-435" class="headerlink" title="Leetcode Notes - 435"></a>Leetcode Notes - 435</h1><p>题目：<strong>435. 无重叠区间</strong></p><p>难度：<strong>中等</strong></p><p>遇见次数：<strong>第二次</strong></p><p>涉及知识点：</p><ul><li>DP</li><li>贪心</li></ul><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="一直错，哭了，不会贪"><a href="#一直错，哭了，不会贪" class="headerlink" title="一直错，哭了，不会贪"></a>一直错，哭了，不会贪</h3><p>理解题解后重写版本😭</p><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210901234654745.png" alt="贪心"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">eraseOverlapIntervals</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] intervals)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(intervals.length &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        Arrays.sort(intervals, <span class="hljs-keyword">new</span> Comparator&lt;<span class="hljs-keyword">int</span>[]&gt;()&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span> <span class="hljs-params">(<span class="hljs-keyword">int</span>[] v1, <span class="hljs-keyword">int</span>[] v2)</span></span>&#123;<br>                <span class="hljs-keyword">return</span> v1[<span class="hljs-number">1</span>] - v2[<span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;);<br><br>        <span class="hljs-keyword">int</span> best = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> minRight = intervals[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; intervals.length; i++)&#123;<br>            <span class="hljs-keyword">if</span>(intervals[i][<span class="hljs-number">0</span>] &gt;= minRight)&#123;<br>                best++;<br>                minRight = intervals[i][<span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> intervals.length - best;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h3><h4 id="思路及算法"><a href="#思路及算法" class="headerlink" title="思路及算法"></a>思路及算法</h4><p>我们可以不断地寻找右端点在首个区间右端点左侧的新区间，将首个区间替换成该区间。那么当我们无法替换时，首个区间就是所有可以选择的区间中右端点最小的那个区间。因此我们将所有区间按照右端点从小到大进行排序，那么排完序之后的首个区间，就是我们选择的首个区间。</p><p>如果有多个区间的右端点都同样最小怎么办？由于我们选择的是首个区间，因此在左侧不会有其它的区间，那么左端点在何处是不重要的，我们只要任意选择一个右端点最小的区间即可。</p><p>当确定了首个区间之后，所有与首个区间不重合的区间就组成了一个规模更小的子问题。由于我们已经在初始时将所有区间按照右端点排好序了，因此对于这个子问题，我们无需再次进行排序，只要找出其中与首个区间不重合并且右端点最小的区间即可。用相同的方法，我们可以依次确定后续的所有区间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">eraseOverlapIntervals</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] intervals)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (intervals.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <br>        Arrays.sort(intervals, <span class="hljs-keyword">new</span> Comparator&lt;<span class="hljs-keyword">int</span>[]&gt;() &#123;<br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] interval1, <span class="hljs-keyword">int</span>[] interval2)</span> </span>&#123;<br>                <span class="hljs-keyword">return</span> interval1[<span class="hljs-number">1</span>] - interval2[<span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;);<br><br>        <span class="hljs-keyword">int</span> n = intervals.length;<br>        <span class="hljs-keyword">int</span> right = intervals[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (intervals[i][<span class="hljs-number">0</span>] &gt;= right) &#123;<br>                ++ans;<br>                right = intervals[i][<span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> n - ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Big Data Intro - Chapter 3</title>
    <link href="/2021/09/01/Big-Data-Intro-Chapter-3/"/>
    <url>/2021/09/01/Big-Data-Intro-Chapter-3/</url>
    
    <content type="html"><![CDATA[<h1 id="第03章-Hive分布式数据仓库"><a href="#第03章-Hive分布式数据仓库" class="headerlink" title="第03章 Hive分布式数据仓库"></a>第03章 Hive分布式数据仓库</h1><h2 id="Part1-Hive概述"><a href="#Part1-Hive概述" class="headerlink" title="Part1 Hive概述"></a>Part1 Hive概述</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Hive是基于<strong>Hadoop</strong>的<strong>数据仓库软件</strong>，可以<strong>查询和管理PB级别</strong>的分布式数据</p><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ol><li>灵活方便的ETL</li><li>支持Tez，Spark等多种计算引擎</li><li>可直接访问HDFS文件以及HBase</li><li>易用易编程</li></ol><h3 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h3><ol><li><p>Hive构建在基于<strong>静态批处理的Hadoop</strong>之上，而Hadoop通常都有<strong>较高的延迟</strong>并且在作业提交和调度的时候<strong>需要大量的开销</strong></p></li><li><p>Hive并不能在大规模数据集上实现<strong>低延迟快速的查询</strong>，并不适合低时延需求的应用，如OLTP（联合事务处理）</p><blockquote><p>例如Hive在几百MB的数据集上执行查询一般有<strong>分钟级</strong>的时间延迟。</p></blockquote></li><li><p>Hive并不提供<strong>实时的查询</strong>和<strong>基于行级的数据更新操作</strong></p></li><li><p>Hive的最佳使用场景是<strong>打出聚集的批处理作业</strong>，例如网络日志分析</p></li></ol><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol><li>高可靠与高容错<ul><li>HiveServer采用集群模式</li><li>双MetaStore</li><li>超时重试机制</li></ul></li><li>类SQL<ul><li>类似SQL语法</li><li>内置大量函数</li></ul></li><li>可扩展<ul><li>自定义存储格式</li><li>自定义函数</li></ul></li><li>多接口<ul><li>Beeline - Hive的命令行客户端</li><li>JDBC</li><li>Thrift - 一种序列化、通信协议</li><li>ODBC - 基于C/C++的数据库标准接口</li></ul></li></ol><h2 id="Part-2-Hive功能与架构"><a href="#Part-2-Hive功能与架构" class="headerlink" title="Part 2 Hive功能与架构"></a>Part 2 Hive功能与架构</h2><h3 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h3><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210901211737923.png" alt="Hive架构图"></p><p>其中需要补充的有——</p><ul><li><p>Optimizer：优化器，分为<strong>逻辑优化器和物理优化器</strong></p><blockquote><p>分别对HQL生成的执行计划和MapReduce任务进行优化</p></blockquote></li><li><p>Thrift Server：提供<strong>thrift接口</strong>，作为JDBC/ODBC接口，为用户访问提供接口</p></li><li><p>Clients：包含命令行接口Beeline和JDBC/ODBC接口，为用户访问提供接口</p></li></ul><h3 id="运行流程"><a href="#运行流程" class="headerlink" title="运行流程"></a>运行流程</h3><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210901212804665.png" alt="Hive运行流程"></p><h3 id="数据存储模型"><a href="#数据存储模型" class="headerlink" title="数据存储模型"></a>数据存储模型</h3><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210901214238333.png" alt="Hive数据存储模型"></p><p>几个基本概念——</p><ul><li><p>数据库：对应 <strong>Schema</strong>，创建表时如果不指定数据库，则默认为<strong>default</strong>数据库</p></li><li><p>表：物理概念，实际对应HDFS上的一个<strong>目录</strong></p></li><li><p>分区：对应所在表所在目下的一个<strong>子目录</strong></p><ul><li>当表格数据量较大时，可对表格进行分区处理 (Partition)</li><li>这样便于局部数据的查询操作，如按时间分区、按地域分区，将具有相同性质的数据存储到同一磁盘块上，从而加快查询效率</li></ul></li><li><p>桶：对应表或分区所在路径的一个<strong>文件</strong></p><ul><li>Hive是针对某一列进行分桶</li><li>Hive采用对列值哈希，然后除以桶的个数求余的方式决定该条记录存放在哪个桶中</li><li>分桶的好处是可以获得更高的查询处理效率。使取样更高效<ul><li>分桶的应用场景：1）数据抽样 2）提升某些查询操作效率，如：mapside join</li></ul></li></ul></li><li><p>数据的<strong>倾斜和正常</strong>：</p><ul><li><strong>倾斜：</strong>数据集中于个别字段值的场景，比如按照城市分区时，80%的数据都来自某个大城市</li><li><strong>正常：</strong>不存在倾斜的数据</li></ul></li><li><p>Hive可以创建两种表<strong>托管表和外部表</strong></p><ul><li><p>创建Hive表，Hive会将数据移动到<strong>数据仓库目录</strong></p></li><li><p>选择规则——</p><ul><li>如果<strong>所有处理都由Hive完成</strong>，建议使用<strong>托管表</strong></li><li>如果<strong>要用Hive和其他工具来处理同一个数据集</strong>，建议使用<strong>外部表</strong></li></ul></li><li><p>两者主要区别——</p><ul><li><p>Hive 创建表时</p><blockquote><ol><li>创建内部表时，会<strong>将数据移动到数据仓库</strong>指向的路径</li><li>若创建外部表，仅<strong>记录数据所在的路径， 不对数据的位置</strong>做任何改变</li></ol></blockquote></li><li><p>Hive 删除表的时</p><blockquote><ol><li>内部表的元数据和数据会被一起删除</li><li>外部表只删除元数据，不删除数据</li><li>这样外部表相对来说更加安全些，数据组织也更加灵活，方便共享源数据</li></ol></blockquote></li></ul></li></ul></li></ul><h2 id="Part-3-Hive基本操作与使用"><a href="#Part-3-Hive基本操作与使用" class="headerlink" title="Part 3 Hive基本操作与使用"></a>Part 3 Hive基本操作与使用</h2><p>详见后续博客</p>]]></content>
    
    
    <categories>
      
      <category>Big Data Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Big Data Intro - Chapter 2</title>
    <link href="/2021/08/31/Big-Data-Intro-Chapter-2/"/>
    <url>/2021/08/31/Big-Data-Intro-Chapter-2/</url>
    
    <content type="html"><![CDATA[<h1 id="第02章-HDFS分布式文件系统和ZooKeeper"><a href="#第02章-HDFS分布式文件系统和ZooKeeper" class="headerlink" title="第02章 HDFS分布式文件系统和ZooKeeper"></a>第02章 HDFS分布式文件系统和ZooKeeper</h1><h2 id="Part-1-HDFS"><a href="#Part-1-HDFS" class="headerlink" title="Part 1 - HDFS"></a>Part 1 - HDFS</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>是一种旨在商品硬件上运行的<strong>分布式文件系统</strong></p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol><li>具有<strong>高容错能力</strong>，旨在部署在低成本硬件上</li><li>提供<strong>高吞吐量的访问</strong>，适用于具有<strong>大数据集</strong>的应用程序</li><li>放宽一些<strong>POSIX</strong>要求，以实现对文件系统数据的<strong>流式访问</strong></li></ol><h3 id="不适用场景"><a href="#不适用场景" class="headerlink" title="不适用场景"></a>不适用场景</h3><h4 id="1-低时间延迟数据访问的应用（例如几十毫秒的范围）"><a href="#1-低时间延迟数据访问的应用（例如几十毫秒的范围）" class="headerlink" title="1. 低时间延迟数据访问的应用（例如几十毫秒的范围）"></a>1. 低时间延迟数据访问的应用（例如几十毫秒的范围）</h4><p><strong>原因：</strong>HDFS是为高吞吐量应用优化的，这样做会造成以<strong>高时间延迟</strong>为代价</p><h4 id="2-大量小文件"><a href="#2-大量小文件" class="headerlink" title="2. 大量小文件"></a>2. 大量小文件</h4><p><strong>原因：</strong>NameNode启动时，将文件系统的元数据加载到内存，因此文件系统所能存储的文件总数受限于NameNode内存容量。根据经验，每个文件，目录和数据块的存储信息大约占150字节，如果一百万个文件，且每个文件占一个数据块，那至少需要300MB的内存空间，但是如果存储十亿个文件，那么需要的内存空间将是非常大的。</p><h4 id="3-多用户写入，任意修改文件"><a href="#3-多用户写入，任意修改文件" class="headerlink" title="3. 多用户写入，任意修改文件"></a>3. 多用户写入，任意修改文件</h4><p><strong>原因：</strong>现在HDFS文件只有一个writer，而且写操作总是写在文件的末尾。也不支持在文件的任意位置进行修改。可能以后会支持，但相对比较低效</p><h3 id="Block-块"><a href="#Block-块" class="headerlink" title="Block - 块"></a>Block - 块</h3><blockquote><p><strong>HDFS</strong> 默认一个块 <strong>128MB</strong> ,一个文件被分成多个块，以块作为存储单位</p></blockquote><p>块的大小远远大于普通文件系统，这可以<strong>最小化寻址开销</strong></p><p>抽象的块概念可以带来以下几个明显的好处——</p><ul><li>支持大规模文件存储<ul><li>文件可以被拆分</li><li>不会受到单个节点的存储容量限制</li></ul></li><li>简化系统设计<ul><li>简化了存储管理</li><li>方便了元数据的管理</li></ul></li><li>适合数据备份<ul><li>每个块都可以冗余存储</li><li>大大提高系统的容错性和可用性</li></ul></li></ul><h3 id="基本系统架构"><a href="#基本系统架构" class="headerlink" title="基本系统架构"></a>基本系统架构</h3><p>HDFS架构包含三个部分：NameNode，DataNode，Client</p><ul><li>NameNode：NameNode用于存储、生成文件系统的元数据。运行一个实例</li><li>DataNode：DataNode用于存储实际的数据，将自己管理的数据块上报给 NameNode ，运行多个实例</li><li>Client：支持业务访问HDFS，从NameNode ,DataNode获取数据返回给业务。多个 实例，和业务一起运行</li></ul><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210831144335072.png" alt="NameNode和DataNode的关系"></p><h4 id="NameNode-——-名称节点"><a href="#NameNode-——-名称节点" class="headerlink" title="NameNode —— 名称节点"></a>NameNode —— 名称节点</h4><p>在 <strong>NameNode</strong> 中，保存了两个核心的数据结构，分别是 <strong>FsImage</strong> 和 <strong>EditLog</strong></p><ul><li><strong>FsImage</strong> 用于维护<ul><li>文件系统树</li><li>文件树中所有的文件和文件夹的元数据</li></ul></li><li>操作日志文件 <strong>EditLog</strong> 中记录了所有针对文件的创建、删除、重命名等操作</li></ul><p><strong>NameNode</strong> 还记录了每个文件中各个块所在的<strong>数据节点的位置信息</strong></p><h4 id="DataNode-——-数据节点"><a href="#DataNode-——-数据节点" class="headerlink" title="DataNode —— 数据节点"></a>DataNode —— 数据节点</h4><p>数据节点是HDFS的<strong>工作节点</strong>——负责数据的存储和读取</p><ul><li>根据 <strong>Client</strong> 或者 <strong>NameNode</strong> 的调度来进行数据的存储和检索</li><li>定期向 <strong>NameNode</strong> 发送自己所存储的块的列表</li></ul><p>每个数据节点中的数据会被保存在各自节点的本地Linux文件系统中</p><h3 id="HDFS-命名空间管理"><a href="#HDFS-命名空间管理" class="headerlink" title="HDFS 命名空间管理"></a>HDFS 命名空间管理</h3><p>首先，HDFS的命名空间包含目录、文件和块</p><p>其次，HDFS使用的是传统的<strong>分级文件体系</strong></p><p>最后，由 <strong>NameNode</strong> 负责维护文件系统命名空间</p><blockquote><p>对文件系统命名空间或其属性的任何更改均由 <strong>NameNode</strong> 记录</p></blockquote><h3 id="通信协议"><a href="#通信协议" class="headerlink" title="通信协议"></a>通信协议</h3><p>所有的HDFS通信协议都是构建在 <strong>TCP/IP</strong> 协议基础之上</p><p><strong>NN</strong> 和 <strong>DN</strong> 之间通过数据节点协议来进行交互</p><p><strong>Client</strong> 与 <strong>NN 和 DN</strong> 之间的交互是不同的——</p><ul><li>与 <strong>NN</strong> 进行交互是通过向 <strong>NN</strong> 主动发起 TCP 链接，并使用客户端协议与名称节点进行交互</li><li>与 <strong>DN</strong> 是通过<strong>RPC（Remote Procedure Call）</strong> 来实现的。</li></ul><p><strong>NameNode</strong> 不会主动发起 RPC，而是响应来自 <strong>DataNode</strong> 和 <strong>Client</strong> 的 RPC 请求</p><h3 id="单名称节点体系结构的局限性"><a href="#单名称节点体系结构的局限性" class="headerlink" title="单名称节点体系结构的局限性"></a>单名称节点体系结构的局限性</h3><p>HDFS 值设置唯一一个名称节点，虽然可以简化系统设计，但是会带来一些明显的局限</p><ol><li><p>命名空间的限制</p></li><li><p>性能的瓶颈</p></li><li><p>隔离问题</p></li><li><p>集群的可用性</p></li></ol><h3 id="HDFS的一些关键特性"><a href="#HDFS的一些关键特性" class="headerlink" title="HDFS的一些关键特性"></a>HDFS的一些关键特性</h3><h4 id="1-HA-——-高可用性"><a href="#1-HA-——-高可用性" class="headerlink" title="1. HA —— 高可用性"></a>1. HA —— 高可用性</h4><p>Hadoop 2.x 才推出的新特性，主要体现在利用 <strong>zookeeper</strong> 实现主备 <strong>NameNode</strong> ，来解决单点 <strong>NameNode</strong> 的故障问题</p><p>由此，我们引出 <strong>Zookeeper</strong> 的一个主要作用——</p><blockquote><p>用来存储 <strong>HA</strong> 下的状态文件，主备信息</p></blockquote><p>其中，由 <strong>ZKFC（Zookeeper Failover Controller）</strong> 用于监控 <strong>NN</strong> 结点的主备状态</p><blockquote><p><strong>ZKFC</strong> 还控制 <strong>NN</strong> 主备仲裁，两者部署在一起，个数相同</p><ul><li>利用 <strong>Zookeeper</strong> 的分布式锁功能，实现 <strong>主备仲裁</strong></li><li>再通过命令通道，控制 <strong>NN</strong> 的主备状态</li></ul></blockquote><p><strong>JN（Journal Node）</strong> 用于存储 <strong>Active NN（主 NN）</strong>生成的 <strong>Editlog</strong>。由 <strong>Standby NN</strong> 加载 <strong>JN</strong> 上 <strong>Editlog</strong> ,同步元数据</p><h4 id="2-HDFS-Federation"><a href="#2-HDFS-Federation" class="headerlink" title="2. HDFS Federation"></a>2. HDFS Federation</h4><p>即利用 **多个 NN ** 来组成命名空间，且互相之间是独立的，两两之间并不互相通信，单个失效也不会影响其他。简单理解为——</p><blockquote><p>各 <strong>NameNode</strong> 负责自己所属的目录。与Linux挂载磁盘到目录类似， 此时每个 <strong>NameNode</strong> 只负责整个hdfs集群中部分目录。</p><p>如NameNode1负责/database目录，那么在/database目录下的文件元数据都由NameNode1负责。各NameNode间元数据不共享，每个NameNode都有对应的standby。</p></blockquote><p>属于某一命名空间，即 <strong>Namespace</strong> ，的一组数据块，称为 <strong>Block Pool</strong></p><p>在 <strong>联邦</strong> 环境下，每个 <strong>NN</strong> 维护一个 <strong>Namespace Volume</strong> ，包括——</p><ul><li><strong>NS</strong> 的元数据</li><li>在该空间下的文件的所有数据块的 <strong>BP</strong></li></ul><h4 id="3-数据副本机制"><a href="#3-数据副本机制" class="headerlink" title="3. 数据副本机制"></a>3. 数据副本机制</h4><p>副本距离计算公式：</p><ul><li>Distance(Rack1/D1, Rack1/D1)=0</li><li>同一台服务器的距离为0</li><li>Distance(Rack1/D1, Rack1/D3)=2</li><li>同一机架不同的服务器距离为2</li><li>Distance(Rack1/D1, Rack2/D1)=4</li><li>不同机架的服务器距离为4</li><li>不同数据中心的节点距离为6。</li></ul><p>副本放置策略</p><ul><li>第一个副本：放置在上传文件的数据节点；如果是集群外提交，则随机挑选一台磁盘 不太满、CPU不太忙的节点</li><li>第二个副本：放置在与第一个副本不同的机架的节点上</li><li>第三个副本：与第一个副本相同机架的其他节点上</li><li>更多副本：随机节点</li></ul><p>如果写请求方所在机器是其中一个DataNode,则直接存放在本地,否则随机在集群中选择一 个DataNode</p><ul><li>Rack1：表示机架1</li><li>D1：表示DataNode节点1</li><li>B1：表示节点上的block块1</li></ul><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210831152858662.png" alt="数据副本机制"></p><h4 id="4-HDFS-数据完整性保障"><a href="#4-HDFS-数据完整性保障" class="headerlink" title="4. HDFS 数据完整性保障"></a>4. HDFS 数据完整性保障</h4><p>HDFS主要目的是<strong>保证存储数据完整性</strong>，对于各组件的失效，做了可靠性处理——</p><ul><li>重建失效数据盘的副本数据<ul><li>DataNode与NameNode之间通过心跳周期汇报数据状态，NameNode管理数据块是否上报完整</li><li>如果DataNode因硬盘损坏未上报数据块，NameNode将发起副本重建动作以恢复丢失的副本。</li></ul></li><li>集群数据均衡<ul><li>HDFS架构设计了<strong>数据均衡机制</strong>，该机制保证数据在各个 <strong>DataNode</strong> 上分布式平均的</li></ul></li><li>元数据可靠性保证<ul><li>采用日志机制操作元数据，同时元数据存放在主备 <strong>NameNode</strong> 上</li><li>快照机制实现了文件系统常见的快照机制，保证数据误操作时，能及时恢复</li></ul></li><li>安全模式防止故障扩散<ul><li>当节点硬盘故障时，进入安全模式，HDFS只支持访问元数据，此时HDFS上的数据是只读的，其他的操作如创建、删除文件等操作都会导致失败。</li><li>待硬盘问题解决、数据恢复后，再退出安全模式。</li></ul></li></ul><h4 id="5-HDFS架构其他关键设计要点说明"><a href="#5-HDFS架构其他关键设计要点说明" class="headerlink" title="5. HDFS架构其他关键设计要点说明"></a>5. HDFS架构其他关键设计要点说明</h4><ul><li>空间回收机制<ul><li>支持回收站机制以及副本数的动态设置机制</li></ul></li><li>数据组织<ul><li>数据存储以<strong>数据块</strong>为单位，存储在操作系统的HDFS文件系统上</li></ul></li><li>访问方式<ul><li>提供 <strong>JAVA API，HTTP 方式，SHELL 方式</strong> 访问HDFS数据</li></ul></li></ul><h3 id="HDFS-3-0-新特性总结"><a href="#HDFS-3-0-新特性总结" class="headerlink" title="HDFS 3.0 新特性总结"></a>HDFS 3.0 新特性总结</h3><ol><li><p>支持 HDFS 中的纠删码 <strong>Erasure Encoding</strong></p><blockquote><ul><li>通过在原始数据中加入新的校验数据,使得各个部分的数据产生关联性，在一定范围的数据出错情况下，通过纠删码技术都可以进行恢复。EC技术可以防止数据丢失，又可以解决HDFS存储空间翻倍的问题</li><li>创建文件时，将从最近的祖先目录继承EC策略，以确定其块如何存储。与3路复制相比，默认的EC策略可以节省50％的存储空间，同时还可以承受更多的存储故障</li><li>建议EC存储用于冷数据，由于冷数据确实数量大，可以减少副本从而降低存储空间， 另外冷数据稳定，一旦需要恢复数据，对业务不会有太大影响。</li></ul></blockquote></li><li><p>基于 HDFS 路由器的联合</p></li><li><p>支持多个 NameNode</p></li><li><p>DataNode 内部添加了负载均衡 Disk Balancer</p></li></ol><h3 id="HDFS-数据读写流程"><a href="#HDFS-数据读写流程" class="headerlink" title="HDFS 数据读写流程"></a>HDFS 数据读写流程</h3><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210831160054496.png" alt="HDFS 数据写入流程"></p><p>HDFS数据写入流程如下：</p><ul><li>业务应用调用HDFS Client提供的API，请求写入文件</li><li>HDFS Client联系NameNode，NameNode在元数据中创建文件节点</li><li>业务应用调用write API写入文件</li><li>HDFS Client收到业务数据后，从NameNode获取到数据块编号、位置信息后，联系 DataNode，并将需要写入数据的DataNode建立起流水线。完成后，客户端再通过 自有协议写入数据到DataNode1，再由DataNode1复制到DataNode2, DataNode3</li><li>写完的数据，将返回确认信息给HDFS Client</li><li>所有数据确认完成后，业务调用HDFS Client关闭文件</li><li>业务调用close, flush后HDFS Client联系NameNode，确认数据写完成，NameNode 持久化元数据</li></ul><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210831160131833.png" alt="HDFS 读取流程"></p><p>HDFS数据读取流程如下：</p><ul><li>业务应用调用HDFS Client提供的API打开文件</li><li>HDFS Client联系NameNode，获取到文件信息（数据块、DataNode位置信息）</li><li>业务应用调用read API读取文件</li><li>HDFS Client根据从NameNode获取到的信息，联系DataNode，获取相应的数据块。 (Client采用就近原则读取数据)</li><li>HDFS Client会与多个DataNode通讯获取数据块</li><li>数据读取完成后，业务调用close关闭连接</li></ul><h2 id="Part-2-ZooKeeper"><a href="#Part-2-ZooKeeper" class="headerlink" title="Part 2 - ZooKeeper"></a>Part 2 - ZooKeeper</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>主要是用来解决分布式应用中经常遇到的一些数据管理问题，提供分布式、高可用性的协调服务能力。</p><p>总体分为<strong>安全模式</strong>以及<strong>非安全模式</strong>——</p><ul><li>安全模式下依赖于 <strong>Kerberos</strong> 和 <strong>LdapServer</strong> 进行安全认证</li><li>非安全模式下则不依赖</li></ul><p><strong>ZK</strong> 作为底层组件广泛被上层组件使用并依赖，如 <strong>Kafka，HDFS，HBase，Storm</strong>等</p><h3 id="体系架构"><a href="#体系架构" class="headerlink" title="体系架构"></a>体系架构</h3><p>ZooKeeper 集群由一组 Server 节点组成，这一组 Server 节点中存在一个角色为 Leader 的节点， 其他节点都为 Follower，Leader 在启动时选举出。</p><blockquote><p>选举方式，对于 n 个实例的服务，n 可能为奇数或偶数：</p><ul><li>当有 <strong>n = 2x + 1</strong> 个节点时，则成为 <strong>Leader</strong> 的节点需要获得 <strong>x + 1</strong> 票，容灾能力为 <strong>x</strong></li><li>当有 <strong>n = 2x + 2</strong> 个节点时，则成为 <strong>Leader</strong> 的节点需要获得 <strong>x + 2</strong> 票（大于一半），容灾能力为 <strong>x</strong></li></ul></blockquote><p>ZooKeeper 使用了一种自定义的原子消息协议（ZooKeeper Atomic Broadcast Zab协议）， 在消息层的这种原子特性，保证了整个协调系统中的节点数据或状态的一致性。</p><p>Leader节点在接收到数据变更请求后，首先将变更写入本地磁盘，以作恢复之用。当所有 的写请求持久化到磁盘以后，才会将变更应用到内存中。</p><p>当客户端 Client 连接到 ZooKeeper 集群，并且执行写请求时，这些请求会被发送到 Leader 节点上，然后 Leader 节点上数据变更会同步到集群中其他的 Follower 节点。</p><h3 id="关键特性"><a href="#关键特性" class="headerlink" title="关键特性"></a>关键特性</h3><h4 id="1-最终一致性"><a href="#1-最终一致性" class="headerlink" title="1. 最终一致性"></a>1. 最终一致性</h4><p>无论哪个 server，对外展示的均是同一视图</p><h4 id="2-实时性"><a href="#2-实时性" class="headerlink" title="2. 实时性"></a>2. 实时性</h4><p>保证客户端将在一个时间间隔范围内获得服务器的更新信息，或者服务器失效的信息</p><h4 id="3-可靠性"><a href="#3-可靠性" class="headerlink" title="3. 可靠性"></a>3. 可靠性</h4><p>一条消息被一个 server 接收，它将被所有 server 接受</p><h4 id="4-等待无关性"><a href="#4-等待无关性" class="headerlink" title="4. 等待无关性"></a>4. 等待无关性</h4><p>慢的或者失效的 client 不会干预快速的 client 的请求，使得每个 client 都能有有效的等待</p><h4 id="5-原子性"><a href="#5-原子性" class="headerlink" title="5. 原子性"></a>5. 原子性</h4><p>更新只能成功或者失败，没有中间态</p><h4 id="6-顺序一致性"><a href="#6-顺序一致性" class="headerlink" title="6. 顺序一致性"></a>6. 顺序一致性</h4><p>客户端所发送的更新会按照他们被发送的顺序进行应用</p><h3 id="ZooKeeper-的读写特性"><a href="#ZooKeeper-的读写特性" class="headerlink" title="ZooKeeper 的读写特性"></a>ZooKeeper 的读写特性</h3><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210831163621689.png" alt="ZK的读操作"></p><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210831163648575.png" alt="ZK的写操作"></p>]]></content>
    
    
    <categories>
      
      <category>Big Data Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Notes - 59</title>
    <link href="/2021/08/31/LeetCode-Notes-59/"/>
    <url>/2021/08/31/LeetCode-Notes-59/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-Notes-59"><a href="#Leetcode-Notes-59" class="headerlink" title="Leetcode Notes - 59"></a>Leetcode Notes - 59</h1><p>题目：<strong>59. 螺旋矩阵 II</strong></p><p>难度：<strong>中等</strong></p><p>遇见次数：<strong>第二次</strong></p><p>涉及知识点：</p><ul><li>二维数组</li><li>模拟</li></ul><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="1-四指针"><a href="#1-四指针" class="headerlink" title="1. 四指针"></a>1. 四指针</h3><p>太！爽！啦！《关于我写出以前没写出来的题还优于题解这回事》🛫</p><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210831125303137.png" alt="四指针"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[][] generateMatrix(<span class="hljs-keyword">int</span> n) &#123;<br>        <span class="hljs-keyword">int</span>[][] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n][n];<br>        <br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> right = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> top = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> bottom = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> count = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(left &lt;= right &amp;&amp; top &lt;= bottom)&#123;<br>            <span class="hljs-comment">// left 2 right</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> l2r = left; l2r &lt; right; l2r++)&#123;<br>                res[top][l2r] = count;<br>                count++;<br>            &#125;<br><br>            <span class="hljs-comment">// top 2 bottom</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> t2b = top; t2b &lt; bottom; t2b++)&#123;<br>                res[t2b][right] = count;<br>                count++;<br>            &#125;<br><br>            <span class="hljs-comment">// right 2 left</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> r2l = right; r2l &gt; left; r2l--)&#123;<br>                res[bottom][r2l] = count;<br>                count++;<br>            &#125;<br><br>            <span class="hljs-comment">// bottom 2 top</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> b2t = bottom; b2t &gt; top; b2t--)&#123;<br>                res[b2t][left] = count;<br>                count++;<br>            &#125;<br><br>            left++;<br>            right--;<br>            top++;<br>            bottom--;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(n % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) res[(n - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>][(n - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>] = n * n;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h3><h4 id="思路及算法"><a href="#思路及算法" class="headerlink" title="思路及算法"></a>思路及算法</h4><p>模拟矩阵的生成。按照要求，初始位置设为矩阵的左上角，初始方向设为向右。若下一步的位置超出矩阵边界，或者是之前访问过的位置，则顺时针旋转，进入下一个方向。如此反复直至填入 <code>n^2</code> 个元素。</p><p>记 <code>matrix</code> 为生成的矩阵，其初始元素设为 0。由于填入的元素均为正数，我们可以判断当前位置的元素值，若不为 0，则说明已经访问过此位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[][] generateMatrix(<span class="hljs-keyword">int</span> n) &#123;<br>        <span class="hljs-keyword">int</span> maxNum = n * n;<br>        <span class="hljs-keyword">int</span> curNum = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span>[][] matrix = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n][n];<br>        <span class="hljs-keyword">int</span> row = <span class="hljs-number">0</span>, column = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span>[][] directions = &#123;&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;&#125;; <span class="hljs-comment">// 右下左上</span><br>        <span class="hljs-keyword">int</span> directionIndex = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (curNum &lt;= maxNum) &#123;<br>            matrix[row][column] = curNum;<br>            curNum++;<br>            <span class="hljs-keyword">int</span> nextRow = row + directions[directionIndex][<span class="hljs-number">0</span>], nextColumn = column + directions[directionIndex][<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (nextRow &lt; <span class="hljs-number">0</span> || nextRow &gt;= n || nextColumn &lt; <span class="hljs-number">0</span> || nextColumn &gt;= n || matrix[nextRow][nextColumn] != <span class="hljs-number">0</span>) &#123;<br>                directionIndex = (directionIndex + <span class="hljs-number">1</span>) % <span class="hljs-number">4</span>; <span class="hljs-comment">// 顺时针旋转至下一个方向</span><br>            &#125;<br>            row = row + directions[directionIndex][<span class="hljs-number">0</span>];<br>            column = column + directions[directionIndex][<span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> matrix;<br>    &#125;<br>&#125;<br><br>作者：LeetCode-Solution<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/spiral-matrix-ii/solution/luo-xuan-ju-zhen-ii-by-leetcode-solution-f7fp/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><blockquote><p>四指针就是按层模拟，这里学习一下模拟的做法</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Leetcode Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Notes - 48</title>
    <link href="/2021/08/31/LeetCode-Notes-48/"/>
    <url>/2021/08/31/LeetCode-Notes-48/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-Notes-48"><a href="#Leetcode-Notes-48" class="headerlink" title="Leetcode Notes - 48"></a>Leetcode Notes - 48</h1><p>题目：<strong>48. 旋转图像</strong></p><p>难度：<strong>中等</strong></p><p>遇见次数：<strong>第二次</strong></p><p>涉及知识点：</p><ul><li>二维数组</li><li>对角线反转</li></ul><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="1-两次翻转"><a href="#1-两次翻转" class="headerlink" title="1. 两次翻转"></a>1. 两次翻转</h3><p>不擦！一不小心就优于题解了呗🛫</p><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210831123212779.png" alt="两次翻转"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(matrix.length == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">int</span> column = matrix[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-keyword">int</span> row = matrix.length;<br><br>        <span class="hljs-comment">// Horizental rotation</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> hColumn = <span class="hljs-number">0</span>; hColumn &lt; column; hColumn++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> hRow = <span class="hljs-number">0</span>; hRow &lt; row / <span class="hljs-number">2</span>; hRow++)&#123;<br>                <span class="hljs-keyword">int</span> tmp = matrix[hRow][hColumn];<br>                matrix[hRow][hColumn] = matrix[row - hRow - <span class="hljs-number">1</span>][hColumn];<br>                matrix[row - hRow - <span class="hljs-number">1</span>][hColumn] = tmp;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// Main cross line rotation</span><br>        <span class="hljs-keyword">int</span> mcColumn = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> mcRow = <span class="hljs-number">0</span>; mcRow &lt; row; mcRow++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = mcColumn; i &lt; column; i++)&#123;<br>                <span class="hljs-keyword">int</span> tmp = matrix[mcRow][i];<br>                matrix[mcRow][i] = matrix[i][mcRow];<br>                matrix[i][mcRow] = tmp;<br>            &#125;<br>            mcColumn++;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="用翻转代替旋转"><a href="#用翻转代替旋转" class="headerlink" title="用翻转代替旋转"></a>用翻转代替旋转</h3><h4 id="思路及算法"><a href="#思路及算法" class="headerlink" title="思路及算法"></a>思路及算法</h4><p>一样啦，只是把竖直改成水平</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = matrix.length;<br>        <span class="hljs-comment">// 水平翻转</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n / <span class="hljs-number">2</span>; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>                <span class="hljs-keyword">int</span> temp = matrix[i][j];<br>                matrix[i][j] = matrix[n - i - <span class="hljs-number">1</span>][j];<br>                matrix[n - i - <span class="hljs-number">1</span>][j] = temp;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 主对角线翻转</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; ++j) &#123;<br>                <span class="hljs-keyword">int</span> temp = matrix[i][j];<br>                matrix[i][j] = matrix[j][i];<br>                matrix[j][i] = temp;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br>作者：LeetCode-Solution<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/rotate-image/solution/xuan-zhuan-tu-xiang-by-leetcode-solution-vu3m/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Notes - 118</title>
    <link href="/2021/08/31/LeetCode-Notes-118/"/>
    <url>/2021/08/31/LeetCode-Notes-118/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-118"><a href="#Leetcode-118" class="headerlink" title="Leetcode - 118"></a>Leetcode - 118</h1><p>题目：<strong>118. 杨辉三角</strong></p><p>难度：<strong>简单</strong></p><p>遇见次数：<strong>第二次</strong></p><p>涉及知识点：</p><ul><li>数学</li><li>线性递推</li></ul><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><p>所谓显式队列😅</p><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210831121026373.png" alt="队列迭代"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">getRow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> rowIndex)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(rowIndex == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;(Arrays.asList(<span class="hljs-number">1</span>)); <br><br>        LinkedList&lt;Integer&gt; doQue = <span class="hljs-keyword">new</span> LinkedList&lt;Integer&gt;();<br>        doQue.offerLast(<span class="hljs-number">0</span>);<br>        doQue.offerLast(<span class="hljs-number">1</span>);<br>        doQue.offerLast(<span class="hljs-number">0</span>);<br><br>        <span class="hljs-keyword">int</span> curIndex = <span class="hljs-number">0</span>;<br>        List&lt;Integer&gt; curList = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br><br>        <span class="hljs-keyword">while</span>(curIndex &lt; rowIndex)&#123;<br>            curList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>            <span class="hljs-keyword">int</span> len = doQue.size();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len - <span class="hljs-number">1</span>; i++)&#123;<br>                <span class="hljs-keyword">int</span> tmp = doQue.poll();<br>                tmp = tmp + doQue.peek();<br>                curList.add(tmp);<br>            &#125;<br><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> ele : curList)&#123;<br>                doQue.offerLast(ele);<br>            &#125;<br>            doQue.offerLast(<span class="hljs-number">0</span>);<br><br>            curIndex++;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> curList;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="数学-线性递推"><a href="#数学-线性递推" class="headerlink" title="数学 - 线性递推"></a>数学 - 线性递推</h3><p>由组合数公式我们，可以得到同一行的相邻组合数的关系——</p><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210831121305506.png" alt="组合数公式"></p><p>利用上述公式我们可以在线性时间计算出第 n 行的所有组合数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">getRow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> rowIndex)</span> </span>&#123;<br>        List&lt;Integer&gt; row = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>        row.add(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= rowIndex; ++i) &#123;<br>            row.add((<span class="hljs-keyword">int</span>) ((<span class="hljs-keyword">long</span>) row.get(i - <span class="hljs-number">1</span>) * (rowIndex - i + <span class="hljs-number">1</span>) / i));<br>        &#125;<br>        <span class="hljs-keyword">return</span> row;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Notes - 706</title>
    <link href="/2021/08/31/LeetCode-Notes-706/"/>
    <url>/2021/08/31/LeetCode-Notes-706/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-Notes-706"><a href="#Leetcode-Notes-706" class="headerlink" title="Leetcode Notes - 706"></a>Leetcode Notes - 706</h1><p>题目：<strong>706. 设计哈希映射</strong></p><p>难度：<strong>简单</strong></p><p>遇见次数：<strong>第二次</strong></p><p>涉及知识点：</p><ul><li>哈希映射</li><li>链地址法</li></ul><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="1-链地址法"><a href="#1-链地址法" class="headerlink" title="1. 链地址法"></a>1. 链地址法</h3><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210831003333051.png" alt="双链表对应"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyHashMap</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> BASE = <span class="hljs-number">769</span>;<br>    <span class="hljs-keyword">private</span> LinkedList[][] data;<br><br>    <span class="hljs-comment">/** Initialize your data structure here. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyHashMap</span><span class="hljs-params">()</span> </span>&#123;<br>        data = <span class="hljs-keyword">new</span> LinkedList[BASE][<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; BASE; ++i) &#123;<br>            data[i][<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> LinkedList&lt;Integer&gt;();<br>            data[i][<span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> LinkedList&lt;Integer&gt;();<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">/** value will always be non-negative. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> h = hash(key);<br>        LinkedList keyList = <span class="hljs-keyword">this</span>.data[h][<span class="hljs-number">0</span>];<br>        LinkedList valueList = <span class="hljs-keyword">this</span>.data[h][<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; keyList.size(); i++)&#123;<br>            Integer curKey = (<span class="hljs-keyword">int</span>) keyList.get(i);<br>            <span class="hljs-keyword">if</span>(curKey == key)&#123;<br>                valueList.set(i, value);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">this</span>.data[h][<span class="hljs-number">0</span>].offerLast(key);<br>        <span class="hljs-keyword">this</span>.data[h][<span class="hljs-number">1</span>].offerLast(value);<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> h = hash(key);<br>        LinkedList keyList = <span class="hljs-keyword">this</span>.data[h][<span class="hljs-number">0</span>];<br>        LinkedList valueList = <span class="hljs-keyword">this</span>.data[h][<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; keyList.size(); i++)&#123;<br>            Integer curKey = (<span class="hljs-keyword">int</span>) keyList.get(i);<br>            <span class="hljs-keyword">if</span>(curKey == key)&#123;<br>                <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>) valueList.get(i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Removes the mapping of the specified value key if this map contains a mapping for the key */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> h = hash(key);<br>        LinkedList keyList = <span class="hljs-keyword">this</span>.data[h][<span class="hljs-number">0</span>];<br>        LinkedList valueList = <span class="hljs-keyword">this</span>.data[h][<span class="hljs-number">1</span>];<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; keyList.size(); i++)&#123;<br>            Integer curKey = (<span class="hljs-keyword">int</span>) keyList.get(i);<br>            <span class="hljs-keyword">if</span>(curKey == key)&#123;<br>                keyList.remove(curKey);<br>                valueList.remove(valueList.get(i));<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> key % BASE;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MyHashMap object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MyHashMap obj = new MyHashMap();</span><br><span class="hljs-comment"> * obj.put(key,value);</span><br><span class="hljs-comment"> * int param_2 = obj.get(key);</span><br><span class="hljs-comment"> * obj.remove(key);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="链地址法"><a href="#链地址法" class="headerlink" title="链地址法"></a>链地址法</h3><h4 id="思路及算法"><a href="#思路及算法" class="headerlink" title="思路及算法"></a>思路及算法</h4><p>官方题解利用了内部私有类，定义了 <code>Pair</code> 来完成 <code>&#123;key, value&#125;</code> 的对应</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyHashMap</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pair</span> </span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> key;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> value;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Pair</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.key = key;<br>            <span class="hljs-keyword">this</span>.value = value;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getKey</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> key;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getValue</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> value;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setValue</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.value = value;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> BASE = <span class="hljs-number">769</span>;<br>    <span class="hljs-keyword">private</span> LinkedList[] data;<br><br>    <span class="hljs-comment">/** Initialize your data structure here. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyHashMap</span><span class="hljs-params">()</span> </span>&#123;<br>        data = <span class="hljs-keyword">new</span> LinkedList[BASE];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; BASE; ++i) &#123;<br>            data[i] = <span class="hljs-keyword">new</span> LinkedList&lt;Pair&gt;();<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">/** value will always be non-negative. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> h = hash(key);<br>        Iterator&lt;Pair&gt; iterator = data[h].iterator();<br>        <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>            Pair pair = iterator.next();<br>            <span class="hljs-keyword">if</span> (pair.getKey() == key) &#123;<br>                pair.setValue(value);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>        data[h].offerLast(<span class="hljs-keyword">new</span> Pair(key, value));<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> h = hash(key);<br>        Iterator&lt;Pair&gt; iterator = data[h].iterator();<br>        <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>            Pair pair = iterator.next();<br>            <span class="hljs-keyword">if</span> (pair.getKey() == key) &#123;<br>                <span class="hljs-keyword">return</span> pair.value;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Removes the mapping of the specified value key if this map contains a mapping for the key */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> h = hash(key);<br>        Iterator&lt;Pair&gt; iterator = data[h].iterator();<br>        <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>            Pair pair = iterator.next();<br>            <span class="hljs-keyword">if</span> (pair.key == key) &#123;<br>                data[h].remove(pair);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> key % BASE;<br>    &#125;<br>&#125;<br><br>作者：LeetCode-Solution<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/design-hashmap/solution/she-ji-ha-xi-ying-she-by-leetcode-soluti-klu9/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Notes - 705</title>
    <link href="/2021/08/31/LeetCode-Notes-705/"/>
    <url>/2021/08/31/LeetCode-Notes-705/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-Notes-705"><a href="#Leetcode-Notes-705" class="headerlink" title="Leetcode Notes - 705"></a>Leetcode Notes - 705</h1><p>题目：<strong>705. 设计哈希集合</strong></p><p>难度：<strong>简单</strong></p><p>遇见次数：<strong>第一次</strong></p><p>涉及知识点：</p><ul><li>哈希映射实现</li><li>哈希函数</li><li>链地址法</li></ul><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="1-链地址法"><a href="#1-链地址法" class="headerlink" title="1. 链地址法"></a>1. 链地址法</h3><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210831001654888.png" alt="链地址法"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyHashSet</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> BASE = <span class="hljs-number">769</span>;<br>    <span class="hljs-keyword">private</span> LinkedList[] dataArr;<br><br>    <span class="hljs-comment">/** Initialize your data structure here. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyHashSet</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.dataArr = <span class="hljs-keyword">new</span> LinkedList[BASE];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; BASE; i++)&#123;<br>            <span class="hljs-keyword">this</span>.dataArr[i] = <span class="hljs-keyword">new</span> LinkedList&lt;Integer&gt;();<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> h = <span class="hljs-keyword">this</span>.hash(key);<br><br>        Iterator&lt;Integer&gt; cur = <span class="hljs-keyword">this</span>.dataArr[h].iterator();<br>        <span class="hljs-keyword">while</span>(cur.hasNext())&#123;<br>            Integer ele = cur.next();<br>            <span class="hljs-keyword">if</span>(ele == key)&#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">this</span>.dataArr[h].offerLast(key);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> h = <span class="hljs-keyword">this</span>.hash(key);<br><br>        Iterator&lt;Integer&gt; cur = <span class="hljs-keyword">this</span>.dataArr[h].iterator();<br>        <span class="hljs-keyword">while</span>(cur.hasNext())&#123;<br>            Integer ele = cur.next();<br>            <span class="hljs-keyword">if</span>(ele == key)&#123;<br>                <span class="hljs-keyword">this</span>.dataArr[h].remove(ele);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Returns true if this set contains the specified element */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">contains</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> h = <span class="hljs-keyword">this</span>.hash(key);<br><br>        Iterator&lt;Integer&gt; cur = <span class="hljs-keyword">this</span>.dataArr[h].iterator();<br>        <span class="hljs-keyword">while</span>(cur.hasNext())&#123;<br>            Integer ele = cur.next();<br>            <span class="hljs-keyword">if</span>(ele == key)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> val % BASE;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MyHashSet object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MyHashSet obj = new MyHashSet();</span><br><span class="hljs-comment"> * obj.add(key);</span><br><span class="hljs-comment"> * obj.remove(key);</span><br><span class="hljs-comment"> * boolean param_3 = obj.contains(key);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="链地址法"><a href="#链地址法" class="headerlink" title="链地址法"></a>链地址法</h3><h4 id="思路及算法"><a href="#思路及算法" class="headerlink" title="思路及算法"></a>思路及算法</h4><p>设哈希表的大小为 <code>base</code>，则可以设计一个简单的哈希函数：<code>hash(x) = x mod base</code>。</p><p>我们开辟一个大小为 <code>base</code> 的数组，数组的每个位置是一个链表。当计算出哈希值之后，就插入到对应位置的链表当中。</p><p>由于我们使用整数除法作为哈希函数，为了尽可能避免冲突，应当将 \textit{base}base 取为一个质数。在这里，我们取 <code>base = 769</code>。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tL0ZpZ3VyZXMvNzA1LzcwNV9saW5rZWRfbGlzdC5wbmc?x-oss-process=image/format,png" alt="fig"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyHashSet</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> BASE = <span class="hljs-number">769</span>;<br>    <span class="hljs-keyword">private</span> LinkedList[] data;<br><br>    <span class="hljs-comment">/** Initialize your data structure here. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyHashSet</span><span class="hljs-params">()</span> </span>&#123;<br>        data = <span class="hljs-keyword">new</span> LinkedList[BASE];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; BASE; ++i) &#123;<br>            data[i] = <span class="hljs-keyword">new</span> LinkedList&lt;Integer&gt;();<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> h = hash(key);<br>        Iterator&lt;Integer&gt; iterator = data[h].iterator();<br>        <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>            Integer element = iterator.next();<br>            <span class="hljs-keyword">if</span> (element == key) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>        data[h].offerLast(key);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> h = hash(key);<br>        Iterator&lt;Integer&gt; iterator = data[h].iterator();<br>        <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>            Integer element = iterator.next();<br>            <span class="hljs-keyword">if</span> (element == key) &#123;<br>                data[h].remove(element);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Returns true if this set contains the specified element */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">contains</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> h = hash(key);<br>        Iterator&lt;Integer&gt; iterator = data[h].iterator();<br>        <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>            Integer element = iterator.next();<br>            <span class="hljs-keyword">if</span> (element == key) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> key % BASE;<br>    &#125;<br>&#125;<br><br>作者：LeetCode-Solution<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/design-hashset/solution/she-ji-ha-xi-ji-he-by-leetcode-solution-xp4t/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><blockquote><p>这里选择769是因为他是质数，能使桶分配的更平均，具体推到和数学原理有待思考！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Leetcode Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Notes - 56</title>
    <link href="/2021/08/31/LeetCode-Notes-56/"/>
    <url>/2021/08/31/LeetCode-Notes-56/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-Notes-56"><a href="#Leetcode-Notes-56" class="headerlink" title="Leetcode Notes - 56"></a>Leetcode Notes - 56</h1><p>题目：<strong>56. 合并区间</strong></p><p>难度：<strong>中等</strong></p><p>遇见次数：<strong>第二次</strong></p><p>涉及知识点：</p><ul><li>二维数组排序</li><li>贪心算法</li></ul><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="1-贪心算法"><a href="#1-贪心算法" class="headerlink" title="1. 贪心算法"></a>1. 贪心算法</h3><p>并不正确的贪心哈哈，没过，但是记录一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[][] merge(<span class="hljs-keyword">int</span>[][] intervals) &#123;<br>        <span class="hljs-keyword">if</span>(intervals.length == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> intervals;<br>        <br>        Arrays.sort(intervals, <span class="hljs-keyword">new</span> Comparator&lt;<span class="hljs-keyword">int</span>[]&gt;()&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] v1, <span class="hljs-keyword">int</span>[] v2)</span></span>&#123;<br>                <span class="hljs-keyword">return</span> v1[<span class="hljs-number">0</span>] - v2[<span class="hljs-number">0</span>];<br>            &#125;<br>        &#125;);<br>        <br>        <span class="hljs-keyword">int</span> p = <span class="hljs-number">1</span>;<br>        List&lt;<span class="hljs-keyword">int</span>[]&gt; resList = <span class="hljs-keyword">new</span> ArrayList&lt;<span class="hljs-keyword">int</span>[]&gt;();<br>        <span class="hljs-keyword">int</span> curLeft = intervals[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">int</span> curRight = intervals[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];<br>        <br>        <span class="hljs-keyword">while</span>(p &lt; intervals.length)&#123;<br>            <span class="hljs-keyword">if</span>(intervals[p][<span class="hljs-number">0</span>] &lt;= curRight)&#123;<br>                <span class="hljs-keyword">if</span>(curRight &lt;= intervals[p][<span class="hljs-number">1</span>])&#123;<br>                    curRight = intervals[p][<span class="hljs-number">1</span>];<br>                &#125;<br>                p++;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">int</span>[] cur = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">2</span>];<br>                cur[<span class="hljs-number">0</span>] = curLeft;<br>                cur[<span class="hljs-number">1</span>] = curRight;<br>                resList.add(cur);<br>                <br>                curLeft = intervals[p][<span class="hljs-number">0</span>];<br>                curRight = intervals[p][<span class="hljs-number">1</span>];<br>                p++;<br>            &#125;   <br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span>(curLeft == intervals[p - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] &amp;&amp; curRight == intervals[p - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>])&#123;<br>            <span class="hljs-keyword">int</span>[] temp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">2</span>];<br>            temp[<span class="hljs-number">0</span>] = curLeft;<br>            temp[<span class="hljs-number">1</span>] = curRight;<br>            resList.add(temp);<br>        &#125;<br>        <br>        <span class="hljs-keyword">int</span>[][] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[resList.size()][<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; resList.size(); i++)&#123;<br>            res[i] = resList.get(i);<br>        &#125;<br>            <br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="排序-贪心"><a href="#排序-贪心" class="headerlink" title="排序 + 贪心"></a>排序 + 贪心</h3><h4 id="思路及算法"><a href="#思路及算法" class="headerlink" title="思路及算法"></a>思路及算法</h4><p>我们用数组 <code>merged</code> 存储最终的答案。</p><p>首先，我们将列表中的区间按照左端点升序排序。然后我们将第一个区间加入 <code>merged</code> 数组中，并按顺序依次考虑之后的每个区间：</p><ul><li>如果当前区间的左端点在数组 <code>merged</code> 中最后一个区间的右端点之后，那么它们不会重合，我们可以直接将这个区间加入数组 <code>merged</code> 的末尾；</li><li>否则，它们重合，我们需要用当前区间的右端点更新数组 <code>merged</code> 中最后一个区间的右端点，将其置为二者的较大值。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[][] merge(<span class="hljs-keyword">int</span>[][] intervals) &#123;<br>        <span class="hljs-keyword">if</span> (intervals.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>];<br>        &#125;<br>        Arrays.sort(intervals, <span class="hljs-keyword">new</span> Comparator&lt;<span class="hljs-keyword">int</span>[]&gt;() &#123;<br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] interval1, <span class="hljs-keyword">int</span>[] interval2)</span> </span>&#123;<br>                <span class="hljs-keyword">return</span> interval1[<span class="hljs-number">0</span>] - interval2[<span class="hljs-number">0</span>];<br>            &#125;<br>        &#125;);<br>        List&lt;<span class="hljs-keyword">int</span>[]&gt; merged = <span class="hljs-keyword">new</span> ArrayList&lt;<span class="hljs-keyword">int</span>[]&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; intervals.length; ++i) &#123;<br>            <span class="hljs-keyword">int</span> L = intervals[i][<span class="hljs-number">0</span>], R = intervals[i][<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (merged.size() == <span class="hljs-number">0</span> || merged.get(merged.size() - <span class="hljs-number">1</span>)[<span class="hljs-number">1</span>] &lt; L) &#123;<br>                merged.add(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;L, R&#125;);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                merged.get(merged.size() - <span class="hljs-number">1</span>)[<span class="hljs-number">1</span>] = Math.max(merged.get(merged.size() - <span class="hljs-number">1</span>)[<span class="hljs-number">1</span>], R);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> merged.toArray(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[merged.size()][]);<br>    &#125;<br>&#125;<br><br>作者：LeetCode-Solution<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/merge-intervals/solution/he-bing-qu-jian-by-leetcode-solution/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Notes - 75</title>
    <link href="/2021/08/31/LeetCode-Notes-75/"/>
    <url>/2021/08/31/LeetCode-Notes-75/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-Notes-75"><a href="#Leetcode-Notes-75" class="headerlink" title="Leetcode Notes -75"></a>Leetcode Notes -75</h1><p>题目：<strong>75. 颜色分类</strong></p><p>难度：<strong>简单</strong></p><p>遇见次数：<strong>第二次</strong></p><p>涉及知识点：</p><ul><li>双指针</li><li>排序</li></ul><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="1-双指针"><a href="#1-双指针" class="headerlink" title="1. 双指针"></a>1. 双指针</h3><p>不正确的双指针😀</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sortColors</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(nums.length &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;<br>        <br>        <span class="hljs-keyword">int</span> p0 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> p2 = nums.length - <span class="hljs-number">1</span>;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++)&#123;<br>            <span class="hljs-keyword">if</span>(i &gt; p2) <span class="hljs-keyword">break</span>;<br>            <br>            <span class="hljs-keyword">int</span> tmp = -<span class="hljs-number">1</span>;<br>            <br>            <span class="hljs-keyword">while</span>(nums[i] != <span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">if</span>(nums[i] == <span class="hljs-number">0</span>)&#123;<br>                    tmp = nums[p0];<br>                    nums[p0] = <span class="hljs-number">0</span>;<br>                    nums[i] = tmp;<br>                    p0++;<br>                &#125;<br><br>                <span class="hljs-keyword">if</span>(nums[i] == <span class="hljs-number">2</span>)&#123;<br>                    tmp = nums[p2];<br>                    nums[p2] = <span class="hljs-number">2</span>;<br>                    nums[i] = tmp;<br>                    p2--;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span>;<br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><h4 id="思路及算法"><a href="#思路及算法" class="headerlink" title="思路及算法"></a>思路及算法</h4><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210831004334916.png" alt="力扣题解"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sortColors</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(nums.length &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;<br>        <br>        <span class="hljs-keyword">int</span> p0 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> p2 = nums.length - <span class="hljs-number">1</span>;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++)&#123;<br>            <span class="hljs-keyword">if</span>(i &gt; p2) <span class="hljs-keyword">break</span>;<br>            <br>            <span class="hljs-keyword">int</span> tmp = -<span class="hljs-number">1</span>;<br>            <br>            <span class="hljs-keyword">while</span>(nums[i] != <span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">if</span>(nums[i] == <span class="hljs-number">0</span>)&#123;<br>                    tmp = nums[p0];<br>                    nums[p0] = <span class="hljs-number">0</span>;<br>                    nums[i] = tmp;<br>                    p0++;<br>                &#125;<br><br>                <span class="hljs-keyword">if</span>(nums[i] == <span class="hljs-number">2</span>)&#123;<br>                    tmp = nums[p2];<br>                    nums[p2] = <span class="hljs-number">2</span>;<br>                    nums[i] = tmp;<br>                    p2--;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span>;<br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Notes - 169</title>
    <link href="/2021/08/31/LeetCode-Notes-169/"/>
    <url>/2021/08/31/LeetCode-Notes-169/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-Notes-169"><a href="#Leetcode-Notes-169" class="headerlink" title="Leetcode Notes - 169"></a>Leetcode Notes - 169</h1><p>题目：<strong>169. 多数元素</strong></p><p>难度：<strong>简单</strong></p><p>遇见次数：<strong>第二次</strong></p><p>涉及知识点：</p><ul><li>哈希</li><li>摩尔投票算法</li></ul><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="1-摩尔投票算法"><a href="#1-摩尔投票算法" class="headerlink" title="1. 摩尔投票算法"></a>1. 摩尔投票算法</h3><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210829220640206.png" alt="摩尔投票算法"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> candidate = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i : nums)&#123;<br>            <span class="hljs-keyword">if</span>(i == candidate)&#123;<br>                count++;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                count--;<br><br>                <span class="hljs-keyword">if</span>(count == <span class="hljs-number">0</span>)&#123;<br>                    candidate = i;<br>                    count = <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> candidate;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="Boyer-Moore-投票算法"><a href="#Boyer-Moore-投票算法" class="headerlink" title="Boyer-Moore 投票算法"></a>Boyer-Moore 投票算法</h3><h4 id="思路及算法"><a href="#思路及算法" class="headerlink" title="思路及算法"></a>思路及算法</h4><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210829220755990.png" alt="LeetCode官方题解"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>        Integer candidate = <span class="hljs-keyword">null</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) &#123;<br>            <span class="hljs-keyword">if</span> (count == <span class="hljs-number">0</span>) &#123;<br>                candidate = num;<br>            &#125;<br>            count += (num == candidate) ? <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> candidate;<br>    &#125;<br>&#125;<br><br>作者：LeetCode-Solution<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/majority-element/solution/duo-shu-yuan-su-by-leetcode-solution/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Notes - 136</title>
    <link href="/2021/08/29/LeetCode-Notes-136/"/>
    <url>/2021/08/29/LeetCode-Notes-136/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-Notes-136"><a href="#Leetcode-Notes-136" class="headerlink" title="Leetcode Notes - 136"></a>Leetcode Notes - 136</h1><p>题目：<strong>136. 只出现一次的数字</strong></p><p>难度：<strong>简单</strong></p><p>遇见次数：<strong>第二次</strong></p><p>涉及知识点：</p><ul><li>位运算</li><li>异或运算</li></ul><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="1-位运算"><a href="#1-位运算" class="headerlink" title="1. 位运算"></a>1. 位运算</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num: nums) &#123;<br>            ans ^= num;<br>            System.out.println(ans);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><h4 id="思路及算法"><a href="#思路及算法" class="headerlink" title="思路及算法"></a>思路及算法</h4><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210829211115524.png" alt="136.题解"></p>]]></content>
    
    
    <categories>
      
      <category>Leetcode Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Notes - 232</title>
    <link href="/2021/07/31/LeetCode-Notes-232/"/>
    <url>/2021/07/31/LeetCode-Notes-232/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-Day-9"><a href="#Leetcode-Day-9" class="headerlink" title="Leetcode - Day 9"></a>Leetcode - Day 9</h1><p>题目：<strong>232. 用栈实现队列</strong></p><p>难度：<strong>简单</strong></p><p>遇见次数：<strong>第一次</strong></p><p>涉及知识点：</p><ul><li>栈</li></ul><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="作弊"><a href="#作弊" class="headerlink" title="作弊"></a>作弊</h3><p>面向答案的编程😈</p><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210731172343379.png" alt="提交情况"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyQueue</span> </span>&#123;<br>    Queue&lt;Integer&gt; myQueue;<br><br>    <span class="hljs-comment">/** Initialize your data structure here. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyQueue</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.myQueue = <span class="hljs-keyword">new</span> LinkedList&lt;Integer&gt;();<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Push element x to the back of queue. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        myQueue.offer(x);<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Removes the element from in front of queue and returns that element. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> ele = myQueue.poll();<br><br>        <span class="hljs-keyword">return</span> ele;<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Get the front element. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">peek</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> ele = myQueue.peek();<br><br>        <span class="hljs-keyword">return</span> ele;<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Returns whether the queue is empty. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> myQueue.isEmpty();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MyQueue object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MyQueue obj = new MyQueue();</span><br><span class="hljs-comment"> * obj.push(x);</span><br><span class="hljs-comment"> * int param_2 = obj.pop();</span><br><span class="hljs-comment"> * int param_3 = obj.peek();</span><br><span class="hljs-comment"> * boolean param_4 = obj.empty();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="双栈"><a href="#双栈" class="headerlink" title="双栈"></a>双栈</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>将一个栈当作输入栈，用于压入 push 传入的数据；另一个栈当作输出栈，用于 pop 和 peek 操作。</p><p>每次 pop 或 peek 时，若输出栈为空则将输入栈的全部数据依次弹出并压入输出栈，这样输出栈从栈顶往栈底的顺序就是队列从队首往队尾的顺序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyQueue</span> </span>&#123;<br>    Deque&lt;Integer&gt; inStack;<br>    Deque&lt;Integer&gt; outStack;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyQueue</span><span class="hljs-params">()</span> </span>&#123;<br>        inStack = <span class="hljs-keyword">new</span> LinkedList&lt;Integer&gt;();<br>        outStack = <span class="hljs-keyword">new</span> LinkedList&lt;Integer&gt;();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        inStack.push(x);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (outStack.isEmpty()) &#123;<br>            in2out();<br>        &#125;<br>        <span class="hljs-keyword">return</span> outStack.pop();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">peek</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (outStack.isEmpty()) &#123;<br>            in2out();<br>        &#125;<br>        <span class="hljs-keyword">return</span> outStack.peek();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> inStack.isEmpty() &amp;&amp; outStack.isEmpty();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">in2out</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (!inStack.isEmpty()) &#123;<br>            outStack.push(inStack.pop());<br>        &#125;<br>    &#125;<br>&#125;<br><br>作者：LeetCode-Solution<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/implement-queue-using-stacks/solution/yong-zhan-shi-xian-dui-lie-by-leetcode-s-xnb6/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Notes - 20</title>
    <link href="/2021/07/31/LeetCode-Notes-20/"/>
    <url>/2021/07/31/LeetCode-Notes-20/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-Day-9"><a href="#Leetcode-Day-9" class="headerlink" title="Leetcode - Day 9"></a>Leetcode - Day 9</h1><p>题目：<strong>20. 有效的括号</strong></p><p>难度：<strong>简单</strong></p><p>遇见次数：<strong>第一次</strong></p><p>涉及知识点：</p><ul><li>栈</li></ul><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="1-栈"><a href="#1-栈" class="headerlink" title="1. 栈"></a>1. 栈</h3><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210731171027262.png" alt="提交情况"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValid</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(s.length() % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br><br>        <span class="hljs-keyword">char</span>[] strArr = s.toCharArray();<br>        Stack&lt;Character&gt; myStack = <span class="hljs-keyword">new</span> Stack&lt;Character&gt;();<br><br>        <span class="hljs-keyword">int</span> no = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; strArr.length; i++)&#123;<br>            no = typeJudge(strArr[i]);<br><br>            <span class="hljs-keyword">if</span>(no &lt;= <span class="hljs-number">3</span>)&#123;<br>                myStack.push(strArr[i]);<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">if</span>(myStack.empty()) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br><br>                <span class="hljs-keyword">if</span>(no - typeJudge(myStack.peek()) != <span class="hljs-number">3</span>)&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>                &#125;<br><br>                myStack.pop();<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> myStack.empty() ? <span class="hljs-keyword">true</span> : <span class="hljs-keyword">false</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">typeJudge</span><span class="hljs-params">(<span class="hljs-keyword">char</span> ch)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(ch == <span class="hljs-string">&#x27;(&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(ch == <span class="hljs-string">&#x27;[&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(ch == <span class="hljs-string">&#x27;&#123;&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>        <span class="hljs-keyword">if</span>(ch == <span class="hljs-string">&#x27;)&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">4</span>;<br>        <span class="hljs-keyword">if</span>(ch == <span class="hljs-string">&#x27;]&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">5</span>;<br>        <span class="hljs-keyword">if</span>(ch == <span class="hljs-string">&#x27;&#125;&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">6</span>;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>判断括号的有效性可以使用「栈」这一数据结构来解决。</p><p>我们遍历给定的字符串 s。当我们遇到一个左括号时，我们会期望在后续的遍历中，有一个相同类型的右括号将其闭合。由于后遇到的左括号要先闭合，因此我们可以将这个左括号放入栈顶。</p><p>当我们遇到一个右括号时，我们需要将一个相同类型的左括号闭合。此时，我们可以取出栈顶的左括号并判断它们是否是相同类型的括号。如果不是相同的类型，或者栈中并没有左括号，那么字符串 s 无效，返回 False。为了快速判断括号的类型，我们可以使用哈希表存储每一种括号。哈希表的键为右括号，值为相同类型的左括号。</p><p>在遍历结束后，如果栈中没有左括号，说明我们将字符串 s 中的所有左括号闭合，返回 True，否则返回 False。</p><p>注意到有效字符串的长度一定为偶数，因此如果字符串的长度为奇数，我们可以直接返回 False，省去后续的遍历判断过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValid</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = s.length();<br>        <span class="hljs-keyword">if</span> (n % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br><br>        Map&lt;Character, Character&gt; pairs = <span class="hljs-keyword">new</span> HashMap&lt;Character, Character&gt;() &#123;&#123;<br>            put(<span class="hljs-string">&#x27;)&#x27;</span>, <span class="hljs-string">&#x27;(&#x27;</span>);<br>            put(<span class="hljs-string">&#x27;]&#x27;</span>, <span class="hljs-string">&#x27;[&#x27;</span>);<br>            put(<span class="hljs-string">&#x27;&#125;&#x27;</span>, <span class="hljs-string">&#x27;&#123;&#x27;</span>);<br>        &#125;&#125;;<br>        Deque&lt;Character&gt; stack = <span class="hljs-keyword">new</span> LinkedList&lt;Character&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">char</span> ch = s.charAt(i);<br>            <span class="hljs-keyword">if</span> (pairs.containsKey(ch)) &#123;<br>                <span class="hljs-keyword">if</span> (stack.isEmpty() || stack.peek() != pairs.get(ch)) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>                &#125;<br>                stack.pop();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                stack.push(ch);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> stack.isEmpty();<br>    &#125;<br>&#125;<br><br>作者：LeetCode-Solution<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/valid-parentheses/solution/you-xiao-de-gua-hao-by-leetcode-solution/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Notes - 15</title>
    <link href="/2021/07/30/LeetCode-Notes-15/"/>
    <url>/2021/07/30/LeetCode-Notes-15/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-Day-8"><a href="#Leetcode-Day-8" class="headerlink" title="Leetcode - Day 8"></a>Leetcode - Day 8</h1><p>题目：<strong>15. 三数之和</strong></p><p>难度：<strong>中等</strong></p><p>遇见次数：<strong>第一次</strong></p><p>涉及知识点：</p><ul><li>双指针</li><li>数组</li></ul><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="1-原地修改"><a href="#1-原地修改" class="headerlink" title="1. 原地修改"></a>1. 原地修改</h3><p><strong>《超 出 时 间 限 制》</strong>🤣</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="hljs-keyword">int</span>[] nums) &#123;<br>        <span class="hljs-keyword">if</span>(nums.length &lt; <span class="hljs-number">3</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();<br>        &#125;<br><br>        Arrays.sort(nums);<br>        <br>        List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();<br>        Map&lt;String, List&lt;Integer&gt;&gt; myHashmap = <span class="hljs-keyword">new</span> HashMap&lt;String, List&lt;Integer&gt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>; a &lt; nums.length - <span class="hljs-number">2</span>; a++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> b = a + <span class="hljs-number">1</span>; b &lt; nums.length - <span class="hljs-number">1</span>; b++)&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> c = b + <span class="hljs-number">1</span>; c &lt; nums.length; c++)&#123;<br>                    <span class="hljs-keyword">if</span>(nums[a] + nums[b] == -nums[c])&#123;<br>                        List&lt;Integer&gt; curNew = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>                        String curStr = <span class="hljs-string">&quot;&quot;</span>;<br>                        <br>                        curNew.add(nums[a]);<br>                        curNew.add(nums[b]);<br>                        curNew.add(nums[c]);<br><br>                        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i : curNew)&#123;<br>                            curStr = curStr + String.format(<span class="hljs-string">&quot;%d&quot;</span>, i);<br>                        &#125;<br><br>                        <span class="hljs-keyword">if</span>(myHashmap.containsKey(curStr))&#123;<br>                            <span class="hljs-keyword">continue</span>;<br>                        &#125;<br>                        <span class="hljs-keyword">else</span>&#123;<br>                            myHashmap.put(curStr,curNew);<br>                            ans.add(curNew);<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="排序-双指针"><a href="#排序-双指针" class="headerlink" title="排序+双指针"></a>排序+双指针</h3><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210730231301770.png" alt="题解"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="hljs-keyword">int</span>[] nums) &#123;<br>    List&lt;List&lt;Integer&gt;&gt; lists = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-comment">//排序</span><br>    Arrays.sort(nums);<br>    <span class="hljs-comment">//双指针</span><br>    <span class="hljs-keyword">int</span> len = nums.length;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; len;++i) &#123;<br>        <span class="hljs-keyword">if</span>(nums[i] &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> lists;<br><br>        <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i-<span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br><br>        <span class="hljs-keyword">int</span> curr = nums[i];<br>        <span class="hljs-keyword">int</span> L = i+<span class="hljs-number">1</span>, R = len-<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (L &lt; R) &#123;<br>            <span class="hljs-keyword">int</span> tmp = curr + nums[L] + nums[R];<br>            <span class="hljs-keyword">if</span>(tmp == <span class="hljs-number">0</span>) &#123;<br>                List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>                list.add(curr);<br>                list.add(nums[L]);<br>                list.add(nums[R]);<br>                lists.add(list);<br>                <span class="hljs-keyword">while</span>(L &lt; R &amp;&amp; nums[L+<span class="hljs-number">1</span>] == nums[L]) ++L;<br>                <span class="hljs-keyword">while</span> (L &lt; R &amp;&amp; nums[R-<span class="hljs-number">1</span>] == nums[R]) --R;<br>                ++L;<br>                --R;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(tmp &lt; <span class="hljs-number">0</span>) &#123;<br>                ++L;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                --R;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> lists;<br>&#125;<br><br>作者：wu_yan_zu<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/3sum/solution/pai-xu-shuang-zhi-zhen-zhu-xing-jie-shi-python3-by/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Notes - 206</title>
    <link href="/2021/07/30/LeetCode-Notes-206/"/>
    <url>/2021/07/30/LeetCode-Notes-206/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-Day-8"><a href="#Leetcode-Day-8" class="headerlink" title="Leetcode - Day 8"></a>Leetcode - Day 8</h1><p>题目：<strong>206. 反转链表</strong></p><p>难度：<strong>简单</strong></p><p>遇见次数：<strong>第一次</strong></p><p>涉及知识点：</p><ul><li>链表</li></ul><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="1-三指针原地修改"><a href="#1-三指针原地修改" class="headerlink" title="1. 三指针原地修改"></a>1. 三指针原地修改</h3><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210730163151525.png" alt="提交情况"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(head.next == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br><br>        ListNode nextNode = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);<br>        ListNode preNode = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);<br><br>        nextNode.next = head.next;<br>        head.next = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">do</span>&#123;<br>            preNode.next = head;<br><br>            head = nextNode.next;<br><br>            nextNode.next = nextNode.next.next;<br><br>            head.next = preNode.next;<br>        &#125;<span class="hljs-keyword">while</span>(nextNode.next != <span class="hljs-keyword">null</span>);<br><br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><p>在遍历链表时，将当前节点的 <code>next</code> 指针改为指向前一个节点。由于节点没有引用其前一个节点，因此必须事先存储其前一个节点。在更改引用之前，还需要存储后一个节点。最后返回新的头引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>        ListNode prev = <span class="hljs-keyword">null</span>;<br>        ListNode curr = head;<br>        <span class="hljs-keyword">while</span> (curr != <span class="hljs-keyword">null</span>) &#123;<br>            ListNode next = curr.next;<br>            curr.next = prev;<br>            prev = curr;<br>            curr = next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> prev;<br>    &#125;<br>&#125;<br><br>作者：LeetCode-Solution<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/reverse-linked-list/solution/fan-zhuan-lian-biao-by-leetcode-solution-d1k2/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><blockquote><p>优于题解不解释</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Leetcode Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Notes - 83</title>
    <link href="/2021/07/30/LeetCode-Notes-83/"/>
    <url>/2021/07/30/LeetCode-Notes-83/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-Day-8"><a href="#Leetcode-Day-8" class="headerlink" title="Leetcode - Day 8"></a>Leetcode - Day 8</h1><p>题目：<strong>83. 删除排序链表中的重复元素</strong></p><p>难度：<strong>简单</strong></p><p>遇见次数：<strong>第一次</strong></p><p>涉及知识点：</p><ul><li>链表</li></ul><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="1-快慢指针-哈希表"><a href="#1-快慢指针-哈希表" class="headerlink" title="1. 快慢指针+哈希表"></a>1. 快慢指针+哈希表</h3><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210730180813688.png" alt="提交情况"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">deleteDuplicates</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(head.next == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br><br>        Set&lt;Integer&gt; myHashset = <span class="hljs-keyword">new</span> HashSet&lt;Integer&gt;();<br>        ListNode fast = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>, head.next);<br>        ListNode ans = head;<br><br>        myHashset.add(head.val);<br>        <span class="hljs-keyword">while</span>(fast.next != <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">if</span>(myHashset.contains(fast.next.val))&#123;<br>                head.next = <span class="hljs-keyword">null</span>;<br>                fast.next = fast.next.next;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                myHashset.add(fast.next.val);<br>                head.next = fast.next;<br>                head = head.next;<br>                fast.next = fast.next.next;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="迭代一次遍历"><a href="#迭代一次遍历" class="headerlink" title="迭代一次遍历"></a>迭代一次遍历</h3><h4 id="思路与算法"><a href="#思路与算法" class="headerlink" title="思路与算法"></a>思路与算法</h4><p>由于给定的链表是排好序的，因此重复的元素在链表中出现的位置是连续的，因此我们只需要对链表进行一次遍历，就可以删除重复的元素。</p><p>具体地，我们从指针 cur 指向链表的头节点，随后开始对链表进行遍历。如果当前 cur 与 cur.next 对应的元素相同，那么我们就将 cur.next 从链表中移除；否则说明链表中已经不存在其它与 cur 对应的元素相同的节点，因此可以将 cur 指向 cur.next。</p><p>当遍历完整个链表之后，我们返回链表的头节点即可。</p><h4 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h4><p>当我们遍历到链表的最后一个节点时，cur.next 为空节点，如果不加以判断，访问 cur.next 对应的元素会产生运行错误。因此我们只需要遍历到链表的最后一个节点，而不需要遍历完整个链表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">deleteDuplicates</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br><br>        ListNode cur = head;<br>        <span class="hljs-keyword">while</span> (cur.next != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (cur.val == cur.next.val) &#123;<br>                cur.next = cur.next.next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                cur = cur.next;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;<br><br>作者：LeetCode-Solution<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/remove-duplicates-from-sorted-list/solution/shan-chu-pai-xu-lian-biao-zhong-de-zhong-49v5/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Notes - 3</title>
    <link href="/2021/07/30/LeetCode-Notes-3/"/>
    <url>/2021/07/30/LeetCode-Notes-3/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-Day-8"><a href="#Leetcode-Day-8" class="headerlink" title="Leetcode - Day 8"></a>Leetcode - Day 8</h1><p>题目：<strong>3. 无重复字符的最长字串</strong></p><p>难度：<strong>简单</strong></p><p>遇见次数：<strong>第二次</strong></p><p>涉及知识点：</p><ul><li>字符串</li><li>哈希集合</li><li>滑动窗口</li></ul><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="1-滑动窗口"><a href="#1-滑动窗口" class="headerlink" title="1. 滑动窗口"></a>1. 滑动窗口</h3><p>学习后重写版本，之前想的确实不对😔</p><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210730154841165.png" alt="提交情况"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(s.length() == <span class="hljs-number">0</span> || s.length() == <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> s.length();<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> maxLen = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">char</span>[] strArr = s.toCharArray();<br>        Set&lt;Character&gt; myHashset = <span class="hljs-keyword">new</span> HashSet&lt;Character&gt;();<br><br>        <span class="hljs-keyword">int</span> right = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br><br>        myHashset.add(strArr[left]);<br>        <span class="hljs-keyword">while</span>(right &lt; strArr.length)&#123;<br>            <span class="hljs-keyword">if</span>(myHashset.contains(strArr[right]))&#123;<br>                myHashset.remove(strArr[left]);<br>                left++;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                maxLen = Math.max(maxLen, right - left + <span class="hljs-number">1</span>);<br>                myHashset.add(strArr[right]);<br>                right++;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> maxLen;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><p>首先，判断当前字符是否包含在map中，如果不包含，将该字符添加到map（字符，字符在数组下标）,<br>此时没有出现重复的字符，左指针不需要变化。</p><p>此时不重复子串的长度为：i-left+1，与原来的maxLen比较，取最大值；</p><p>如果当前字符 ch 包含在 map中，此时有2类情况：</p><ul><li>当前字符包含在当前有效的子段中，如：abca，当我们遍历到第二个a，当前有效最长子段是 abc，我们又遍历到a，那么此时更新 left 为 map.get(a)+1=1，当前有效子段更新为 bca；</li><li>当前字符不包含在当前最长有效子段中，如：abba，我们先添加a,b进map，此时left=0，我们再添加b，发现map中包含b，而且b包含在最长有效子段中，就是1）的情况，我们更新 left=map.get(b)+1=2，此时子段更新为 b，而且map中仍然包含a，map.get(a)=0；</li></ul><p>随后，我们遍历到a，发现a包含在map中，且map.get(a)=0，如果我们像上述第一种情况一样处理，就会发现</p><blockquote><p> left=map.get(a)+1=1</p></blockquote><p>实际上，left此时应该不变，left始终为2，子段变成 ba才对。</p><ul><li>为了处理以上2类情况，我们每次更新left，left=Math.max(left , map.get(ch)+1).</li><li>另外，更新left后，不管原来的 s.charAt(i) 是否在最长子段中，我们都要将 s.charAt(i) 的位置更新为当前的i，因此此时新的 s.charAt(i) 已经进入到 当前最长的子段中！</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        HashMap&lt;Character, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        <span class="hljs-keyword">int</span> maxLen = <span class="hljs-number">0</span>;<span class="hljs-comment">//用于记录最大不重复子串的长度</span><br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<span class="hljs-comment">//滑动窗口左指针</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.length() ; i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(map.containsKey(s.charAt(i)))<br>            &#123;<br>                left = Math.max(left , map.get(s.charAt(i))+<span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-comment">//不管是否更新left，都要更新 s.charAt(i) 的位置！</span><br>            map.put(s.charAt(i) , i);<br>            maxLen = Math.max(maxLen , i-left+<span class="hljs-number">1</span>);<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> maxLen;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Notes - 203</title>
    <link href="/2021/07/29/LeetCode-Notes-203/"/>
    <url>/2021/07/29/LeetCode-Notes-203/</url>
    
    <content type="html"><![CDATA[<h2 id="Leetcode-Day-7"><a href="#Leetcode-Day-7" class="headerlink" title="Leetcode - Day 7"></a>Leetcode - Day 7</h2><p>题目：<strong>203. 移除链表元素</strong></p><p>难度：<strong>简单</strong></p><p>遇见次数：<strong>第一次</strong></p><p>涉及知识点：</p><ul><li>链表</li></ul><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="1-原地修改"><a href="#1-原地修改" class="headerlink" title="1. 原地修改"></a>1. 原地修改</h3><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210729123540821.png" alt="提交情况"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">removeElements</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>        ListNode ans;<br><br>        <span class="hljs-keyword">while</span>(head != <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">if</span>(head.val == val)&#123;<br>                head = head.next;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        ans = head;<br><br>        <span class="hljs-keyword">if</span>(ans == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> ans;<br>        &#125;<br><br>        <span class="hljs-keyword">while</span>(head.next != <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">if</span>(head.next.val == val)&#123;<br>                head.next = head.next.next;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                head = head.next;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210729123702255.png" alt="官方题解"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">removeElements</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>        ListNode dummyHead = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);<br>        dummyHead.next = head;<br>        ListNode temp = dummyHead;<br>        <span class="hljs-keyword">while</span> (temp.next != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (temp.next.val == val) &#123;<br>                temp.next = temp.next.next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                temp = temp.next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummyHead.next;<br>    &#125;<br>&#125;<br><br>作者：LeetCode-Solution<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/remove-linked-list-elements/solution/yi-chu-lian-biao-yuan-su-by-leetcode-sol-654m/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><blockquote><p>哑头结点创建</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Leetcode Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Notes - 141</title>
    <link href="/2021/07/29/LeetCode-Notes-141/"/>
    <url>/2021/07/29/LeetCode-Notes-141/</url>
    
    <content type="html"><![CDATA[<h2 id="Leetcode-Day-7"><a href="#Leetcode-Day-7" class="headerlink" title="Leetcode - Day 7"></a>Leetcode - Day 7</h2><p>题目：<strong>141. 环形链表</strong></p><p>难度：<strong>简单</strong></p><p>遇见次数：<strong>第一次</strong></p><p>涉及知识点：</p><ul><li>字符串</li><li>哈希表</li></ul><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="1-哈希记录节点"><a href="#1-哈希记录节点" class="headerlink" title="1. 哈希记录节点"></a>1. 哈希记录节点</h3><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210729110135271.png" alt="提交情况"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode(int x) &#123;</span><br><span class="hljs-comment"> *         val = x;</span><br><span class="hljs-comment"> *         next = null;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br><br>        Set&lt;ListNode&gt; checkMap = <span class="hljs-keyword">new</span> HashSet&lt;ListNode&gt;();<br><br>        <span class="hljs-keyword">while</span>(head != <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">if</span>(checkMap.contains(head))&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br><br>            checkMap.add(head);<br>            head = head.next;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h3><h4 id="思路及算法"><a href="#思路及算法" class="headerlink" title="思路及算法"></a>思路及算法</h4><p>本方法需要读者对「Floyd 判圈算法」（又称龟兔赛跑算法）有所了解。</p><p>假想「乌龟」和「兔子」在链表上移动，「兔子」跑得快，「乌龟」跑得慢。当「乌龟」和「兔子」从链表上的同一个节点开始移动时，如果该链表中没有环，那么「兔子」将一直处于「乌龟」的前方；如果该链表中有环，那么「兔子」会先于「乌龟」进入环，并且一直在环内移动。等到「乌龟」进入环时，由于「兔子」的速度快，它一定会在某个时刻与乌龟相遇，即套了「乌龟」若干圈。</p><p>我们可以根据上述思路来解决本题。具体地，我们定义两个指针，一快一满。慢指针每次只移动一步，而快指针每次移动两步。初始时，慢指针在位置 <code>head</code>，而快指针在位置 <code>head.next</code>。这样一来，如果在移动的过程中，快指针反过来追上慢指针，就说明该链表为环形链表。否则快指针将到达链表尾部，该链表不为环形链表。</p><h4 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h4><p>为什么我们要规定初始时慢指针在位置 <code>head</code>，快指针在位置 <code>head.next</code>，而不是两个指针都在位置 <code>head</code>（即与「乌龟」和「兔子」中的叙述相同）？</p><p>观察下面的代码，我们使用的是 while 循环，循环条件先于循环体。由于循环条件一定是判断快慢指针是否重合，如果我们将两个指针初始都置于 head，那么 while 循环就不会执行。因此，我们可以假想一个在 head 之前的虚拟节点，慢指针从虚拟节点移动一步到达 head，快指针从虚拟节点移动两步到达 head.next，这样我们就可以使用 while 循环了。</p><p>当然，我们也可以使用 do-while 循环。此时，我们就可以把快慢指针的初始值都置为 head。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span> || head.next == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        <br>        ListNode slow = head;<br>        ListNode fast = head;<br>        <span class="hljs-keyword">do</span>&#123;<br>            <span class="hljs-keyword">if</span> (fast == <span class="hljs-keyword">null</span> || fast.next == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>            slow = slow.next;<br>            fast = fast.next.next;<br>        &#125; <span class="hljs-keyword">while</span>(slow != fast);<br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Notes - 21</title>
    <link href="/2021/07/29/LeetCode-Notes-21/"/>
    <url>/2021/07/29/LeetCode-Notes-21/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-Day-7"><a href="#Leetcode-Day-7" class="headerlink" title="Leetcode - Day 7"></a>Leetcode - Day 7</h1><p>题目：<strong>21. 合并两个有序链表</strong></p><p>难度：<strong>简单</strong></p><p>遇见次数：<strong>第二次</strong></p><p>涉及知识点：</p><ul><li>链表</li></ul><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="1-一次遍历"><a href="#1-一次遍历" class="headerlink" title="1. 一次遍历"></a>1. 一次遍历</h3><p>双指针一次遍历，空间复杂度优于题解🛫</p><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210729130352882.png" alt="提交情况"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(l1 == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> l2;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(l2 == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> l1;<br>        &#125;<br><br>        ListNode ans;<br><br>        ans = l1.val &gt; l2.val ? l2 : l1;<br>        ListNode dummy;<br>        <span class="hljs-keyword">while</span>(l1 != <span class="hljs-keyword">null</span> &amp;&amp; l2 != <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">if</span>(l1.val &lt;= l2.val)&#123;<br>                <span class="hljs-keyword">do</span>&#123;<br>                    dummy = l1;<br>                    l1 = l1.next;<br><br>                    <span class="hljs-keyword">if</span>(l1 == <span class="hljs-keyword">null</span>)&#123;<br>                        dummy.next = l2;<br>                        <span class="hljs-keyword">return</span> ans;<br>                    &#125;<br>                &#125;<span class="hljs-keyword">while</span>(l1.val &lt;= l2.val);<br><br>                dummy.next = l2;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span>(l1.val &gt; l2.val)&#123;<br>                <span class="hljs-keyword">do</span>&#123;<br>                    dummy = l2;<br>                    l2 = l2.next;<br><br>                    <span class="hljs-keyword">if</span>(l2 == <span class="hljs-keyword">null</span>)&#123;<br>                        dummy.next = l1;<br>                        <span class="hljs-keyword">return</span> ans;<br>                    &#125;<br>                &#125;<span class="hljs-keyword">while</span>(l1.val &gt; l2.val);<br><br>                dummy.next = l1;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>我们可以如下递归地定义两个链表里的 <code>merge</code> 操作（忽略边界情况，比如空链表等）：</p><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210729130732855.png" alt="递归条件"></p><p>也就是说，两个链表头部值较小的一个节点与剩下元素的 <code>merge</code> 操作结果合并。</p><h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><p>我们直接将以上递归过程建模，同时需要考虑边界情况。</p><p>如果 <code>l1</code> 或者 <code>l2</code> 一开始就是空链表 ，那么没有任何操作需要合并，所以我们只需要返回非空链表。否则，我们要判断 <code>l1</code> 和 <code>l2</code> 哪一个链表的头节点的值更小，然后递归地决定下一个添加到结果里的节点。如果两个链表有一个为空，递归结束。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (l1 == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> l2;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (l2 == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> l1;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (l1.val &lt; l2.val) &#123;<br>            l1.next = mergeTwoLists(l1.next, l2);<br>            <span class="hljs-keyword">return</span> l1;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            l2.next = mergeTwoLists(l1, l2.next);<br>            <span class="hljs-keyword">return</span> l2;<br>        &#125;<br><br>    &#125;<br>&#125;<br><br>作者：LeetCode-Solution<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/merge-two-sorted-lists/solution/he-bing-liang-ge-you-xu-lian-biao-by-leetcode-solu/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Notes - 383</title>
    <link href="/2021/07/28/LeetCode-Notes-383/"/>
    <url>/2021/07/28/LeetCode-Notes-383/</url>
    
    <content type="html"><![CDATA[<h2 id="Leetcode-Day-6"><a href="#Leetcode-Day-6" class="headerlink" title="Leetcode - Day 6"></a>Leetcode - Day 6</h2><p>题目：<strong>383. 赎金信</strong></p><p>难度：<strong>简单</strong></p><p>遇见次数：<strong>第一次</strong></p><p>涉及知识点：</p><ul><li>字符串</li><li>哈希表</li></ul><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="1-字母哈希计数"><a href="#1-字母哈希计数" class="headerlink" title="1. 字母哈希计数"></a>1. 字母哈希计数</h3><p><img src="https://typorastroage.oss-cn-beijing.aliyuncs.com/img/image-20210728120715643.png" alt="提交结果"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">canConstruct</span><span class="hljs-params">(String ransomNote, String magazine)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(magazine.length() == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">int</span>[] dicArr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">26</span>];<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> ch1 : magazine.toCharArray())&#123;<br>            dicArr[ch1 - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> ch2 : ransomNote.toCharArray())&#123;<br>            dicArr[ch2 - <span class="hljs-string">&#x27;a&#x27;</span>]--;<br><br>            <span class="hljs-keyword">if</span>(dicArr[ch2 - <span class="hljs-string">&#x27;a&#x27;</span>] &lt; <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ul><li>利用大小26的数组来进行计数</li><li>避免使用 <code>charAt()</code> 方法，因为每次调用它会检查一遍索引值是否越界，时间复杂度就会上去</li></ul>]]></content>
    
    
    <categories>
      
      <category>Leetcode Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2021/07/24/hello-world/"/>
    <url>/2021/07/24/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
