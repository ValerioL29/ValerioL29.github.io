<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>LeetCode Notes - 240</title>
    <link href="/2021/09/01/LeetCode-Notes-240/"/>
    <url>/2021/09/01/LeetCode-Notes-240/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-Notes-240"><a href="#Leetcode-Notes-240" class="headerlink" title="Leetcode Notes - 240"></a>Leetcode Notes - 240</h1><p>题目：<strong>240. 搜索二维矩阵 II</strong></p><p>难度：<strong>中等</strong></p><p>遇见次数：<strong>第二次</strong></p><p>涉及知识点：</p><ul><li>二分查找</li><li>搜索二维矩阵</li><li>搜索二叉树</li></ul><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="1-错就对了！"><a href="#1-错就对了！" class="headerlink" title="1. 错就对了！"></a>1. 错就对了！</h3><p>暴力法的废物…二分写不出来，麻了😭</p><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210901230057218.png" alt="暴力遍历"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">searchMatrix</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> c = <span class="hljs-number">0</span>; c &lt; matrix[<span class="hljs-number">0</span>].length; c++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> r = <span class="hljs-number">0</span>; r &lt; matrix.length; r++)&#123;<br>                <span class="hljs-keyword">if</span>(matrix[r][c] == target) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="剪枝"><a href="#剪枝" class="headerlink" title="剪枝"></a>剪枝</h3><h4 id="思路及算法"><a href="#思路及算法" class="headerlink" title="思路及算法"></a>思路及算法</h4><p>并不是想不到这个方法，很重要一个弯没有转过来。</p><p>就是向左向右不能是同一个单调性，于是我们有——</p><ul><li>选左上角，往右走和往下走都增大，不能选</li><li>选右下角，往上走和往左走都减小，不能选</li><li>选左下角，往右走增大，往上走减小，可选</li><li>选右上角，往下走增大，往左走减小，可选</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">searchMatrix</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>        <span class="hljs-comment">// start our &quot;pointer&quot; in the bottom-left</span><br>        <span class="hljs-keyword">int</span> row = matrix.length-<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> col = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span> (row &gt;= <span class="hljs-number">0</span> &amp;&amp; col &lt; matrix[<span class="hljs-number">0</span>].length) &#123;<br>            <span class="hljs-keyword">if</span> (matrix[row][col] &gt; target) &#123;<br>                row--;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (matrix[row][col] &lt; target) &#123;<br>                col++;<br>            &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// found it</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Notes - 435</title>
    <link href="/2021/09/01/LeetCode-Notes-435/"/>
    <url>/2021/09/01/LeetCode-Notes-435/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-Notes-435"><a href="#Leetcode-Notes-435" class="headerlink" title="Leetcode Notes - 435"></a>Leetcode Notes - 435</h1><p>题目：<strong>435. 无重叠区间</strong></p><p>难度：<strong>中等</strong></p><p>遇见次数：<strong>第二次</strong></p><p>涉及知识点：</p><ul><li>DP</li><li>贪心</li></ul><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="一直错，哭了，不会贪"><a href="#一直错，哭了，不会贪" class="headerlink" title="一直错，哭了，不会贪"></a>一直错，哭了，不会贪</h3><p>理解题解后重写版本😭</p><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210901234654745.png" alt="贪心"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">eraseOverlapIntervals</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] intervals)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(intervals.length &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        Arrays.sort(intervals, <span class="hljs-keyword">new</span> Comparator&lt;<span class="hljs-keyword">int</span>[]&gt;()&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span> <span class="hljs-params">(<span class="hljs-keyword">int</span>[] v1, <span class="hljs-keyword">int</span>[] v2)</span></span>&#123;<br>                <span class="hljs-keyword">return</span> v1[<span class="hljs-number">1</span>] - v2[<span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;);<br><br>        <span class="hljs-keyword">int</span> best = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> minRight = intervals[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; intervals.length; i++)&#123;<br>            <span class="hljs-keyword">if</span>(intervals[i][<span class="hljs-number">0</span>] &gt;= minRight)&#123;<br>                best++;<br>                minRight = intervals[i][<span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> intervals.length - best;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h3><h4 id="思路及算法"><a href="#思路及算法" class="headerlink" title="思路及算法"></a>思路及算法</h4><p>我们可以不断地寻找右端点在首个区间右端点左侧的新区间，将首个区间替换成该区间。那么当我们无法替换时，首个区间就是所有可以选择的区间中右端点最小的那个区间。因此我们将所有区间按照右端点从小到大进行排序，那么排完序之后的首个区间，就是我们选择的首个区间。</p><p>如果有多个区间的右端点都同样最小怎么办？由于我们选择的是首个区间，因此在左侧不会有其它的区间，那么左端点在何处是不重要的，我们只要任意选择一个右端点最小的区间即可。</p><p>当确定了首个区间之后，所有与首个区间不重合的区间就组成了一个规模更小的子问题。由于我们已经在初始时将所有区间按照右端点排好序了，因此对于这个子问题，我们无需再次进行排序，只要找出其中与首个区间不重合并且右端点最小的区间即可。用相同的方法，我们可以依次确定后续的所有区间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">eraseOverlapIntervals</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] intervals)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (intervals.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <br>        Arrays.sort(intervals, <span class="hljs-keyword">new</span> Comparator&lt;<span class="hljs-keyword">int</span>[]&gt;() &#123;<br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] interval1, <span class="hljs-keyword">int</span>[] interval2)</span> </span>&#123;<br>                <span class="hljs-keyword">return</span> interval1[<span class="hljs-number">1</span>] - interval2[<span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;);<br><br>        <span class="hljs-keyword">int</span> n = intervals.length;<br>        <span class="hljs-keyword">int</span> right = intervals[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (intervals[i][<span class="hljs-number">0</span>] &gt;= right) &#123;<br>                ++ans;<br>                right = intervals[i][<span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> n - ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Big Data Intro - Chapter 3</title>
    <link href="/2021/09/01/Big-Data-Intro-Chapter-3/"/>
    <url>/2021/09/01/Big-Data-Intro-Chapter-3/</url>
    
    <content type="html"><![CDATA[<h1 id="第03章-Hive分布式数据仓库"><a href="#第03章-Hive分布式数据仓库" class="headerlink" title="第03章 Hive分布式数据仓库"></a>第03章 Hive分布式数据仓库</h1><h2 id="Part1-Hive概述"><a href="#Part1-Hive概述" class="headerlink" title="Part1 Hive概述"></a>Part1 Hive概述</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Hive是基于<strong>Hadoop</strong>的<strong>数据仓库软件</strong>，可以<strong>查询和管理PB级别</strong>的分布式数据</p><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ol><li>灵活方便的ETL</li><li>支持Tez，Spark等多种计算引擎</li><li>可直接访问HDFS文件以及HBase</li><li>易用易编程</li></ol><h3 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h3><ol><li><p>Hive构建在基于<strong>静态批处理的Hadoop</strong>之上，而Hadoop通常都有<strong>较高的延迟</strong>并且在作业提交和调度的时候<strong>需要大量的开销</strong></p></li><li><p>Hive并不能在大规模数据集上实现<strong>低延迟快速的查询</strong>，并不适合低时延需求的应用，如OLTP（联合事务处理）</p><blockquote><p>例如Hive在几百MB的数据集上执行查询一般有<strong>分钟级</strong>的时间延迟。</p></blockquote></li><li><p>Hive并不提供<strong>实时的查询</strong>和<strong>基于行级的数据更新操作</strong></p></li><li><p>Hive的最佳使用场景是<strong>打出聚集的批处理作业</strong>，例如网络日志分析</p></li></ol><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol><li>高可靠与高容错<ul><li>HiveServer采用集群模式</li><li>双MetaStore</li><li>超时重试机制</li></ul></li><li>类SQL<ul><li>类似SQL语法</li><li>内置大量函数</li></ul></li><li>可扩展<ul><li>自定义存储格式</li><li>自定义函数</li></ul></li><li>多接口<ul><li>Beeline - Hive的命令行客户端</li><li>JDBC</li><li>Thrift - 一种序列化、通信协议</li><li>ODBC - 基于C/C++的数据库标准接口</li></ul></li></ol><h2 id="Part-2-Hive功能与架构"><a href="#Part-2-Hive功能与架构" class="headerlink" title="Part 2 Hive功能与架构"></a>Part 2 Hive功能与架构</h2><h3 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h3><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210901211737923.png" alt="Hive架构图"></p><p>其中需要补充的有——</p><ul><li><p>Optimizer：优化器，分为<strong>逻辑优化器和物理优化器</strong></p><blockquote><p>分别对HQL生成的执行计划和MapReduce任务进行优化</p></blockquote></li><li><p>Thrift Server：提供<strong>thrift接口</strong>，作为JDBC/ODBC接口，为用户访问提供接口</p></li><li><p>Clients：包含命令行接口Beeline和JDBC/ODBC接口，为用户访问提供接口</p></li></ul><h3 id="运行流程"><a href="#运行流程" class="headerlink" title="运行流程"></a>运行流程</h3><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210901212804665.png" alt="Hive运行流程"></p><h3 id="数据存储模型"><a href="#数据存储模型" class="headerlink" title="数据存储模型"></a>数据存储模型</h3><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210901214238333.png" alt="Hive数据存储模型"></p><p>几个基本概念——</p><ul><li><p>数据库：对应 <strong>Schema</strong>，创建表时如果不指定数据库，则默认为<strong>default</strong>数据库</p></li><li><p>表：物理概念，实际对应HDFS上的一个<strong>目录</strong></p></li><li><p>分区：对应所在表所在目下的一个<strong>子目录</strong></p><ul><li>当表格数据量较大时，可对表格进行分区处理 (Partition)</li><li>这样便于局部数据的查询操作，如按时间分区、按地域分区，将具有相同性质的数据存储到同一磁盘块上，从而加快查询效率</li></ul></li><li><p>桶：对应表或分区所在路径的一个<strong>文件</strong></p><ul><li>Hive是针对某一列进行分桶</li><li>Hive采用对列值哈希，然后除以桶的个数求余的方式决定该条记录存放在哪个桶中</li><li>分桶的好处是可以获得更高的查询处理效率。使取样更高效<ul><li>分桶的应用场景：1）数据抽样 2）提升某些查询操作效率，如：mapside join</li></ul></li></ul></li><li><p>数据的<strong>倾斜和正常</strong>：</p><ul><li><strong>倾斜：</strong>数据集中于个别字段值的场景，比如按照城市分区时，80%的数据都来自某个大城市</li><li><strong>正常：</strong>不存在倾斜的数据</li></ul></li><li><p>Hive可以创建两种表<strong>托管表和外部表</strong></p><ul><li><p>创建Hive表，Hive会将数据移动到<strong>数据仓库目录</strong></p></li><li><p>选择规则——</p><ul><li>如果<strong>所有处理都由Hive完成</strong>，建议使用<strong>托管表</strong></li><li>如果<strong>要用Hive和其他工具来处理同一个数据集</strong>，建议使用<strong>外部表</strong></li></ul></li><li><p>两者主要区别——</p><ul><li><p>Hive 创建表时</p><blockquote><ol><li>创建内部表时，会<strong>将数据移动到数据仓库</strong>指向的路径</li><li>若创建外部表，仅<strong>记录数据所在的路径， 不对数据的位置</strong>做任何改变</li></ol></blockquote></li><li><p>Hive 删除表的时</p><blockquote><ol><li>内部表的元数据和数据会被一起删除</li><li>外部表只删除元数据，不删除数据</li><li>这样外部表相对来说更加安全些，数据组织也更加灵活，方便共享源数据</li></ol></blockquote></li></ul></li></ul></li></ul><h2 id="Part-3-Hive基本操作与使用"><a href="#Part-3-Hive基本操作与使用" class="headerlink" title="Part 3 Hive基本操作与使用"></a>Part 3 Hive基本操作与使用</h2><p>详见后续博客</p>]]></content>
    
    
    <categories>
      
      <category>Big Data Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Big Data Intro - Chapter 2</title>
    <link href="/2021/08/31/Big-Data-Intro-Chapter-2/"/>
    <url>/2021/08/31/Big-Data-Intro-Chapter-2/</url>
    
    <content type="html"><![CDATA[<h1 id="第02章-HDFS分布式文件系统和ZooKeeper"><a href="#第02章-HDFS分布式文件系统和ZooKeeper" class="headerlink" title="第02章 HDFS分布式文件系统和ZooKeeper"></a>第02章 HDFS分布式文件系统和ZooKeeper</h1><h2 id="Part-1-HDFS"><a href="#Part-1-HDFS" class="headerlink" title="Part 1 - HDFS"></a>Part 1 - HDFS</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>是一种旨在商品硬件上运行的<strong>分布式文件系统</strong></p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol><li>具有<strong>高容错能力</strong>，旨在部署在低成本硬件上</li><li>提供<strong>高吞吐量的访问</strong>，适用于具有<strong>大数据集</strong>的应用程序</li><li>放宽一些<strong>POSIX</strong>要求，以实现对文件系统数据的<strong>流式访问</strong></li></ol><h3 id="不适用场景"><a href="#不适用场景" class="headerlink" title="不适用场景"></a>不适用场景</h3><h4 id="1-低时间延迟数据访问的应用（例如几十毫秒的范围）"><a href="#1-低时间延迟数据访问的应用（例如几十毫秒的范围）" class="headerlink" title="1. 低时间延迟数据访问的应用（例如几十毫秒的范围）"></a>1. 低时间延迟数据访问的应用（例如几十毫秒的范围）</h4><p><strong>原因：</strong>HDFS是为高吞吐量应用优化的，这样做会造成以<strong>高时间延迟</strong>为代价</p><h4 id="2-大量小文件"><a href="#2-大量小文件" class="headerlink" title="2. 大量小文件"></a>2. 大量小文件</h4><p><strong>原因：</strong>NameNode启动时，将文件系统的元数据加载到内存，因此文件系统所能存储的文件总数受限于NameNode内存容量。根据经验，每个文件，目录和数据块的存储信息大约占150字节，如果一百万个文件，且每个文件占一个数据块，那至少需要300MB的内存空间，但是如果存储十亿个文件，那么需要的内存空间将是非常大的。</p><h4 id="3-多用户写入，任意修改文件"><a href="#3-多用户写入，任意修改文件" class="headerlink" title="3. 多用户写入，任意修改文件"></a>3. 多用户写入，任意修改文件</h4><p><strong>原因：</strong>现在HDFS文件只有一个writer，而且写操作总是写在文件的末尾。也不支持在文件的任意位置进行修改。可能以后会支持，但相对比较低效</p><h3 id="Block-块"><a href="#Block-块" class="headerlink" title="Block - 块"></a>Block - 块</h3><blockquote><p><strong>HDFS</strong> 默认一个块 <strong>128MB</strong> ,一个文件被分成多个块，以块作为存储单位</p></blockquote><p>块的大小远远大于普通文件系统，这可以<strong>最小化寻址开销</strong></p><p>抽象的块概念可以带来以下几个明显的好处——</p><ul><li>支持大规模文件存储<ul><li>文件可以被拆分</li><li>不会受到单个节点的存储容量限制</li></ul></li><li>简化系统设计<ul><li>简化了存储管理</li><li>方便了元数据的管理</li></ul></li><li>适合数据备份<ul><li>每个块都可以冗余存储</li><li>大大提高系统的容错性和可用性</li></ul></li></ul><h3 id="基本系统架构"><a href="#基本系统架构" class="headerlink" title="基本系统架构"></a>基本系统架构</h3><p>HDFS架构包含三个部分：NameNode，DataNode，Client</p><ul><li>NameNode：NameNode用于存储、生成文件系统的元数据。运行一个实例</li><li>DataNode：DataNode用于存储实际的数据，将自己管理的数据块上报给 NameNode ，运行多个实例</li><li>Client：支持业务访问HDFS，从NameNode ,DataNode获取数据返回给业务。多个 实例，和业务一起运行</li></ul><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210831144335072.png" alt="NameNode和DataNode的关系"></p><h4 id="NameNode-——-名称节点"><a href="#NameNode-——-名称节点" class="headerlink" title="NameNode —— 名称节点"></a>NameNode —— 名称节点</h4><p>在 <strong>NameNode</strong> 中，保存了两个核心的数据结构，分别是 <strong>FsImage</strong> 和 <strong>EditLog</strong></p><ul><li><strong>FsImage</strong> 用于维护<ul><li>文件系统树</li><li>文件树中所有的文件和文件夹的元数据</li></ul></li><li>操作日志文件 <strong>EditLog</strong> 中记录了所有针对文件的创建、删除、重命名等操作</li></ul><p><strong>NameNode</strong> 还记录了每个文件中各个块所在的<strong>数据节点的位置信息</strong></p><h4 id="DataNode-——-数据节点"><a href="#DataNode-——-数据节点" class="headerlink" title="DataNode —— 数据节点"></a>DataNode —— 数据节点</h4><p>数据节点是HDFS的<strong>工作节点</strong>——负责数据的存储和读取</p><ul><li>根据 <strong>Client</strong> 或者 <strong>NameNode</strong> 的调度来进行数据的存储和检索</li><li>定期向 <strong>NameNode</strong> 发送自己所存储的块的列表</li></ul><p>每个数据节点中的数据会被保存在各自节点的本地Linux文件系统中</p><h3 id="HDFS-命名空间管理"><a href="#HDFS-命名空间管理" class="headerlink" title="HDFS 命名空间管理"></a>HDFS 命名空间管理</h3><p>首先，HDFS的命名空间包含目录、文件和块</p><p>其次，HDFS使用的是传统的<strong>分级文件体系</strong></p><p>最后，由 <strong>NameNode</strong> 负责维护文件系统命名空间</p><blockquote><p>对文件系统命名空间或其属性的任何更改均由 <strong>NameNode</strong> 记录</p></blockquote><h3 id="通信协议"><a href="#通信协议" class="headerlink" title="通信协议"></a>通信协议</h3><p>所有的HDFS通信协议都是构建在 <strong>TCP/IP</strong> 协议基础之上</p><p><strong>NN</strong> 和 <strong>DN</strong> 之间通过数据节点协议来进行交互</p><p><strong>Client</strong> 与 <strong>NN 和 DN</strong> 之间的交互是不同的——</p><ul><li>与 <strong>NN</strong> 进行交互是通过向 <strong>NN</strong> 主动发起 TCP 链接，并使用客户端协议与名称节点进行交互</li><li>与 <strong>DN</strong> 是通过<strong>RPC（Remote Procedure Call）</strong> 来实现的。</li></ul><p><strong>NameNode</strong> 不会主动发起 RPC，而是响应来自 <strong>DataNode</strong> 和 <strong>Client</strong> 的 RPC 请求</p><h3 id="单名称节点体系结构的局限性"><a href="#单名称节点体系结构的局限性" class="headerlink" title="单名称节点体系结构的局限性"></a>单名称节点体系结构的局限性</h3><p>HDFS 值设置唯一一个名称节点，虽然可以简化系统设计，但是会带来一些明显的局限</p><ol><li><p>命名空间的限制</p></li><li><p>性能的瓶颈</p></li><li><p>隔离问题</p></li><li><p>集群的可用性</p></li></ol><h3 id="HDFS的一些关键特性"><a href="#HDFS的一些关键特性" class="headerlink" title="HDFS的一些关键特性"></a>HDFS的一些关键特性</h3><h4 id="1-HA-——-高可用性"><a href="#1-HA-——-高可用性" class="headerlink" title="1. HA —— 高可用性"></a>1. HA —— 高可用性</h4><p>Hadoop 2.x 才推出的新特性，主要体现在利用 <strong>zookeeper</strong> 实现主备 <strong>NameNode</strong> ，来解决单点 <strong>NameNode</strong> 的故障问题</p><p>由此，我们引出 <strong>Zookeeper</strong> 的一个主要作用——</p><blockquote><p>用来存储 <strong>HA</strong> 下的状态文件，主备信息</p></blockquote><p>其中，由 <strong>ZKFC（Zookeeper Failover Controller）</strong> 用于监控 <strong>NN</strong> 结点的主备状态</p><blockquote><p><strong>ZKFC</strong> 还控制 <strong>NN</strong> 主备仲裁，两者部署在一起，个数相同</p><ul><li>利用 <strong>Zookeeper</strong> 的分布式锁功能，实现 <strong>主备仲裁</strong></li><li>再通过命令通道，控制 <strong>NN</strong> 的主备状态</li></ul></blockquote><p><strong>JN（Journal Node）</strong> 用于存储 <strong>Active NN（主 NN）</strong>生成的 <strong>Editlog</strong>。由 <strong>Standby NN</strong> 加载 <strong>JN</strong> 上 <strong>Editlog</strong> ,同步元数据</p><h4 id="2-HDFS-Federation"><a href="#2-HDFS-Federation" class="headerlink" title="2. HDFS Federation"></a>2. HDFS Federation</h4><p>即利用 **多个 NN ** 来组成命名空间，且互相之间是独立的，两两之间并不互相通信，单个失效也不会影响其他。简单理解为——</p><blockquote><p>各 <strong>NameNode</strong> 负责自己所属的目录。与Linux挂载磁盘到目录类似， 此时每个 <strong>NameNode</strong> 只负责整个hdfs集群中部分目录。</p><p>如NameNode1负责/database目录，那么在/database目录下的文件元数据都由NameNode1负责。各NameNode间元数据不共享，每个NameNode都有对应的standby。</p></blockquote><p>属于某一命名空间，即 <strong>Namespace</strong> ，的一组数据块，称为 <strong>Block Pool</strong></p><p>在 <strong>联邦</strong> 环境下，每个 <strong>NN</strong> 维护一个 <strong>Namespace Volume</strong> ，包括——</p><ul><li><strong>NS</strong> 的元数据</li><li>在该空间下的文件的所有数据块的 <strong>BP</strong></li></ul><h4 id="3-数据副本机制"><a href="#3-数据副本机制" class="headerlink" title="3. 数据副本机制"></a>3. 数据副本机制</h4><p>副本距离计算公式：</p><ul><li>Distance(Rack1/D1, Rack1/D1)=0</li><li>同一台服务器的距离为0</li><li>Distance(Rack1/D1, Rack1/D3)=2</li><li>同一机架不同的服务器距离为2</li><li>Distance(Rack1/D1, Rack2/D1)=4</li><li>不同机架的服务器距离为4</li><li>不同数据中心的节点距离为6。</li></ul><p>副本放置策略</p><ul><li>第一个副本：放置在上传文件的数据节点；如果是集群外提交，则随机挑选一台磁盘 不太满、CPU不太忙的节点</li><li>第二个副本：放置在与第一个副本不同的机架的节点上</li><li>第三个副本：与第一个副本相同机架的其他节点上</li><li>更多副本：随机节点</li></ul><p>如果写请求方所在机器是其中一个DataNode,则直接存放在本地,否则随机在集群中选择一 个DataNode</p><ul><li>Rack1：表示机架1</li><li>D1：表示DataNode节点1</li><li>B1：表示节点上的block块1</li></ul><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210831152858662.png" alt="数据副本机制"></p><h4 id="4-HDFS-数据完整性保障"><a href="#4-HDFS-数据完整性保障" class="headerlink" title="4. HDFS 数据完整性保障"></a>4. HDFS 数据完整性保障</h4><p>HDFS主要目的是<strong>保证存储数据完整性</strong>，对于各组件的失效，做了可靠性处理——</p><ul><li>重建失效数据盘的副本数据<ul><li>DataNode与NameNode之间通过心跳周期汇报数据状态，NameNode管理数据块是否上报完整</li><li>如果DataNode因硬盘损坏未上报数据块，NameNode将发起副本重建动作以恢复丢失的副本。</li></ul></li><li>集群数据均衡<ul><li>HDFS架构设计了<strong>数据均衡机制</strong>，该机制保证数据在各个 <strong>DataNode</strong> 上分布式平均的</li></ul></li><li>元数据可靠性保证<ul><li>采用日志机制操作元数据，同时元数据存放在主备 <strong>NameNode</strong> 上</li><li>快照机制实现了文件系统常见的快照机制，保证数据误操作时，能及时恢复</li></ul></li><li>安全模式防止故障扩散<ul><li>当节点硬盘故障时，进入安全模式，HDFS只支持访问元数据，此时HDFS上的数据是只读的，其他的操作如创建、删除文件等操作都会导致失败。</li><li>待硬盘问题解决、数据恢复后，再退出安全模式。</li></ul></li></ul><h4 id="5-HDFS架构其他关键设计要点说明"><a href="#5-HDFS架构其他关键设计要点说明" class="headerlink" title="5. HDFS架构其他关键设计要点说明"></a>5. HDFS架构其他关键设计要点说明</h4><ul><li>空间回收机制<ul><li>支持回收站机制以及副本数的动态设置机制</li></ul></li><li>数据组织<ul><li>数据存储以<strong>数据块</strong>为单位，存储在操作系统的HDFS文件系统上</li></ul></li><li>访问方式<ul><li>提供 <strong>JAVA API，HTTP 方式，SHELL 方式</strong> 访问HDFS数据</li></ul></li></ul><h3 id="HDFS-3-0-新特性总结"><a href="#HDFS-3-0-新特性总结" class="headerlink" title="HDFS 3.0 新特性总结"></a>HDFS 3.0 新特性总结</h3><ol><li><p>支持 HDFS 中的纠删码 <strong>Erasure Encoding</strong></p><blockquote><ul><li>通过在原始数据中加入新的校验数据,使得各个部分的数据产生关联性，在一定范围的数据出错情况下，通过纠删码技术都可以进行恢复。EC技术可以防止数据丢失，又可以解决HDFS存储空间翻倍的问题</li><li>创建文件时，将从最近的祖先目录继承EC策略，以确定其块如何存储。与3路复制相比，默认的EC策略可以节省50％的存储空间，同时还可以承受更多的存储故障</li><li>建议EC存储用于冷数据，由于冷数据确实数量大，可以减少副本从而降低存储空间， 另外冷数据稳定，一旦需要恢复数据，对业务不会有太大影响。</li></ul></blockquote></li><li><p>基于 HDFS 路由器的联合</p></li><li><p>支持多个 NameNode</p></li><li><p>DataNode 内部添加了负载均衡 Disk Balancer</p></li></ol><h3 id="HDFS-数据读写流程"><a href="#HDFS-数据读写流程" class="headerlink" title="HDFS 数据读写流程"></a>HDFS 数据读写流程</h3><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210831160054496.png" alt="HDFS 数据写入流程"></p><p>HDFS数据写入流程如下：</p><ul><li>业务应用调用HDFS Client提供的API，请求写入文件</li><li>HDFS Client联系NameNode，NameNode在元数据中创建文件节点</li><li>业务应用调用write API写入文件</li><li>HDFS Client收到业务数据后，从NameNode获取到数据块编号、位置信息后，联系 DataNode，并将需要写入数据的DataNode建立起流水线。完成后，客户端再通过 自有协议写入数据到DataNode1，再由DataNode1复制到DataNode2, DataNode3</li><li>写完的数据，将返回确认信息给HDFS Client</li><li>所有数据确认完成后，业务调用HDFS Client关闭文件</li><li>业务调用close, flush后HDFS Client联系NameNode，确认数据写完成，NameNode 持久化元数据</li></ul><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210831160131833.png" alt="HDFS 读取流程"></p><p>HDFS数据读取流程如下：</p><ul><li>业务应用调用HDFS Client提供的API打开文件</li><li>HDFS Client联系NameNode，获取到文件信息（数据块、DataNode位置信息）</li><li>业务应用调用read API读取文件</li><li>HDFS Client根据从NameNode获取到的信息，联系DataNode，获取相应的数据块。 (Client采用就近原则读取数据)</li><li>HDFS Client会与多个DataNode通讯获取数据块</li><li>数据读取完成后，业务调用close关闭连接</li></ul><h2 id="Part-2-ZooKeeper"><a href="#Part-2-ZooKeeper" class="headerlink" title="Part 2 - ZooKeeper"></a>Part 2 - ZooKeeper</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>主要是用来解决分布式应用中经常遇到的一些数据管理问题，提供分布式、高可用性的协调服务能力。</p><p>总体分为<strong>安全模式</strong>以及<strong>非安全模式</strong>——</p><ul><li>安全模式下依赖于 <strong>Kerberos</strong> 和 <strong>LdapServer</strong> 进行安全认证</li><li>非安全模式下则不依赖</li></ul><p><strong>ZK</strong> 作为底层组件广泛被上层组件使用并依赖，如 <strong>Kafka，HDFS，HBase，Storm</strong>等</p><h3 id="体系架构"><a href="#体系架构" class="headerlink" title="体系架构"></a>体系架构</h3><p>ZooKeeper 集群由一组 Server 节点组成，这一组 Server 节点中存在一个角色为 Leader 的节点， 其他节点都为 Follower，Leader 在启动时选举出。</p><blockquote><p>选举方式，对于 n 个实例的服务，n 可能为奇数或偶数：</p><ul><li>当有 <strong>n = 2x + 1</strong> 个节点时，则成为 <strong>Leader</strong> 的节点需要获得 <strong>x + 1</strong> 票，容灾能力为 <strong>x</strong></li><li>当有 <strong>n = 2x + 2</strong> 个节点时，则成为 <strong>Leader</strong> 的节点需要获得 <strong>x + 2</strong> 票（大于一半），容灾能力为 <strong>x</strong></li></ul></blockquote><p>ZooKeeper 使用了一种自定义的原子消息协议（ZooKeeper Atomic Broadcast Zab协议）， 在消息层的这种原子特性，保证了整个协调系统中的节点数据或状态的一致性。</p><p>Leader节点在接收到数据变更请求后，首先将变更写入本地磁盘，以作恢复之用。当所有 的写请求持久化到磁盘以后，才会将变更应用到内存中。</p><p>当客户端 Client 连接到 ZooKeeper 集群，并且执行写请求时，这些请求会被发送到 Leader 节点上，然后 Leader 节点上数据变更会同步到集群中其他的 Follower 节点。</p><h3 id="关键特性"><a href="#关键特性" class="headerlink" title="关键特性"></a>关键特性</h3><h4 id="1-最终一致性"><a href="#1-最终一致性" class="headerlink" title="1. 最终一致性"></a>1. 最终一致性</h4><p>无论哪个 server，对外展示的均是同一视图</p><h4 id="2-实时性"><a href="#2-实时性" class="headerlink" title="2. 实时性"></a>2. 实时性</h4><p>保证客户端将在一个时间间隔范围内获得服务器的更新信息，或者服务器失效的信息</p><h4 id="3-可靠性"><a href="#3-可靠性" class="headerlink" title="3. 可靠性"></a>3. 可靠性</h4><p>一条消息被一个 server 接收，它将被所有 server 接受</p><h4 id="4-等待无关性"><a href="#4-等待无关性" class="headerlink" title="4. 等待无关性"></a>4. 等待无关性</h4><p>慢的或者失效的 client 不会干预快速的 client 的请求，使得每个 client 都能有有效的等待</p><h4 id="5-原子性"><a href="#5-原子性" class="headerlink" title="5. 原子性"></a>5. 原子性</h4><p>更新只能成功或者失败，没有中间态</p><h4 id="6-顺序一致性"><a href="#6-顺序一致性" class="headerlink" title="6. 顺序一致性"></a>6. 顺序一致性</h4><p>客户端所发送的更新会按照他们被发送的顺序进行应用</p><h3 id="ZooKeeper-的读写特性"><a href="#ZooKeeper-的读写特性" class="headerlink" title="ZooKeeper 的读写特性"></a>ZooKeeper 的读写特性</h3><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210831163621689.png" alt="ZK的读操作"></p><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210831163648575.png" alt="ZK的写操作"></p>]]></content>
    
    
    <categories>
      
      <category>Big Data Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Notes - 59</title>
    <link href="/2021/08/31/LeetCode-Notes-59/"/>
    <url>/2021/08/31/LeetCode-Notes-59/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-Notes-59"><a href="#Leetcode-Notes-59" class="headerlink" title="Leetcode Notes - 59"></a>Leetcode Notes - 59</h1><p>题目：<strong>59. 螺旋矩阵 II</strong></p><p>难度：<strong>中等</strong></p><p>遇见次数：<strong>第二次</strong></p><p>涉及知识点：</p><ul><li>二维数组</li><li>模拟</li></ul><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="1-四指针"><a href="#1-四指针" class="headerlink" title="1. 四指针"></a>1. 四指针</h3><p>太！爽！啦！《关于我写出以前没写出来的题还优于题解这回事》🛫</p><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210831125303137.png" alt="四指针"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[][] generateMatrix(<span class="hljs-keyword">int</span> n) &#123;<br>        <span class="hljs-keyword">int</span>[][] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n][n];<br>        <br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> right = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> top = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> bottom = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> count = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(left &lt;= right &amp;&amp; top &lt;= bottom)&#123;<br>            <span class="hljs-comment">// left 2 right</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> l2r = left; l2r &lt; right; l2r++)&#123;<br>                res[top][l2r] = count;<br>                count++;<br>            &#125;<br><br>            <span class="hljs-comment">// top 2 bottom</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> t2b = top; t2b &lt; bottom; t2b++)&#123;<br>                res[t2b][right] = count;<br>                count++;<br>            &#125;<br><br>            <span class="hljs-comment">// right 2 left</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> r2l = right; r2l &gt; left; r2l--)&#123;<br>                res[bottom][r2l] = count;<br>                count++;<br>            &#125;<br><br>            <span class="hljs-comment">// bottom 2 top</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> b2t = bottom; b2t &gt; top; b2t--)&#123;<br>                res[b2t][left] = count;<br>                count++;<br>            &#125;<br><br>            left++;<br>            right--;<br>            top++;<br>            bottom--;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(n % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) res[(n - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>][(n - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>] = n * n;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h3><h4 id="思路及算法"><a href="#思路及算法" class="headerlink" title="思路及算法"></a>思路及算法</h4><p>模拟矩阵的生成。按照要求，初始位置设为矩阵的左上角，初始方向设为向右。若下一步的位置超出矩阵边界，或者是之前访问过的位置，则顺时针旋转，进入下一个方向。如此反复直至填入 <code>n^2</code> 个元素。</p><p>记 <code>matrix</code> 为生成的矩阵，其初始元素设为 0。由于填入的元素均为正数，我们可以判断当前位置的元素值，若不为 0，则说明已经访问过此位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[][] generateMatrix(<span class="hljs-keyword">int</span> n) &#123;<br>        <span class="hljs-keyword">int</span> maxNum = n * n;<br>        <span class="hljs-keyword">int</span> curNum = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span>[][] matrix = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n][n];<br>        <span class="hljs-keyword">int</span> row = <span class="hljs-number">0</span>, column = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span>[][] directions = &#123;&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;&#125;; <span class="hljs-comment">// 右下左上</span><br>        <span class="hljs-keyword">int</span> directionIndex = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (curNum &lt;= maxNum) &#123;<br>            matrix[row][column] = curNum;<br>            curNum++;<br>            <span class="hljs-keyword">int</span> nextRow = row + directions[directionIndex][<span class="hljs-number">0</span>], nextColumn = column + directions[directionIndex][<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (nextRow &lt; <span class="hljs-number">0</span> || nextRow &gt;= n || nextColumn &lt; <span class="hljs-number">0</span> || nextColumn &gt;= n || matrix[nextRow][nextColumn] != <span class="hljs-number">0</span>) &#123;<br>                directionIndex = (directionIndex + <span class="hljs-number">1</span>) % <span class="hljs-number">4</span>; <span class="hljs-comment">// 顺时针旋转至下一个方向</span><br>            &#125;<br>            row = row + directions[directionIndex][<span class="hljs-number">0</span>];<br>            column = column + directions[directionIndex][<span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> matrix;<br>    &#125;<br>&#125;<br><br>作者：LeetCode-Solution<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/spiral-matrix-ii/solution/luo-xuan-ju-zhen-ii-by-leetcode-solution-f7fp/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><blockquote><p>四指针就是按层模拟，这里学习一下模拟的做法</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Leetcode Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Notes - 48</title>
    <link href="/2021/08/31/LeetCode-Notes-48/"/>
    <url>/2021/08/31/LeetCode-Notes-48/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-Notes-48"><a href="#Leetcode-Notes-48" class="headerlink" title="Leetcode Notes - 48"></a>Leetcode Notes - 48</h1><p>题目：<strong>48. 旋转图像</strong></p><p>难度：<strong>中等</strong></p><p>遇见次数：<strong>第二次</strong></p><p>涉及知识点：</p><ul><li>二维数组</li><li>对角线反转</li></ul><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="1-两次翻转"><a href="#1-两次翻转" class="headerlink" title="1. 两次翻转"></a>1. 两次翻转</h3><p>不擦！一不小心就优于题解了呗🛫</p><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210831123212779.png" alt="两次翻转"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(matrix.length == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">int</span> column = matrix[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-keyword">int</span> row = matrix.length;<br><br>        <span class="hljs-comment">// Horizental rotation</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> hColumn = <span class="hljs-number">0</span>; hColumn &lt; column; hColumn++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> hRow = <span class="hljs-number">0</span>; hRow &lt; row / <span class="hljs-number">2</span>; hRow++)&#123;<br>                <span class="hljs-keyword">int</span> tmp = matrix[hRow][hColumn];<br>                matrix[hRow][hColumn] = matrix[row - hRow - <span class="hljs-number">1</span>][hColumn];<br>                matrix[row - hRow - <span class="hljs-number">1</span>][hColumn] = tmp;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// Main cross line rotation</span><br>        <span class="hljs-keyword">int</span> mcColumn = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> mcRow = <span class="hljs-number">0</span>; mcRow &lt; row; mcRow++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = mcColumn; i &lt; column; i++)&#123;<br>                <span class="hljs-keyword">int</span> tmp = matrix[mcRow][i];<br>                matrix[mcRow][i] = matrix[i][mcRow];<br>                matrix[i][mcRow] = tmp;<br>            &#125;<br>            mcColumn++;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="用翻转代替旋转"><a href="#用翻转代替旋转" class="headerlink" title="用翻转代替旋转"></a>用翻转代替旋转</h3><h4 id="思路及算法"><a href="#思路及算法" class="headerlink" title="思路及算法"></a>思路及算法</h4><p>一样啦，只是把竖直改成水平</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = matrix.length;<br>        <span class="hljs-comment">// 水平翻转</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n / <span class="hljs-number">2</span>; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>                <span class="hljs-keyword">int</span> temp = matrix[i][j];<br>                matrix[i][j] = matrix[n - i - <span class="hljs-number">1</span>][j];<br>                matrix[n - i - <span class="hljs-number">1</span>][j] = temp;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 主对角线翻转</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; ++j) &#123;<br>                <span class="hljs-keyword">int</span> temp = matrix[i][j];<br>                matrix[i][j] = matrix[j][i];<br>                matrix[j][i] = temp;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br>作者：LeetCode-Solution<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/rotate-image/solution/xuan-zhuan-tu-xiang-by-leetcode-solution-vu3m/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Notes - 118</title>
    <link href="/2021/08/31/LeetCode-Notes-118/"/>
    <url>/2021/08/31/LeetCode-Notes-118/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-118"><a href="#Leetcode-118" class="headerlink" title="Leetcode - 118"></a>Leetcode - 118</h1><p>题目：<strong>118. 杨辉三角</strong></p><p>难度：<strong>简单</strong></p><p>遇见次数：<strong>第二次</strong></p><p>涉及知识点：</p><ul><li>数学</li><li>线性递推</li></ul><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><p>所谓显式队列😅</p><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210831121026373.png" alt="队列迭代"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">getRow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> rowIndex)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(rowIndex == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;(Arrays.asList(<span class="hljs-number">1</span>)); <br><br>        LinkedList&lt;Integer&gt; doQue = <span class="hljs-keyword">new</span> LinkedList&lt;Integer&gt;();<br>        doQue.offerLast(<span class="hljs-number">0</span>);<br>        doQue.offerLast(<span class="hljs-number">1</span>);<br>        doQue.offerLast(<span class="hljs-number">0</span>);<br><br>        <span class="hljs-keyword">int</span> curIndex = <span class="hljs-number">0</span>;<br>        List&lt;Integer&gt; curList = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br><br>        <span class="hljs-keyword">while</span>(curIndex &lt; rowIndex)&#123;<br>            curList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>            <span class="hljs-keyword">int</span> len = doQue.size();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len - <span class="hljs-number">1</span>; i++)&#123;<br>                <span class="hljs-keyword">int</span> tmp = doQue.poll();<br>                tmp = tmp + doQue.peek();<br>                curList.add(tmp);<br>            &#125;<br><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> ele : curList)&#123;<br>                doQue.offerLast(ele);<br>            &#125;<br>            doQue.offerLast(<span class="hljs-number">0</span>);<br><br>            curIndex++;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> curList;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="数学-线性递推"><a href="#数学-线性递推" class="headerlink" title="数学 - 线性递推"></a>数学 - 线性递推</h3><p>由组合数公式我们，可以得到同一行的相邻组合数的关系——</p><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210831121305506.png" alt="组合数公式"></p><p>利用上述公式我们可以在线性时间计算出第 n 行的所有组合数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">getRow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> rowIndex)</span> </span>&#123;<br>        List&lt;Integer&gt; row = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>        row.add(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= rowIndex; ++i) &#123;<br>            row.add((<span class="hljs-keyword">int</span>) ((<span class="hljs-keyword">long</span>) row.get(i - <span class="hljs-number">1</span>) * (rowIndex - i + <span class="hljs-number">1</span>) / i));<br>        &#125;<br>        <span class="hljs-keyword">return</span> row;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Notes - 706</title>
    <link href="/2021/08/31/LeetCode-Notes-706/"/>
    <url>/2021/08/31/LeetCode-Notes-706/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-Notes-706"><a href="#Leetcode-Notes-706" class="headerlink" title="Leetcode Notes - 706"></a>Leetcode Notes - 706</h1><p>题目：<strong>706. 设计哈希映射</strong></p><p>难度：<strong>简单</strong></p><p>遇见次数：<strong>第二次</strong></p><p>涉及知识点：</p><ul><li>哈希映射</li><li>链地址法</li></ul><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="1-链地址法"><a href="#1-链地址法" class="headerlink" title="1. 链地址法"></a>1. 链地址法</h3><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210831003333051.png" alt="双链表对应"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyHashMap</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> BASE = <span class="hljs-number">769</span>;<br>    <span class="hljs-keyword">private</span> LinkedList[][] data;<br><br>    <span class="hljs-comment">/** Initialize your data structure here. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyHashMap</span><span class="hljs-params">()</span> </span>&#123;<br>        data = <span class="hljs-keyword">new</span> LinkedList[BASE][<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; BASE; ++i) &#123;<br>            data[i][<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> LinkedList&lt;Integer&gt;();<br>            data[i][<span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> LinkedList&lt;Integer&gt;();<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">/** value will always be non-negative. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> h = hash(key);<br>        LinkedList keyList = <span class="hljs-keyword">this</span>.data[h][<span class="hljs-number">0</span>];<br>        LinkedList valueList = <span class="hljs-keyword">this</span>.data[h][<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; keyList.size(); i++)&#123;<br>            Integer curKey = (<span class="hljs-keyword">int</span>) keyList.get(i);<br>            <span class="hljs-keyword">if</span>(curKey == key)&#123;<br>                valueList.set(i, value);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">this</span>.data[h][<span class="hljs-number">0</span>].offerLast(key);<br>        <span class="hljs-keyword">this</span>.data[h][<span class="hljs-number">1</span>].offerLast(value);<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> h = hash(key);<br>        LinkedList keyList = <span class="hljs-keyword">this</span>.data[h][<span class="hljs-number">0</span>];<br>        LinkedList valueList = <span class="hljs-keyword">this</span>.data[h][<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; keyList.size(); i++)&#123;<br>            Integer curKey = (<span class="hljs-keyword">int</span>) keyList.get(i);<br>            <span class="hljs-keyword">if</span>(curKey == key)&#123;<br>                <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>) valueList.get(i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Removes the mapping of the specified value key if this map contains a mapping for the key */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> h = hash(key);<br>        LinkedList keyList = <span class="hljs-keyword">this</span>.data[h][<span class="hljs-number">0</span>];<br>        LinkedList valueList = <span class="hljs-keyword">this</span>.data[h][<span class="hljs-number">1</span>];<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; keyList.size(); i++)&#123;<br>            Integer curKey = (<span class="hljs-keyword">int</span>) keyList.get(i);<br>            <span class="hljs-keyword">if</span>(curKey == key)&#123;<br>                keyList.remove(curKey);<br>                valueList.remove(valueList.get(i));<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> key % BASE;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MyHashMap object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MyHashMap obj = new MyHashMap();</span><br><span class="hljs-comment"> * obj.put(key,value);</span><br><span class="hljs-comment"> * int param_2 = obj.get(key);</span><br><span class="hljs-comment"> * obj.remove(key);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="链地址法"><a href="#链地址法" class="headerlink" title="链地址法"></a>链地址法</h3><h4 id="思路及算法"><a href="#思路及算法" class="headerlink" title="思路及算法"></a>思路及算法</h4><p>官方题解利用了内部私有类，定义了 <code>Pair</code> 来完成 <code>&#123;key, value&#125;</code> 的对应</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyHashMap</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pair</span> </span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> key;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> value;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Pair</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.key = key;<br>            <span class="hljs-keyword">this</span>.value = value;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getKey</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> key;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getValue</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> value;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setValue</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.value = value;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> BASE = <span class="hljs-number">769</span>;<br>    <span class="hljs-keyword">private</span> LinkedList[] data;<br><br>    <span class="hljs-comment">/** Initialize your data structure here. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyHashMap</span><span class="hljs-params">()</span> </span>&#123;<br>        data = <span class="hljs-keyword">new</span> LinkedList[BASE];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; BASE; ++i) &#123;<br>            data[i] = <span class="hljs-keyword">new</span> LinkedList&lt;Pair&gt;();<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">/** value will always be non-negative. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> h = hash(key);<br>        Iterator&lt;Pair&gt; iterator = data[h].iterator();<br>        <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>            Pair pair = iterator.next();<br>            <span class="hljs-keyword">if</span> (pair.getKey() == key) &#123;<br>                pair.setValue(value);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>        data[h].offerLast(<span class="hljs-keyword">new</span> Pair(key, value));<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> h = hash(key);<br>        Iterator&lt;Pair&gt; iterator = data[h].iterator();<br>        <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>            Pair pair = iterator.next();<br>            <span class="hljs-keyword">if</span> (pair.getKey() == key) &#123;<br>                <span class="hljs-keyword">return</span> pair.value;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Removes the mapping of the specified value key if this map contains a mapping for the key */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> h = hash(key);<br>        Iterator&lt;Pair&gt; iterator = data[h].iterator();<br>        <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>            Pair pair = iterator.next();<br>            <span class="hljs-keyword">if</span> (pair.key == key) &#123;<br>                data[h].remove(pair);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> key % BASE;<br>    &#125;<br>&#125;<br><br>作者：LeetCode-Solution<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/design-hashmap/solution/she-ji-ha-xi-ying-she-by-leetcode-soluti-klu9/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Notes - 705</title>
    <link href="/2021/08/31/LeetCode-Notes-705/"/>
    <url>/2021/08/31/LeetCode-Notes-705/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-Notes-705"><a href="#Leetcode-Notes-705" class="headerlink" title="Leetcode Notes - 705"></a>Leetcode Notes - 705</h1><p>题目：<strong>705. 设计哈希集合</strong></p><p>难度：<strong>简单</strong></p><p>遇见次数：<strong>第一次</strong></p><p>涉及知识点：</p><ul><li>哈希映射实现</li><li>哈希函数</li><li>链地址法</li></ul><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="1-链地址法"><a href="#1-链地址法" class="headerlink" title="1. 链地址法"></a>1. 链地址法</h3><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210831001654888.png" alt="链地址法"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyHashSet</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> BASE = <span class="hljs-number">769</span>;<br>    <span class="hljs-keyword">private</span> LinkedList[] dataArr;<br><br>    <span class="hljs-comment">/** Initialize your data structure here. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyHashSet</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.dataArr = <span class="hljs-keyword">new</span> LinkedList[BASE];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; BASE; i++)&#123;<br>            <span class="hljs-keyword">this</span>.dataArr[i] = <span class="hljs-keyword">new</span> LinkedList&lt;Integer&gt;();<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> h = <span class="hljs-keyword">this</span>.hash(key);<br><br>        Iterator&lt;Integer&gt; cur = <span class="hljs-keyword">this</span>.dataArr[h].iterator();<br>        <span class="hljs-keyword">while</span>(cur.hasNext())&#123;<br>            Integer ele = cur.next();<br>            <span class="hljs-keyword">if</span>(ele == key)&#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">this</span>.dataArr[h].offerLast(key);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> h = <span class="hljs-keyword">this</span>.hash(key);<br><br>        Iterator&lt;Integer&gt; cur = <span class="hljs-keyword">this</span>.dataArr[h].iterator();<br>        <span class="hljs-keyword">while</span>(cur.hasNext())&#123;<br>            Integer ele = cur.next();<br>            <span class="hljs-keyword">if</span>(ele == key)&#123;<br>                <span class="hljs-keyword">this</span>.dataArr[h].remove(ele);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Returns true if this set contains the specified element */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">contains</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> h = <span class="hljs-keyword">this</span>.hash(key);<br><br>        Iterator&lt;Integer&gt; cur = <span class="hljs-keyword">this</span>.dataArr[h].iterator();<br>        <span class="hljs-keyword">while</span>(cur.hasNext())&#123;<br>            Integer ele = cur.next();<br>            <span class="hljs-keyword">if</span>(ele == key)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> val % BASE;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MyHashSet object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MyHashSet obj = new MyHashSet();</span><br><span class="hljs-comment"> * obj.add(key);</span><br><span class="hljs-comment"> * obj.remove(key);</span><br><span class="hljs-comment"> * boolean param_3 = obj.contains(key);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="链地址法"><a href="#链地址法" class="headerlink" title="链地址法"></a>链地址法</h3><h4 id="思路及算法"><a href="#思路及算法" class="headerlink" title="思路及算法"></a>思路及算法</h4><p>设哈希表的大小为 <code>base</code>，则可以设计一个简单的哈希函数：<code>hash(x) = x mod base</code>。</p><p>我们开辟一个大小为 <code>base</code> 的数组，数组的每个位置是一个链表。当计算出哈希值之后，就插入到对应位置的链表当中。</p><p>由于我们使用整数除法作为哈希函数，为了尽可能避免冲突，应当将 \textit{base}base 取为一个质数。在这里，我们取 <code>base = 769</code>。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tL0ZpZ3VyZXMvNzA1LzcwNV9saW5rZWRfbGlzdC5wbmc?x-oss-process=image/format,png" alt="fig"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyHashSet</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> BASE = <span class="hljs-number">769</span>;<br>    <span class="hljs-keyword">private</span> LinkedList[] data;<br><br>    <span class="hljs-comment">/** Initialize your data structure here. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyHashSet</span><span class="hljs-params">()</span> </span>&#123;<br>        data = <span class="hljs-keyword">new</span> LinkedList[BASE];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; BASE; ++i) &#123;<br>            data[i] = <span class="hljs-keyword">new</span> LinkedList&lt;Integer&gt;();<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> h = hash(key);<br>        Iterator&lt;Integer&gt; iterator = data[h].iterator();<br>        <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>            Integer element = iterator.next();<br>            <span class="hljs-keyword">if</span> (element == key) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>        data[h].offerLast(key);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> h = hash(key);<br>        Iterator&lt;Integer&gt; iterator = data[h].iterator();<br>        <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>            Integer element = iterator.next();<br>            <span class="hljs-keyword">if</span> (element == key) &#123;<br>                data[h].remove(element);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Returns true if this set contains the specified element */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">contains</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> h = hash(key);<br>        Iterator&lt;Integer&gt; iterator = data[h].iterator();<br>        <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>            Integer element = iterator.next();<br>            <span class="hljs-keyword">if</span> (element == key) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> key % BASE;<br>    &#125;<br>&#125;<br><br>作者：LeetCode-Solution<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/design-hashset/solution/she-ji-ha-xi-ji-he-by-leetcode-solution-xp4t/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><blockquote><p>这里选择769是因为他是质数，能使桶分配的更平均，具体推到和数学原理有待思考！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Leetcode Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Notes - 56</title>
    <link href="/2021/08/31/LeetCode-Notes-56/"/>
    <url>/2021/08/31/LeetCode-Notes-56/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-Notes-56"><a href="#Leetcode-Notes-56" class="headerlink" title="Leetcode Notes - 56"></a>Leetcode Notes - 56</h1><p>题目：<strong>56. 合并区间</strong></p><p>难度：<strong>中等</strong></p><p>遇见次数：<strong>第二次</strong></p><p>涉及知识点：</p><ul><li>二维数组排序</li><li>贪心算法</li></ul><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="1-贪心算法"><a href="#1-贪心算法" class="headerlink" title="1. 贪心算法"></a>1. 贪心算法</h3><p>并不正确的贪心哈哈，没过，但是记录一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[][] merge(<span class="hljs-keyword">int</span>[][] intervals) &#123;<br>        <span class="hljs-keyword">if</span>(intervals.length == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> intervals;<br>        <br>        Arrays.sort(intervals, <span class="hljs-keyword">new</span> Comparator&lt;<span class="hljs-keyword">int</span>[]&gt;()&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] v1, <span class="hljs-keyword">int</span>[] v2)</span></span>&#123;<br>                <span class="hljs-keyword">return</span> v1[<span class="hljs-number">0</span>] - v2[<span class="hljs-number">0</span>];<br>            &#125;<br>        &#125;);<br>        <br>        <span class="hljs-keyword">int</span> p = <span class="hljs-number">1</span>;<br>        List&lt;<span class="hljs-keyword">int</span>[]&gt; resList = <span class="hljs-keyword">new</span> ArrayList&lt;<span class="hljs-keyword">int</span>[]&gt;();<br>        <span class="hljs-keyword">int</span> curLeft = intervals[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">int</span> curRight = intervals[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];<br>        <br>        <span class="hljs-keyword">while</span>(p &lt; intervals.length)&#123;<br>            <span class="hljs-keyword">if</span>(intervals[p][<span class="hljs-number">0</span>] &lt;= curRight)&#123;<br>                <span class="hljs-keyword">if</span>(curRight &lt;= intervals[p][<span class="hljs-number">1</span>])&#123;<br>                    curRight = intervals[p][<span class="hljs-number">1</span>];<br>                &#125;<br>                p++;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">int</span>[] cur = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">2</span>];<br>                cur[<span class="hljs-number">0</span>] = curLeft;<br>                cur[<span class="hljs-number">1</span>] = curRight;<br>                resList.add(cur);<br>                <br>                curLeft = intervals[p][<span class="hljs-number">0</span>];<br>                curRight = intervals[p][<span class="hljs-number">1</span>];<br>                p++;<br>            &#125;   <br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span>(curLeft == intervals[p - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] &amp;&amp; curRight == intervals[p - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>])&#123;<br>            <span class="hljs-keyword">int</span>[] temp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">2</span>];<br>            temp[<span class="hljs-number">0</span>] = curLeft;<br>            temp[<span class="hljs-number">1</span>] = curRight;<br>            resList.add(temp);<br>        &#125;<br>        <br>        <span class="hljs-keyword">int</span>[][] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[resList.size()][<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; resList.size(); i++)&#123;<br>            res[i] = resList.get(i);<br>        &#125;<br>            <br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="排序-贪心"><a href="#排序-贪心" class="headerlink" title="排序 + 贪心"></a>排序 + 贪心</h3><h4 id="思路及算法"><a href="#思路及算法" class="headerlink" title="思路及算法"></a>思路及算法</h4><p>我们用数组 <code>merged</code> 存储最终的答案。</p><p>首先，我们将列表中的区间按照左端点升序排序。然后我们将第一个区间加入 <code>merged</code> 数组中，并按顺序依次考虑之后的每个区间：</p><ul><li>如果当前区间的左端点在数组 <code>merged</code> 中最后一个区间的右端点之后，那么它们不会重合，我们可以直接将这个区间加入数组 <code>merged</code> 的末尾；</li><li>否则，它们重合，我们需要用当前区间的右端点更新数组 <code>merged</code> 中最后一个区间的右端点，将其置为二者的较大值。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[][] merge(<span class="hljs-keyword">int</span>[][] intervals) &#123;<br>        <span class="hljs-keyword">if</span> (intervals.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>];<br>        &#125;<br>        Arrays.sort(intervals, <span class="hljs-keyword">new</span> Comparator&lt;<span class="hljs-keyword">int</span>[]&gt;() &#123;<br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] interval1, <span class="hljs-keyword">int</span>[] interval2)</span> </span>&#123;<br>                <span class="hljs-keyword">return</span> interval1[<span class="hljs-number">0</span>] - interval2[<span class="hljs-number">0</span>];<br>            &#125;<br>        &#125;);<br>        List&lt;<span class="hljs-keyword">int</span>[]&gt; merged = <span class="hljs-keyword">new</span> ArrayList&lt;<span class="hljs-keyword">int</span>[]&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; intervals.length; ++i) &#123;<br>            <span class="hljs-keyword">int</span> L = intervals[i][<span class="hljs-number">0</span>], R = intervals[i][<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (merged.size() == <span class="hljs-number">0</span> || merged.get(merged.size() - <span class="hljs-number">1</span>)[<span class="hljs-number">1</span>] &lt; L) &#123;<br>                merged.add(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;L, R&#125;);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                merged.get(merged.size() - <span class="hljs-number">1</span>)[<span class="hljs-number">1</span>] = Math.max(merged.get(merged.size() - <span class="hljs-number">1</span>)[<span class="hljs-number">1</span>], R);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> merged.toArray(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[merged.size()][]);<br>    &#125;<br>&#125;<br><br>作者：LeetCode-Solution<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/merge-intervals/solution/he-bing-qu-jian-by-leetcode-solution/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Notes - 75</title>
    <link href="/2021/08/31/LeetCode-Notes-75/"/>
    <url>/2021/08/31/LeetCode-Notes-75/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-Notes-75"><a href="#Leetcode-Notes-75" class="headerlink" title="Leetcode Notes -75"></a>Leetcode Notes -75</h1><p>题目：<strong>75. 颜色分类</strong></p><p>难度：<strong>简单</strong></p><p>遇见次数：<strong>第二次</strong></p><p>涉及知识点：</p><ul><li>双指针</li><li>排序</li></ul><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="1-双指针"><a href="#1-双指针" class="headerlink" title="1. 双指针"></a>1. 双指针</h3><p>不正确的双指针😀</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sortColors</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(nums.length &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;<br>        <br>        <span class="hljs-keyword">int</span> p0 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> p2 = nums.length - <span class="hljs-number">1</span>;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++)&#123;<br>            <span class="hljs-keyword">if</span>(i &gt; p2) <span class="hljs-keyword">break</span>;<br>            <br>            <span class="hljs-keyword">int</span> tmp = -<span class="hljs-number">1</span>;<br>            <br>            <span class="hljs-keyword">while</span>(nums[i] != <span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">if</span>(nums[i] == <span class="hljs-number">0</span>)&#123;<br>                    tmp = nums[p0];<br>                    nums[p0] = <span class="hljs-number">0</span>;<br>                    nums[i] = tmp;<br>                    p0++;<br>                &#125;<br><br>                <span class="hljs-keyword">if</span>(nums[i] == <span class="hljs-number">2</span>)&#123;<br>                    tmp = nums[p2];<br>                    nums[p2] = <span class="hljs-number">2</span>;<br>                    nums[i] = tmp;<br>                    p2--;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span>;<br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><h4 id="思路及算法"><a href="#思路及算法" class="headerlink" title="思路及算法"></a>思路及算法</h4><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210831004334916.png" alt="力扣题解"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sortColors</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(nums.length &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;<br>        <br>        <span class="hljs-keyword">int</span> p0 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> p2 = nums.length - <span class="hljs-number">1</span>;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++)&#123;<br>            <span class="hljs-keyword">if</span>(i &gt; p2) <span class="hljs-keyword">break</span>;<br>            <br>            <span class="hljs-keyword">int</span> tmp = -<span class="hljs-number">1</span>;<br>            <br>            <span class="hljs-keyword">while</span>(nums[i] != <span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">if</span>(nums[i] == <span class="hljs-number">0</span>)&#123;<br>                    tmp = nums[p0];<br>                    nums[p0] = <span class="hljs-number">0</span>;<br>                    nums[i] = tmp;<br>                    p0++;<br>                &#125;<br><br>                <span class="hljs-keyword">if</span>(nums[i] == <span class="hljs-number">2</span>)&#123;<br>                    tmp = nums[p2];<br>                    nums[p2] = <span class="hljs-number">2</span>;<br>                    nums[i] = tmp;<br>                    p2--;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span>;<br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Notes - 169</title>
    <link href="/2021/08/31/LeetCode-Notes-169/"/>
    <url>/2021/08/31/LeetCode-Notes-169/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-Notes-169"><a href="#Leetcode-Notes-169" class="headerlink" title="Leetcode Notes - 169"></a>Leetcode Notes - 169</h1><p>题目：<strong>169. 多数元素</strong></p><p>难度：<strong>简单</strong></p><p>遇见次数：<strong>第二次</strong></p><p>涉及知识点：</p><ul><li>哈希</li><li>摩尔投票算法</li></ul><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="1-摩尔投票算法"><a href="#1-摩尔投票算法" class="headerlink" title="1. 摩尔投票算法"></a>1. 摩尔投票算法</h3><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210829220640206.png" alt="摩尔投票算法"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> candidate = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i : nums)&#123;<br>            <span class="hljs-keyword">if</span>(i == candidate)&#123;<br>                count++;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                count--;<br><br>                <span class="hljs-keyword">if</span>(count == <span class="hljs-number">0</span>)&#123;<br>                    candidate = i;<br>                    count = <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> candidate;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="Boyer-Moore-投票算法"><a href="#Boyer-Moore-投票算法" class="headerlink" title="Boyer-Moore 投票算法"></a>Boyer-Moore 投票算法</h3><h4 id="思路及算法"><a href="#思路及算法" class="headerlink" title="思路及算法"></a>思路及算法</h4><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210829220755990.png" alt="LeetCode官方题解"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>        Integer candidate = <span class="hljs-keyword">null</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) &#123;<br>            <span class="hljs-keyword">if</span> (count == <span class="hljs-number">0</span>) &#123;<br>                candidate = num;<br>            &#125;<br>            count += (num == candidate) ? <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> candidate;<br>    &#125;<br>&#125;<br><br>作者：LeetCode-Solution<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/majority-element/solution/duo-shu-yuan-su-by-leetcode-solution/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Notes - 136</title>
    <link href="/2021/08/29/LeetCode-Notes-136/"/>
    <url>/2021/08/29/LeetCode-Notes-136/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-Notes-136"><a href="#Leetcode-Notes-136" class="headerlink" title="Leetcode Notes - 136"></a>Leetcode Notes - 136</h1><p>题目：<strong>136. 只出现一次的数字</strong></p><p>难度：<strong>简单</strong></p><p>遇见次数：<strong>第二次</strong></p><p>涉及知识点：</p><ul><li>位运算</li><li>异或运算</li></ul><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="1-位运算"><a href="#1-位运算" class="headerlink" title="1. 位运算"></a>1. 位运算</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num: nums) &#123;<br>            ans ^= num;<br>            System.out.println(ans);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><h4 id="思路及算法"><a href="#思路及算法" class="headerlink" title="思路及算法"></a>思路及算法</h4><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210829211115524.png" alt="136.题解"></p>]]></content>
    
    
    <categories>
      
      <category>Leetcode Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Notes - 232</title>
    <link href="/2021/07/31/LeetCode-Notes-232/"/>
    <url>/2021/07/31/LeetCode-Notes-232/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-Day-9"><a href="#Leetcode-Day-9" class="headerlink" title="Leetcode - Day 9"></a>Leetcode - Day 9</h1><p>题目：<strong>232. 用栈实现队列</strong></p><p>难度：<strong>简单</strong></p><p>遇见次数：<strong>第一次</strong></p><p>涉及知识点：</p><ul><li>栈</li></ul><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="作弊"><a href="#作弊" class="headerlink" title="作弊"></a>作弊</h3><p>面向答案的编程😈</p><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210731172343379.png" alt="提交情况"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyQueue</span> </span>&#123;<br>    Queue&lt;Integer&gt; myQueue;<br><br>    <span class="hljs-comment">/** Initialize your data structure here. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyQueue</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.myQueue = <span class="hljs-keyword">new</span> LinkedList&lt;Integer&gt;();<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Push element x to the back of queue. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        myQueue.offer(x);<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Removes the element from in front of queue and returns that element. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> ele = myQueue.poll();<br><br>        <span class="hljs-keyword">return</span> ele;<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Get the front element. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">peek</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> ele = myQueue.peek();<br><br>        <span class="hljs-keyword">return</span> ele;<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Returns whether the queue is empty. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> myQueue.isEmpty();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MyQueue object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MyQueue obj = new MyQueue();</span><br><span class="hljs-comment"> * obj.push(x);</span><br><span class="hljs-comment"> * int param_2 = obj.pop();</span><br><span class="hljs-comment"> * int param_3 = obj.peek();</span><br><span class="hljs-comment"> * boolean param_4 = obj.empty();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="双栈"><a href="#双栈" class="headerlink" title="双栈"></a>双栈</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>将一个栈当作输入栈，用于压入 push 传入的数据；另一个栈当作输出栈，用于 pop 和 peek 操作。</p><p>每次 pop 或 peek 时，若输出栈为空则将输入栈的全部数据依次弹出并压入输出栈，这样输出栈从栈顶往栈底的顺序就是队列从队首往队尾的顺序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyQueue</span> </span>&#123;<br>    Deque&lt;Integer&gt; inStack;<br>    Deque&lt;Integer&gt; outStack;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyQueue</span><span class="hljs-params">()</span> </span>&#123;<br>        inStack = <span class="hljs-keyword">new</span> LinkedList&lt;Integer&gt;();<br>        outStack = <span class="hljs-keyword">new</span> LinkedList&lt;Integer&gt;();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        inStack.push(x);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (outStack.isEmpty()) &#123;<br>            in2out();<br>        &#125;<br>        <span class="hljs-keyword">return</span> outStack.pop();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">peek</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (outStack.isEmpty()) &#123;<br>            in2out();<br>        &#125;<br>        <span class="hljs-keyword">return</span> outStack.peek();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> inStack.isEmpty() &amp;&amp; outStack.isEmpty();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">in2out</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (!inStack.isEmpty()) &#123;<br>            outStack.push(inStack.pop());<br>        &#125;<br>    &#125;<br>&#125;<br><br>作者：LeetCode-Solution<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/implement-queue-using-stacks/solution/yong-zhan-shi-xian-dui-lie-by-leetcode-s-xnb6/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Notes - 20</title>
    <link href="/2021/07/31/LeetCode-Notes-20/"/>
    <url>/2021/07/31/LeetCode-Notes-20/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-Day-9"><a href="#Leetcode-Day-9" class="headerlink" title="Leetcode - Day 9"></a>Leetcode - Day 9</h1><p>题目：<strong>20. 有效的括号</strong></p><p>难度：<strong>简单</strong></p><p>遇见次数：<strong>第一次</strong></p><p>涉及知识点：</p><ul><li>栈</li></ul><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="1-栈"><a href="#1-栈" class="headerlink" title="1. 栈"></a>1. 栈</h3><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210731171027262.png" alt="提交情况"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValid</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(s.length() % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br><br>        <span class="hljs-keyword">char</span>[] strArr = s.toCharArray();<br>        Stack&lt;Character&gt; myStack = <span class="hljs-keyword">new</span> Stack&lt;Character&gt;();<br><br>        <span class="hljs-keyword">int</span> no = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; strArr.length; i++)&#123;<br>            no = typeJudge(strArr[i]);<br><br>            <span class="hljs-keyword">if</span>(no &lt;= <span class="hljs-number">3</span>)&#123;<br>                myStack.push(strArr[i]);<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">if</span>(myStack.empty()) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br><br>                <span class="hljs-keyword">if</span>(no - typeJudge(myStack.peek()) != <span class="hljs-number">3</span>)&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>                &#125;<br><br>                myStack.pop();<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> myStack.empty() ? <span class="hljs-keyword">true</span> : <span class="hljs-keyword">false</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">typeJudge</span><span class="hljs-params">(<span class="hljs-keyword">char</span> ch)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(ch == <span class="hljs-string">&#x27;(&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(ch == <span class="hljs-string">&#x27;[&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(ch == <span class="hljs-string">&#x27;&#123;&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>        <span class="hljs-keyword">if</span>(ch == <span class="hljs-string">&#x27;)&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">4</span>;<br>        <span class="hljs-keyword">if</span>(ch == <span class="hljs-string">&#x27;]&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">5</span>;<br>        <span class="hljs-keyword">if</span>(ch == <span class="hljs-string">&#x27;&#125;&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">6</span>;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>判断括号的有效性可以使用「栈」这一数据结构来解决。</p><p>我们遍历给定的字符串 s。当我们遇到一个左括号时，我们会期望在后续的遍历中，有一个相同类型的右括号将其闭合。由于后遇到的左括号要先闭合，因此我们可以将这个左括号放入栈顶。</p><p>当我们遇到一个右括号时，我们需要将一个相同类型的左括号闭合。此时，我们可以取出栈顶的左括号并判断它们是否是相同类型的括号。如果不是相同的类型，或者栈中并没有左括号，那么字符串 s 无效，返回 False。为了快速判断括号的类型，我们可以使用哈希表存储每一种括号。哈希表的键为右括号，值为相同类型的左括号。</p><p>在遍历结束后，如果栈中没有左括号，说明我们将字符串 s 中的所有左括号闭合，返回 True，否则返回 False。</p><p>注意到有效字符串的长度一定为偶数，因此如果字符串的长度为奇数，我们可以直接返回 False，省去后续的遍历判断过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValid</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = s.length();<br>        <span class="hljs-keyword">if</span> (n % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br><br>        Map&lt;Character, Character&gt; pairs = <span class="hljs-keyword">new</span> HashMap&lt;Character, Character&gt;() &#123;&#123;<br>            put(<span class="hljs-string">&#x27;)&#x27;</span>, <span class="hljs-string">&#x27;(&#x27;</span>);<br>            put(<span class="hljs-string">&#x27;]&#x27;</span>, <span class="hljs-string">&#x27;[&#x27;</span>);<br>            put(<span class="hljs-string">&#x27;&#125;&#x27;</span>, <span class="hljs-string">&#x27;&#123;&#x27;</span>);<br>        &#125;&#125;;<br>        Deque&lt;Character&gt; stack = <span class="hljs-keyword">new</span> LinkedList&lt;Character&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">char</span> ch = s.charAt(i);<br>            <span class="hljs-keyword">if</span> (pairs.containsKey(ch)) &#123;<br>                <span class="hljs-keyword">if</span> (stack.isEmpty() || stack.peek() != pairs.get(ch)) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>                &#125;<br>                stack.pop();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                stack.push(ch);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> stack.isEmpty();<br>    &#125;<br>&#125;<br><br>作者：LeetCode-Solution<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/valid-parentheses/solution/you-xiao-de-gua-hao-by-leetcode-solution/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Notes - 15</title>
    <link href="/2021/07/30/LeetCode-Notes-15/"/>
    <url>/2021/07/30/LeetCode-Notes-15/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-Day-8"><a href="#Leetcode-Day-8" class="headerlink" title="Leetcode - Day 8"></a>Leetcode - Day 8</h1><p>题目：<strong>15. 三数之和</strong></p><p>难度：<strong>中等</strong></p><p>遇见次数：<strong>第一次</strong></p><p>涉及知识点：</p><ul><li>双指针</li><li>数组</li></ul><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="1-原地修改"><a href="#1-原地修改" class="headerlink" title="1. 原地修改"></a>1. 原地修改</h3><p><strong>《超 出 时 间 限 制》</strong>🤣</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="hljs-keyword">int</span>[] nums) &#123;<br>        <span class="hljs-keyword">if</span>(nums.length &lt; <span class="hljs-number">3</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();<br>        &#125;<br><br>        Arrays.sort(nums);<br>        <br>        List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();<br>        Map&lt;String, List&lt;Integer&gt;&gt; myHashmap = <span class="hljs-keyword">new</span> HashMap&lt;String, List&lt;Integer&gt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>; a &lt; nums.length - <span class="hljs-number">2</span>; a++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> b = a + <span class="hljs-number">1</span>; b &lt; nums.length - <span class="hljs-number">1</span>; b++)&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> c = b + <span class="hljs-number">1</span>; c &lt; nums.length; c++)&#123;<br>                    <span class="hljs-keyword">if</span>(nums[a] + nums[b] == -nums[c])&#123;<br>                        List&lt;Integer&gt; curNew = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>                        String curStr = <span class="hljs-string">&quot;&quot;</span>;<br>                        <br>                        curNew.add(nums[a]);<br>                        curNew.add(nums[b]);<br>                        curNew.add(nums[c]);<br><br>                        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i : curNew)&#123;<br>                            curStr = curStr + String.format(<span class="hljs-string">&quot;%d&quot;</span>, i);<br>                        &#125;<br><br>                        <span class="hljs-keyword">if</span>(myHashmap.containsKey(curStr))&#123;<br>                            <span class="hljs-keyword">continue</span>;<br>                        &#125;<br>                        <span class="hljs-keyword">else</span>&#123;<br>                            myHashmap.put(curStr,curNew);<br>                            ans.add(curNew);<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="排序-双指针"><a href="#排序-双指针" class="headerlink" title="排序+双指针"></a>排序+双指针</h3><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210730231301770.png" alt="题解"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="hljs-keyword">int</span>[] nums) &#123;<br>    List&lt;List&lt;Integer&gt;&gt; lists = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-comment">//排序</span><br>    Arrays.sort(nums);<br>    <span class="hljs-comment">//双指针</span><br>    <span class="hljs-keyword">int</span> len = nums.length;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; len;++i) &#123;<br>        <span class="hljs-keyword">if</span>(nums[i] &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> lists;<br><br>        <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i-<span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br><br>        <span class="hljs-keyword">int</span> curr = nums[i];<br>        <span class="hljs-keyword">int</span> L = i+<span class="hljs-number">1</span>, R = len-<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (L &lt; R) &#123;<br>            <span class="hljs-keyword">int</span> tmp = curr + nums[L] + nums[R];<br>            <span class="hljs-keyword">if</span>(tmp == <span class="hljs-number">0</span>) &#123;<br>                List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>                list.add(curr);<br>                list.add(nums[L]);<br>                list.add(nums[R]);<br>                lists.add(list);<br>                <span class="hljs-keyword">while</span>(L &lt; R &amp;&amp; nums[L+<span class="hljs-number">1</span>] == nums[L]) ++L;<br>                <span class="hljs-keyword">while</span> (L &lt; R &amp;&amp; nums[R-<span class="hljs-number">1</span>] == nums[R]) --R;<br>                ++L;<br>                --R;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(tmp &lt; <span class="hljs-number">0</span>) &#123;<br>                ++L;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                --R;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> lists;<br>&#125;<br><br>作者：wu_yan_zu<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/3sum/solution/pai-xu-shuang-zhi-zhen-zhu-xing-jie-shi-python3-by/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Notes - 206</title>
    <link href="/2021/07/30/LeetCode-Notes-206/"/>
    <url>/2021/07/30/LeetCode-Notes-206/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-Day-8"><a href="#Leetcode-Day-8" class="headerlink" title="Leetcode - Day 8"></a>Leetcode - Day 8</h1><p>题目：<strong>206. 反转链表</strong></p><p>难度：<strong>简单</strong></p><p>遇见次数：<strong>第一次</strong></p><p>涉及知识点：</p><ul><li>链表</li></ul><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="1-三指针原地修改"><a href="#1-三指针原地修改" class="headerlink" title="1. 三指针原地修改"></a>1. 三指针原地修改</h3><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210730163151525.png" alt="提交情况"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(head.next == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br><br>        ListNode nextNode = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);<br>        ListNode preNode = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);<br><br>        nextNode.next = head.next;<br>        head.next = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">do</span>&#123;<br>            preNode.next = head;<br><br>            head = nextNode.next;<br><br>            nextNode.next = nextNode.next.next;<br><br>            head.next = preNode.next;<br>        &#125;<span class="hljs-keyword">while</span>(nextNode.next != <span class="hljs-keyword">null</span>);<br><br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><p>在遍历链表时，将当前节点的 <code>next</code> 指针改为指向前一个节点。由于节点没有引用其前一个节点，因此必须事先存储其前一个节点。在更改引用之前，还需要存储后一个节点。最后返回新的头引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>        ListNode prev = <span class="hljs-keyword">null</span>;<br>        ListNode curr = head;<br>        <span class="hljs-keyword">while</span> (curr != <span class="hljs-keyword">null</span>) &#123;<br>            ListNode next = curr.next;<br>            curr.next = prev;<br>            prev = curr;<br>            curr = next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> prev;<br>    &#125;<br>&#125;<br><br>作者：LeetCode-Solution<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/reverse-linked-list/solution/fan-zhuan-lian-biao-by-leetcode-solution-d1k2/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><blockquote><p>优于题解不解释</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Leetcode Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Notes - 83</title>
    <link href="/2021/07/30/LeetCode-Notes-83/"/>
    <url>/2021/07/30/LeetCode-Notes-83/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-Day-8"><a href="#Leetcode-Day-8" class="headerlink" title="Leetcode - Day 8"></a>Leetcode - Day 8</h1><p>题目：<strong>83. 删除排序链表中的重复元素</strong></p><p>难度：<strong>简单</strong></p><p>遇见次数：<strong>第一次</strong></p><p>涉及知识点：</p><ul><li>链表</li></ul><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="1-快慢指针-哈希表"><a href="#1-快慢指针-哈希表" class="headerlink" title="1. 快慢指针+哈希表"></a>1. 快慢指针+哈希表</h3><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210730180813688.png" alt="提交情况"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">deleteDuplicates</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(head.next == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br><br>        Set&lt;Integer&gt; myHashset = <span class="hljs-keyword">new</span> HashSet&lt;Integer&gt;();<br>        ListNode fast = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>, head.next);<br>        ListNode ans = head;<br><br>        myHashset.add(head.val);<br>        <span class="hljs-keyword">while</span>(fast.next != <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">if</span>(myHashset.contains(fast.next.val))&#123;<br>                head.next = <span class="hljs-keyword">null</span>;<br>                fast.next = fast.next.next;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                myHashset.add(fast.next.val);<br>                head.next = fast.next;<br>                head = head.next;<br>                fast.next = fast.next.next;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="迭代一次遍历"><a href="#迭代一次遍历" class="headerlink" title="迭代一次遍历"></a>迭代一次遍历</h3><h4 id="思路与算法"><a href="#思路与算法" class="headerlink" title="思路与算法"></a>思路与算法</h4><p>由于给定的链表是排好序的，因此重复的元素在链表中出现的位置是连续的，因此我们只需要对链表进行一次遍历，就可以删除重复的元素。</p><p>具体地，我们从指针 cur 指向链表的头节点，随后开始对链表进行遍历。如果当前 cur 与 cur.next 对应的元素相同，那么我们就将 cur.next 从链表中移除；否则说明链表中已经不存在其它与 cur 对应的元素相同的节点，因此可以将 cur 指向 cur.next。</p><p>当遍历完整个链表之后，我们返回链表的头节点即可。</p><h4 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h4><p>当我们遍历到链表的最后一个节点时，cur.next 为空节点，如果不加以判断，访问 cur.next 对应的元素会产生运行错误。因此我们只需要遍历到链表的最后一个节点，而不需要遍历完整个链表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">deleteDuplicates</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br><br>        ListNode cur = head;<br>        <span class="hljs-keyword">while</span> (cur.next != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (cur.val == cur.next.val) &#123;<br>                cur.next = cur.next.next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                cur = cur.next;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;<br><br>作者：LeetCode-Solution<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/remove-duplicates-from-sorted-list/solution/shan-chu-pai-xu-lian-biao-zhong-de-zhong-49v5/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Notes - 3</title>
    <link href="/2021/07/30/LeetCode-Notes-3/"/>
    <url>/2021/07/30/LeetCode-Notes-3/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-Day-8"><a href="#Leetcode-Day-8" class="headerlink" title="Leetcode - Day 8"></a>Leetcode - Day 8</h1><p>题目：<strong>3. 无重复字符的最长字串</strong></p><p>难度：<strong>简单</strong></p><p>遇见次数：<strong>第二次</strong></p><p>涉及知识点：</p><ul><li>字符串</li><li>哈希集合</li><li>滑动窗口</li></ul><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="1-滑动窗口"><a href="#1-滑动窗口" class="headerlink" title="1. 滑动窗口"></a>1. 滑动窗口</h3><p>学习后重写版本，之前想的确实不对😔</p><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210730154841165.png" alt="提交情况"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(s.length() == <span class="hljs-number">0</span> || s.length() == <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> s.length();<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> maxLen = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">char</span>[] strArr = s.toCharArray();<br>        Set&lt;Character&gt; myHashset = <span class="hljs-keyword">new</span> HashSet&lt;Character&gt;();<br><br>        <span class="hljs-keyword">int</span> right = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br><br>        myHashset.add(strArr[left]);<br>        <span class="hljs-keyword">while</span>(right &lt; strArr.length)&#123;<br>            <span class="hljs-keyword">if</span>(myHashset.contains(strArr[right]))&#123;<br>                myHashset.remove(strArr[left]);<br>                left++;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                maxLen = Math.max(maxLen, right - left + <span class="hljs-number">1</span>);<br>                myHashset.add(strArr[right]);<br>                right++;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> maxLen;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><p>首先，判断当前字符是否包含在map中，如果不包含，将该字符添加到map（字符，字符在数组下标）,<br>此时没有出现重复的字符，左指针不需要变化。</p><p>此时不重复子串的长度为：i-left+1，与原来的maxLen比较，取最大值；</p><p>如果当前字符 ch 包含在 map中，此时有2类情况：</p><ul><li>当前字符包含在当前有效的子段中，如：abca，当我们遍历到第二个a，当前有效最长子段是 abc，我们又遍历到a，那么此时更新 left 为 map.get(a)+1=1，当前有效子段更新为 bca；</li><li>当前字符不包含在当前最长有效子段中，如：abba，我们先添加a,b进map，此时left=0，我们再添加b，发现map中包含b，而且b包含在最长有效子段中，就是1）的情况，我们更新 left=map.get(b)+1=2，此时子段更新为 b，而且map中仍然包含a，map.get(a)=0；</li></ul><p>随后，我们遍历到a，发现a包含在map中，且map.get(a)=0，如果我们像上述第一种情况一样处理，就会发现</p><blockquote><p> left=map.get(a)+1=1</p></blockquote><p>实际上，left此时应该不变，left始终为2，子段变成 ba才对。</p><ul><li>为了处理以上2类情况，我们每次更新left，left=Math.max(left , map.get(ch)+1).</li><li>另外，更新left后，不管原来的 s.charAt(i) 是否在最长子段中，我们都要将 s.charAt(i) 的位置更新为当前的i，因此此时新的 s.charAt(i) 已经进入到 当前最长的子段中！</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        HashMap&lt;Character, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        <span class="hljs-keyword">int</span> maxLen = <span class="hljs-number">0</span>;<span class="hljs-comment">//用于记录最大不重复子串的长度</span><br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<span class="hljs-comment">//滑动窗口左指针</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.length() ; i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(map.containsKey(s.charAt(i)))<br>            &#123;<br>                left = Math.max(left , map.get(s.charAt(i))+<span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-comment">//不管是否更新left，都要更新 s.charAt(i) 的位置！</span><br>            map.put(s.charAt(i) , i);<br>            maxLen = Math.max(maxLen , i-left+<span class="hljs-number">1</span>);<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> maxLen;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Notes - 203</title>
    <link href="/2021/07/29/LeetCode-Notes-203/"/>
    <url>/2021/07/29/LeetCode-Notes-203/</url>
    
    <content type="html"><![CDATA[<h2 id="Leetcode-Day-7"><a href="#Leetcode-Day-7" class="headerlink" title="Leetcode - Day 7"></a>Leetcode - Day 7</h2><p>题目：<strong>203. 移除链表元素</strong></p><p>难度：<strong>简单</strong></p><p>遇见次数：<strong>第一次</strong></p><p>涉及知识点：</p><ul><li>链表</li></ul><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="1-原地修改"><a href="#1-原地修改" class="headerlink" title="1. 原地修改"></a>1. 原地修改</h3><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210729123540821.png" alt="提交情况"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">removeElements</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>        ListNode ans;<br><br>        <span class="hljs-keyword">while</span>(head != <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">if</span>(head.val == val)&#123;<br>                head = head.next;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        ans = head;<br><br>        <span class="hljs-keyword">if</span>(ans == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> ans;<br>        &#125;<br><br>        <span class="hljs-keyword">while</span>(head.next != <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">if</span>(head.next.val == val)&#123;<br>                head.next = head.next.next;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                head = head.next;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210729123702255.png" alt="官方题解"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">removeElements</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>        ListNode dummyHead = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);<br>        dummyHead.next = head;<br>        ListNode temp = dummyHead;<br>        <span class="hljs-keyword">while</span> (temp.next != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (temp.next.val == val) &#123;<br>                temp.next = temp.next.next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                temp = temp.next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummyHead.next;<br>    &#125;<br>&#125;<br><br>作者：LeetCode-Solution<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/remove-linked-list-elements/solution/yi-chu-lian-biao-yuan-su-by-leetcode-sol-654m/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><blockquote><p>哑头结点创建</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Leetcode Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Notes - 141</title>
    <link href="/2021/07/29/LeetCode-Notes-141/"/>
    <url>/2021/07/29/LeetCode-Notes-141/</url>
    
    <content type="html"><![CDATA[<h2 id="Leetcode-Day-7"><a href="#Leetcode-Day-7" class="headerlink" title="Leetcode - Day 7"></a>Leetcode - Day 7</h2><p>题目：<strong>141. 环形链表</strong></p><p>难度：<strong>简单</strong></p><p>遇见次数：<strong>第一次</strong></p><p>涉及知识点：</p><ul><li>字符串</li><li>哈希表</li></ul><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="1-哈希记录节点"><a href="#1-哈希记录节点" class="headerlink" title="1. 哈希记录节点"></a>1. 哈希记录节点</h3><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210729110135271.png" alt="提交情况"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode(int x) &#123;</span><br><span class="hljs-comment"> *         val = x;</span><br><span class="hljs-comment"> *         next = null;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br><br>        Set&lt;ListNode&gt; checkMap = <span class="hljs-keyword">new</span> HashSet&lt;ListNode&gt;();<br><br>        <span class="hljs-keyword">while</span>(head != <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">if</span>(checkMap.contains(head))&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br><br>            checkMap.add(head);<br>            head = head.next;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h3><h4 id="思路及算法"><a href="#思路及算法" class="headerlink" title="思路及算法"></a>思路及算法</h4><p>本方法需要读者对「Floyd 判圈算法」（又称龟兔赛跑算法）有所了解。</p><p>假想「乌龟」和「兔子」在链表上移动，「兔子」跑得快，「乌龟」跑得慢。当「乌龟」和「兔子」从链表上的同一个节点开始移动时，如果该链表中没有环，那么「兔子」将一直处于「乌龟」的前方；如果该链表中有环，那么「兔子」会先于「乌龟」进入环，并且一直在环内移动。等到「乌龟」进入环时，由于「兔子」的速度快，它一定会在某个时刻与乌龟相遇，即套了「乌龟」若干圈。</p><p>我们可以根据上述思路来解决本题。具体地，我们定义两个指针，一快一满。慢指针每次只移动一步，而快指针每次移动两步。初始时，慢指针在位置 <code>head</code>，而快指针在位置 <code>head.next</code>。这样一来，如果在移动的过程中，快指针反过来追上慢指针，就说明该链表为环形链表。否则快指针将到达链表尾部，该链表不为环形链表。</p><h4 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h4><p>为什么我们要规定初始时慢指针在位置 <code>head</code>，快指针在位置 <code>head.next</code>，而不是两个指针都在位置 <code>head</code>（即与「乌龟」和「兔子」中的叙述相同）？</p><p>观察下面的代码，我们使用的是 while 循环，循环条件先于循环体。由于循环条件一定是判断快慢指针是否重合，如果我们将两个指针初始都置于 head，那么 while 循环就不会执行。因此，我们可以假想一个在 head 之前的虚拟节点，慢指针从虚拟节点移动一步到达 head，快指针从虚拟节点移动两步到达 head.next，这样我们就可以使用 while 循环了。</p><p>当然，我们也可以使用 do-while 循环。此时，我们就可以把快慢指针的初始值都置为 head。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span> || head.next == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        <br>        ListNode slow = head;<br>        ListNode fast = head;<br>        <span class="hljs-keyword">do</span>&#123;<br>            <span class="hljs-keyword">if</span> (fast == <span class="hljs-keyword">null</span> || fast.next == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>            slow = slow.next;<br>            fast = fast.next.next;<br>        &#125; <span class="hljs-keyword">while</span>(slow != fast);<br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Notes - 21</title>
    <link href="/2021/07/29/LeetCode-Notes-21/"/>
    <url>/2021/07/29/LeetCode-Notes-21/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-Day-7"><a href="#Leetcode-Day-7" class="headerlink" title="Leetcode - Day 7"></a>Leetcode - Day 7</h1><p>题目：<strong>21. 合并两个有序链表</strong></p><p>难度：<strong>简单</strong></p><p>遇见次数：<strong>第二次</strong></p><p>涉及知识点：</p><ul><li>链表</li></ul><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="1-一次遍历"><a href="#1-一次遍历" class="headerlink" title="1. 一次遍历"></a>1. 一次遍历</h3><p>双指针一次遍历，空间复杂度优于题解🛫</p><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210729130352882.png" alt="提交情况"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(l1 == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> l2;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(l2 == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> l1;<br>        &#125;<br><br>        ListNode ans;<br><br>        ans = l1.val &gt; l2.val ? l2 : l1;<br>        ListNode dummy;<br>        <span class="hljs-keyword">while</span>(l1 != <span class="hljs-keyword">null</span> &amp;&amp; l2 != <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">if</span>(l1.val &lt;= l2.val)&#123;<br>                <span class="hljs-keyword">do</span>&#123;<br>                    dummy = l1;<br>                    l1 = l1.next;<br><br>                    <span class="hljs-keyword">if</span>(l1 == <span class="hljs-keyword">null</span>)&#123;<br>                        dummy.next = l2;<br>                        <span class="hljs-keyword">return</span> ans;<br>                    &#125;<br>                &#125;<span class="hljs-keyword">while</span>(l1.val &lt;= l2.val);<br><br>                dummy.next = l2;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span>(l1.val &gt; l2.val)&#123;<br>                <span class="hljs-keyword">do</span>&#123;<br>                    dummy = l2;<br>                    l2 = l2.next;<br><br>                    <span class="hljs-keyword">if</span>(l2 == <span class="hljs-keyword">null</span>)&#123;<br>                        dummy.next = l1;<br>                        <span class="hljs-keyword">return</span> ans;<br>                    &#125;<br>                &#125;<span class="hljs-keyword">while</span>(l1.val &gt; l2.val);<br><br>                dummy.next = l1;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>我们可以如下递归地定义两个链表里的 <code>merge</code> 操作（忽略边界情况，比如空链表等）：</p><p><img src="https://alipicbed.oss-cn-beijing.aliyuncs.com/img/image-20210729130732855.png" alt="递归条件"></p><p>也就是说，两个链表头部值较小的一个节点与剩下元素的 <code>merge</code> 操作结果合并。</p><h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><p>我们直接将以上递归过程建模，同时需要考虑边界情况。</p><p>如果 <code>l1</code> 或者 <code>l2</code> 一开始就是空链表 ，那么没有任何操作需要合并，所以我们只需要返回非空链表。否则，我们要判断 <code>l1</code> 和 <code>l2</code> 哪一个链表的头节点的值更小，然后递归地决定下一个添加到结果里的节点。如果两个链表有一个为空，递归结束。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (l1 == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> l2;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (l2 == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> l1;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (l1.val &lt; l2.val) &#123;<br>            l1.next = mergeTwoLists(l1.next, l2);<br>            <span class="hljs-keyword">return</span> l1;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            l2.next = mergeTwoLists(l1, l2.next);<br>            <span class="hljs-keyword">return</span> l2;<br>        &#125;<br><br>    &#125;<br>&#125;<br><br>作者：LeetCode-Solution<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/merge-two-sorted-lists/solution/he-bing-liang-ge-you-xu-lian-biao-by-leetcode-solu/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Notes - 383</title>
    <link href="/2021/07/28/LeetCode-Notes-383/"/>
    <url>/2021/07/28/LeetCode-Notes-383/</url>
    
    <content type="html"><![CDATA[<h2 id="Leetcode-Day-6"><a href="#Leetcode-Day-6" class="headerlink" title="Leetcode - Day 6"></a>Leetcode - Day 6</h2><p>题目：<strong>383. 赎金信</strong></p><p>难度：<strong>简单</strong></p><p>遇见次数：<strong>第一次</strong></p><p>涉及知识点：</p><ul><li>字符串</li><li>哈希表</li></ul><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="1-字母哈希计数"><a href="#1-字母哈希计数" class="headerlink" title="1. 字母哈希计数"></a>1. 字母哈希计数</h3><p><img src="https://typorastroage.oss-cn-beijing.aliyuncs.com/img/image-20210728120715643.png" alt="提交结果"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">canConstruct</span><span class="hljs-params">(String ransomNote, String magazine)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(magazine.length() == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">int</span>[] dicArr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">26</span>];<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> ch1 : magazine.toCharArray())&#123;<br>            dicArr[ch1 - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> ch2 : ransomNote.toCharArray())&#123;<br>            dicArr[ch2 - <span class="hljs-string">&#x27;a&#x27;</span>]--;<br><br>            <span class="hljs-keyword">if</span>(dicArr[ch2 - <span class="hljs-string">&#x27;a&#x27;</span>] &lt; <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ul><li>利用大小26的数组来进行计数</li><li>避免使用 <code>charAt()</code> 方法，因为每次调用它会检查一遍索引值是否越界，时间复杂度就会上去</li></ul>]]></content>
    
    
    <categories>
      
      <category>Leetcode Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2021/07/24/hello-world/"/>
    <url>/2021/07/24/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
